.版本 2
.支持库 ehalcon

.程序集 窗口程序集1

.子程序 __启动窗口_创建完毕

视_调试配置 (G (#视_调试_发生错误暂停, #视_调试_启用))  ' 这一行是启用调试的，如果程序中发生执行错误，则会暂停以方便检查异常
主程序 ()

.子程序 主程序
.局部变量 Button, tuple
.局部变量 ClampsModelExists, tuple
.局部变量 Col, tuple
.局部变量 CookieModelExists, tuple
.局部变量 CylinderModelExists, tuple
.局部变量 NumCurrent, tuple
.局部变量 NumTotal, tuple
.局部变量 Row, tuple
.局部变量 StatusWindowHandle, tuple
.局部变量 mCount, tuple


' Explore the Power of HALCON
' (c) 2005-2010 MVTec Software GmbH


' Attention: Due to space restrictions, the downloaded HALCON installation
' potentially does not include the pre-generated models used for the following
' application procedures:
' (A) p_do_cylinder_3d
' (B) p_do_cookie_box
' (C) p_do_3d_matching_clamps
' In this case, for using these application procedures also in
' "Explore the Power of HALCON", the models have to be generated
' by running the corresponding HDevelop example programs once:
' (A) Applications/Object-Recognition-3D/locate_cylinder_3d.hdev (cylinder.sm3)
' (B) Applications/Object-Recognition-2D/locate_cookie_box.hdev (cookie_box_model.dsm)
' (C) Applications/Position-Recognition-3D/3d_matching_clamps.hdev (clamp_sloped_35.sm3)

' When starting the application, the procedure do_check_for_model_files
' checks for the presence of these three model files. If any of these
' files are missing by the time you run explore_halcon.hdev, the respective
' procedure will be omitted.

do_check_for_model_files (CylinderModelExists, CookieModelExists, ClampsModelExists)
视_设值 (mCount, 视_加 (视_加 (CylinderModelExists, CookieModelExists), ClampsModelExists))


' To run this application continuously, simply uncomment the while statement:
' * while (1)

' p_show_intro ()

p_initialize (StatusWindowHandle)
dev_set_check (“~give_error”)
get_mposition (StatusWindowHandle, Row, Col, Button)
dev_set_check (“give_error”)
视_设值 (NumCurrent, 0)
视_设值 (NumTotal, 视_加 (49, mCount))
' p_do_locate_pipe_joints_stereo ()
p_do_clips ()
.如果 (视_是否为真 (CylinderModelExists))
    视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
    p_show_status_window (G (“”), G (“3D Matching”), G (“for Bin Picking”), G (“Locate Metallic Cylinder on a Heap”), NumCurrent, NumTotal, StatusWindowHandle)
    p_do_cylinder_3d ()
    wait_seconds (1)
.否则

.如果结束

.如果 (视_是否为真 (CookieModelExists))
    视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
    p_show_status_window (G (“”), G (“Descriptor-based”), G (“Matching”), G (“Determine Pose of Cookie Box”), NumCurrent, NumTotal, StatusWindowHandle)
    p_do_cookie_box ()
    wait_seconds (1)
.否则

.如果结束

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“Perspective”), G (“Deformable Matching”), G (“for automotive Industry”), G (“Locate Engine Parts in a Box”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_locate_engine_parts ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“Monitoring”), G (“Using Perspective”), G (“Deformable Matching”), G (“Detect Road Signs”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_detect_road_signs ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Inspection”), G (“Using GMM Classifier”), G (“Inspect Pill Types in a Blister”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_blister_mixed ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“Multi-View Stereo”), G (“Reconstruction and ”), G (“3D Surface Based Matching”), G (“Locate Pipe Joints from a Pile”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_locate_pipe_joints_stereo ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Identification”), G (“of Data Codes”), G (“Read Distorted ECC200 Codes”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_ecc200_finder_pattern_tolerance ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Inspection for”), G (“Packaging Industry”), G (“Inspect Bottle Mouth for Damages”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_bottle_mouth ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Robot Vision”), G (“for Automotive Industry”), G (“Track an Engine Part”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_track_engine_part ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“Perspective”), G (“Deformable Matching”), G (“for Automotive Industry”), G (“Determine Pose of a Car Component”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_car_door ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Sheet of Light”), G (“”), G (“Reconstruct Connection Rod”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_reconstruct_connection_rod_uncalib ()
wait_seconds (1)

.如果 (视_是否为真 (ClampsModelExists))
    视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
    p_show_status_window (G (“”), G (“3D Matching”), G (“Based on a CAD Model”), G (“Find Objects in Arbitrary 3D Poses”), NumCurrent, NumTotal, StatusWindowHandle)
    p_do_3d_matching_clamps ()
    wait_seconds (1)
.否则

.如果结束

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“OCR”), G (“Text Line Orientation”), G (“Detect Rotated Dot Prints”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_textline_orientation ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Local Deformable Matching”), G (“for Food Industry”), G (“Locate Cocoa Packages”), NumCurrent, NumTotal, StatusWindowHandle)
p_find_cocoa_package_local_deformable ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Segmentation”), G (“Using a GMM Classifier”), G (“Detect Errors in a Mesh”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_novelty_detection_gmm ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Correlation-Based”), G (“Matching”), G (“Matching on Defocused Images”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_find_ncc_model_defocused ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“3D Rectangle Pose”), G (“”), G (“Get the 3D Position of Rectangular Objects”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_3d_position_of_rectangle ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Optical Flow”), G (“”), G (“Detection of Moving Objects”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_optical_flow_bicycle ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Print Inspection”), G (“”), G (“Print Inspection using a Variation Model”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_variation_model_illumination ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Board Inspection”), G (“”), G (“Inspect the Radius of Bonding Balls”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_balls ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Optical Character”), G (“Recognition”), G (“Extract the ID Number of Parcels”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_ocr_color ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“3D Measurements”), G (“Using Binocular Stereo”), G (“Extract Board Components Using Stereo Images”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_stereo ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Inpainting”), G (“”), G (“Fill Up Gaps in a Distance Image”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_inpainting ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Identification”), G (“2D Data Codes”), G (“Read ECC 200, QR Data Codes and PDF417”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_2dbarcode ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“PCB Inspection”), G (“”), G (“Detect Defects on a Printed Circuit Board”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_pcb ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Image Enhancement”), G (“”), G (“Enhance Faint and Fragmented Structure”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_enhancement ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Shape-Based Matching under”), G (“Perspective Distortions”), G (“Locate Metal Parts in 3D World Coordinates”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_world_plane ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Board Inspection”), G (“Using Shape-Based Matching”), G (“Measure Leads of a Moving IC”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_measure_board ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Color Image Processing”), G (“”), G (“Segment Fuses using Color Information”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_color_fuses ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Position Recognition”), G (“of Compound Objects”), G (“Locate a Pipe Wrench in Different States”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_component_matching ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Image Mosaicking”), G (“Using Bundle Adjustment”), G (“Create Image Mosaic of a Die”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_mosaicking ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Inspection”), G (“of Non-Planar Surfaces”), G (“Rectify the Surface of a Can”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_grid_rectification ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Uncalibrated”), G (“Binocular Stereo”), G (“Segment Board Components by Uncalibrated Stereo”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_stereo_uncal ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Completeness Check”), G (“”), G (“Inspect a Punching Die of Razors”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_razor_blades ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“3D Measurements”), G (“in World Coordinates”), G (“Measure Pitch Lines of a Caliper”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_measure_3d ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Medical Image Analysis”), G (“Subpixel Line Detection”), G (“Find and Measure Vessels in an Angiographic Image”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_angio ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Color Image Processing”), G (“”), G (“Extract Colored Wires of a Connector”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_color_lines ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Projective Transformations”), G (“”), G (“Apply Projective Transformations”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_projective_points ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Industrial Inspection”), G (“”), G (“Measure the Radius of Steel Balls”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_circles ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“3D Reconstruction”), G (“”), G (“Inspect a Resistor Using Depth From Focus”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_resistors ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“2D Measurements”), G (“with High Accuracy”), G (“Measure the Leads of an IC”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_measure_leads ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Shape Recognition”), G (“Using Shape-Based Matching”), G (“Recognize Different Coins”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_match_coins ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“2D Measurements”), G (“of Circular Arcs”), G (“Inspect Parts of a Flange”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_measure_arc ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Remote Sensing”), G (“”), G (“Extract Roads from an Aerial Image”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_roads ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“2D Measurements”), G (“”), G (“Measure the Diameter of Holes”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_measure_rim ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Shape Recognition”), G (“Using Shape-Based Matching”), G (“Recognize Multiple Metal Parts”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_multiple_parts ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Surveillance”), G (“”), G (“Monitor Cars and People on a Crossing”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_xing ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Position Recognition”), G (“”), G (“Determine Orientation of Clips”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_clips ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Print Inspection”), G (“”), G (“Inspect the Print on a Pen Clip”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_print_check ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“3D Measurement”), G (“”), G (“Get the 3D Position of Circular Holes”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_3d_position_of_circles ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Wood Inspection”), G (“”), G (“Determine the Age of a Tree”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_wood ()
wait_seconds (1)

视_设值 (NumCurrent, 视_加 (NumCurrent, 1))
p_show_status_window (G (“”), G (“Projective Transformations”), G (“and Texture Mapping”), G (“Project the MVTec Logo into the Olympic Stadium”), NumCurrent, NumTotal, StatusWindowHandle)
p_do_projective_trans ()
wait_seconds (1)

dev_close_window ()
p_show_end ()

' * endwhile


.子程序 p_initialize
.参数 StatusWindowHandle, tuple, 参考

dev_update_window (“off”)
dev_update_pc (“on”)

dev_close_window ()
dev_close_window ()
dev_open_window (0, 653, 361, 266, “black”, StatusWindowHandle)

返回 ()

.子程序 p_show_status_window
.参数 TitleCurrent0, tuple
.参数 TitleCurrent1, tuple
.参数 TitleCurrent2, tuple
.参数 TitleCurrentApplication, tuple
.参数 NumCurrent, tuple
.参数 NumTotal, tuple
.参数 StatusWindow, tuple
.局部变量 Ascent, tuple
.局部变量 Background, obj
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 Descent, tuple
.局部变量 Height, tuple
.局部变量 Path, tuple
.局部变量 Pointer, tuple
.局部变量 PosCol, tuple
.局部变量 PosRow, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 StatusBackground, obj
.局部变量 Step, tuple
.局部变量 Type, tuple
.局部变量 WWidth, tuple
.局部变量 Width, tuple
.局部变量 WindowHandleTitle, tuple


' Show status window and current titles

视_设值 (Path, “explore_10/”)

p_set_font (StatusWindow)
dev_set_window (StatusWindow)
dev_set_part (0, 0, 265, 360)
read_image (StatusBackground, 视_加 (Path, “explore_halcon_bg”))
dev_display (StatusBackground)

' mvtec blue
set_rgb (StatusWindow, 0, 48, 117)
dev_set_line_width (1)

视_设值 (WWidth, 361)
视_设值 (Step, 视_除 (视_减 (WWidth, 视_乘 (2, 13)), NumTotal))
视_设值 (Row1, gen_tuple_const (NumTotal, 140))
tuple_gen_sequence (13, 视_加 (13, 视_乘 (视_减 (NumTotal, 1), Step)), Step, Column1)
视_设值 (Row2, gen_tuple_const (NumTotal, 150))
视_设值 (Column2, 视_加 (Column1, 视_减 (Step, 2)))
dev_set_draw (“fill”)
disp_rectangle1 (StatusWindow, 视_取元素范围 (Row1, 0, 视_减 (NumCurrent, 1)), 视_取元素范围 (Column1, 0, 视_减 (NumCurrent, 1)), 视_取元素范围 (Row2, 0, 视_减 (NumCurrent, 1)), 视_取元素范围 (Column2, 0, 视_减 (NumCurrent, 1)))
dev_set_draw (“margin”)
disp_rectangle1 (StatusWindow, 视_取元素范围 (Row1, NumCurrent, 视_减 (NumTotal, 1)), 视_取元素范围 (Column1, NumCurrent, 视_减 (NumTotal, 1)), 视_取元素范围 (Row2, NumCurrent, 视_减 (NumTotal, 1)), 视_取元素范围 (Column2, NumCurrent, 视_减 (NumTotal, 1)))

set_tposition (StatusWindow, 175, 12)
write_string (StatusWindow, TitleCurrent0)
set_tposition (StatusWindow, 200, 12)
write_string (StatusWindow, TitleCurrent1)
set_tposition (StatusWindow, 225, 12)
write_string (StatusWindow, TitleCurrent2)


dev_open_window (0, 0, 640, 480, “black”, WindowHandleTitle)
read_image (Background, 视_加 (Path, “explore_halcon_next_demo”))
get_image_pointer1 (Background, Pointer, Type, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Background)
p_set_font (WindowHandleTitle)
get_string_extents (WindowHandleTitle, TitleCurrentApplication, Ascent, Descent, Width, Height)
dev_set_part (0, 0, 479, 639)
视_设值 (PosRow, 200)
视_设值 (PosCol, 视_除 (视_减 (640, Width), 到小数 (2)))
' * dev_set_color ('yellow')
set_rgb (WindowHandleTitle, 0, 48, 117)
set_tposition (WindowHandleTitle, PosRow, PosCol)
write_string (WindowHandleTitle, TitleCurrentApplication)
wait_seconds (3)
dev_close_window ()


返回 ()

.子程序 p_do_ocr_color
.局部变量 Blue, obj
.局部变量 Cluster, obj
.局部变量 Cluster1, obj
.局部变量 Cluster2, obj
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 Confidence, tuple
.局部变量 Deviation, tuple
.局部变量 FinalNumbers, obj
.局部变量 FinalNumbersUnsorted, obj
.局部变量 Foreground, obj
.局部变量 ForegroundRaw, obj
.局部变量 Green, obj
.局部变量 GreenReduced, obj
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 ImageMean, obj
.局部变量 ImageOCR, obj
.局部变量 ImageOCRRaw, obj
.局部变量 ImageSub, obj
.局部变量 ImgNr, tuple
.局部变量 Mean, obj
.局部变量 MeanIntensity, tuple
.局部变量 NoNumbers, obj
.局部变量 NumNumbers, tuple
.局部变量 NumberCand, obj
.局部变量 NumberParts, obj
.局部变量 NumberRegion, obj
.局部变量 Numbers, obj
.局部变量 OCRHandle, tuple
.局部变量 Opening, obj
.局部变量 PointerBlue, tuple
.局部变量 PointerGreen, tuple
.局部变量 PointerRed, tuple
.局部变量 RecChar, tuple
.局部变量 Red, obj
.局部变量 RedReduced, obj
.局部变量 RegionFillUp, obj
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WidthCluster, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型


' OCR (numbers) with color segmentation

dev_update_window (“off”)
dev_update_var (“off”)

read_image (Image, “ocr/color_form_01”)
get_image_pointer3 (Image, PointerRed, PointerGreen, PointerBlue, Type, Width, Height)

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)

dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_set_line_width (3)
dev_set_draw (“margin”)
p_set_font (WindowHandle)

read_ocr_class_mlp (“Industrial_0-9”, OCRHandle)
视_设值 (ImgNr, 1)
.变量循环首 (1, 40, 1, i)
    read_image (Image, 视_加 (“ocr/color_form_0”, ImgNr))

    ' Detect foreground

    mean_image (Image, Mean, 3, 3)
    decompose3 (Mean, Red, Green, Blue)
    threshold (Green, ForegroundRaw, 0, 220)
    clip_region (ForegroundRaw, Foreground, 3, 3, 视_减 (Height, 4), 视_减 (Width, 4))

    ' Divide colors

    reduce_domain (Red, Foreground, RedReduced)
    reduce_domain (Green, Foreground, GreenReduced)
    sub_image (RedReduced, GreenReduced, ImageSub, 2, 128)
    mean_image (ImageSub, ImageMean, 3, 3)
    bin_threshold (ImageMean, Cluster1)
    difference (Foreground, Cluster1, Cluster2)
    concat_obj (Cluster1, Cluster2, Cluster)
    opening_circle (Cluster, Opening, 2.5)
    smallest_rectangle1 (Opening, Row1, Column1, Row2, Column2)
    视_设值 (WidthCluster, 视_加 (视_减 (Column2, Column1), 1))
    .如果 (视_大于 (视_取元素 (WidthCluster, 0), 视_取元素 (WidthCluster, 1)))
        select_obj (Opening, NumberRegion, 2)
    .否则
        select_obj (Opening, NumberRegion, 1)
    .如果结束

    ' Expand Numbers

    closing_rectangle1 (NumberRegion, NumberCand, 1, 20)
    difference (Image, NumberCand, NoNumbers)
    connection (NumberRegion, NumberParts)
    intensity (NumberParts, Green, MeanIntensity, Deviation)
    expand_gray_ref (NumberParts, Green, NoNumbers, Numbers, 20, “image”, MeanIntensity, 48)
    union1 (Numbers, NumberRegion)
    connection (NumberRegion, Numbers)

    ' Fine tuning

    fill_up_shape (Numbers, RegionFillUp, “area”, 1, 100)
    opening_circle (RegionFillUp, FinalNumbersUnsorted, 3.5)
    sort_region (FinalNumbersUnsorted, FinalNumbers, “character”, “true”, “row”)
    dev_set_color (“black”)
    dev_display (Image)
    disp_message (WindowHandle, “Extract ID number of parcel”, “window”, -1, -1, “black”, “true”)
    .如果 (视_小于 (i, 3))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则
        ' *         wait_seconds (0.25)
    .如果结束
    dev_display (FinalNumbers)
    count_obj (FinalNumbers, NumNumbers)
    union1 (FinalNumbers, NumberRegion)
    difference (Image, NumberRegion, NoNumbers)
    paint_region (NoNumbers, Green, ImageOCRRaw, 255, “fill”)
    paint_region (NumberRegion, ImageOCRRaw, ImageOCR, 0, “fill”)

    ' OCR

    do_ocr_multi_class_mlp (FinalNumbers, ImageOCR, OCRHandle, RecChar, Confidence)
    disp_message (WindowHandle, 视_加 (“Extracted ID: ”, sum (RecChar)), “window”, 400, -1, “black”, “true”)
    .如果 (视_小于 (i, 3))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (3)
    .否则
        ' *         wait_seconds (0.25)
    .如果结束
    视_设值 (ImgNr, 视_加 (ImgNr, 1))
    .如果 (视_大于 (ImgNr, 8))
        视_设值 (ImgNr, 1)
    .否则

    .如果结束

.变量循环尾 ()
clear_ocr_class_mlp (OCRHandle)
wait_seconds (2)
dev_close_window ()
dev_set_line_width (1)


dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_circles
.局部变量 Attrib, tuple
.局部变量 Column, tuple
.局部变量 ContEllipse, obj
.局部变量 ContoursSplit, obj
.局部变量 Edges, obj
.局部变量 EndPhi, tuple
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 Number, tuple
.局部变量 ObjectSelected, obj
.局部变量 PointOrder, tuple
.局部变量 Radius, tuple
.局部变量 Region, obj
.局部变量 RegionBorder, obj
.局部变量 RegionClipped, obj
.局部变量 RegionDilation, obj
.局部变量 Row, tuple
.局部变量 StartPhi, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 i, 整数型
.局部变量 j, tuple


dev_update_window (“off”)
read_image (Image, “double_circle”)
get_image_size (Image, Width, Height)

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)

dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

dev_display (Image)
disp_message (WindowHandle, “Measure the radius of steel balls”, “window”, -1, -1, “black”, “true”)
fast_threshold (Image, Region, 0, 120, 7)
boundary (Region, RegionBorder, “inner”)
clip_region_rel (RegionBorder, RegionClipped, 5, 5, 5, 5)
dilation_circle (RegionClipped, RegionDilation, 2.5)
reduce_domain (Image, RegionDilation, ImageReduced)
edges_sub_pix (ImageReduced, Edges, “lanser2”, 0.5, 40, 60)
segment_contours_xld (Edges, ContoursSplit, “lines_circles”, 5, 4, 3)
count_obj (ContoursSplit, Number)
dev_set_draw (“margin”)
视_设值 (j, 0)
.变量循环首 (1, DD (Number, ), 1, i)
    dev_set_line_width (3)
    select_obj (ContoursSplit, ObjectSelected, i)
    get_contour_global_attrib_xld (ObjectSelected, “cont_approx”, Attrib)
    .如果 (视_大于 (Attrib, 0))
        fit_circle_contour_xld (ObjectSelected, “ahuber”, -1, 2, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)
        gen_ellipse_contour_xld (ContEllipse, Row, Column, 0, Radius, Radius, 0, 视_乘 (4, acos (0)), “positive”, 到小数 (1))
        dev_set_color (“green”)
        dev_display (ContEllipse)
        .如果 (视_等于 (i, 1))
            dev_set_line_width (1)
            dev_set_color (“blue”)
            disp_line (WindowHandle, 169, 458, 188, 379)
            disp_message (WindowHandle, 视_加 (视_加 (“Radius: ”, 视_文本格式化 (Radius, “5.2f”)), “ px”), “image”, 145, 390, “black”, “true”)

        .否则

        .如果结束
        .如果 (视_等于 (i, 3))
            dev_set_line_width (1)
            dev_set_color (“blue”)
            disp_line (WindowHandle, 268, 181, 356, 213)
            disp_message (WindowHandle, 视_加 (视_加 (“Radius: ”, 视_文本格式化 (Radius, “5.2f”)), “ px”), “window”, 244, 91, “black”, “true”)
        .否则

        .如果结束
        .如果 (视_小于 (Radius, 100))
            dev_set_line_width (1)
            dev_set_color (“blue”)
            disp_line (WindowHandle, 316, 373, 123, 293)
            disp_message (WindowHandle, 视_加 (视_加 (“Radius: ”, 视_文本格式化 (Radius, “5.2f”)), “ px”), “window”, 100, 200, “black”, “true”)
            dev_open_window (205, 20, 256, 256, “black”, WindowHandle1)
            dev_set_part (round (视_减 (Row, 视_加 (Radius, 5))), round (视_减 (Column, 视_加 (Radius, 5))), round (视_加 (Row, 视_加 (Radius, 5))), round (视_加 (Column, 视_加 (Radius, 5))))
            dev_display (Image)
            dev_set_line_width (3)
            dev_set_color (“green”)
            dev_display (ContEllipse)
            wait_seconds (4)
            dev_close_window ()
            dev_set_window (WindowHandle)
            dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
        .否则

        .如果结束
        视_设值 (j, 视_加 (j, 1))
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (4)
dev_close_window ()
dev_set_line_width (1)


返回 ()

.子程序 p_do_measure_arc
.局部变量 Amplitude, tuple
.局部变量 AngleExtend, tuple
.局部变量 AngleStart, tuple
.局部变量 ColPoint, tuple
.局部变量 Column, tuple
.局部变量 ColumnEdge, tuple
.局部变量 Distance, tuple
.局部变量 Height, tuple
.局部变量 IntermedDist, tuple
.局部变量 MeasureHandle, tuple
.局部变量 Pointer, tuple
.局部变量 Radius, tuple
.局部变量 Row, tuple
.局部变量 RowEdge, tuple
.局部变量 RowPoint, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 Zeiss1, obj
.局部变量 false, tuple
.局部变量 true, tuple


read_image (Zeiss1, “zeiss1”)
get_image_pointer1 (Zeiss1, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 视_除 (视_乘 (Height, 到小数 (640)), Width), “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Zeiss1)
p_set_font (WindowHandle)

p_write_message (WindowHandle, G (-1), G (-1), G (“Inspect parts of a flange”), 真)
dev_set_color (“medium slate blue”)
wait_seconds (2)
视_设值 (Row, 275)
视_设值 (Column, 335)
视_设值 (Radius, 107)
视_设值 (AngleStart, －DD (rad (55), ))
视_设值 (AngleExtend, rad (170))
dev_set_draw (“fill”)
dev_set_color (“green”)
dev_set_line_width (1)
get_points_ellipse (视_加 (AngleStart, AngleExtend), Row, Column, 0, Radius, Radius, RowPoint, ColPoint)
dev_display (Zeiss1)
disp_arc (WindowHandle, Row, Column, AngleExtend, RowPoint, ColPoint)
p_write_message (WindowHandle, G (-1), G (-1), G (“Define measure arc”), 真)
dev_set_line_width (3)
gen_measure_arc (Row, Column, Radius, AngleStart, AngleExtend, 10, Width, Height, “nearest_neighbor”, MeasureHandle)
wait_seconds (1)
measure_pos (Zeiss1, MeasureHandle, 1, 10, “all”, “all”, RowEdge, ColumnEdge, Amplitude, Distance)
wait_seconds (1)
distance_pp (视_取元素 (RowEdge, 1), 视_取元素 (ColumnEdge, 1), 视_取元素 (RowEdge, 2), 视_取元素 (ColumnEdge, 2), IntermedDist)
p_write_message (WindowHandle, G (-1), G (-1), G (“Measure distance on arc”), 真)
' * dev_display (Zeiss1)
dev_set_color (“red”)
' * disp_circle (WindowHandle, RowEdge, ColumnEdge, RowEdge-RowEdge+1)
disp_line (WindowHandle, 视_取元素 (RowEdge, 1), 视_取元素 (ColumnEdge, 1), 视_取元素 (RowEdge, 2), 视_取元素 (ColumnEdge, 2))
p_write_message (WindowHandle, G (170), G (455), G (视_加 (视_加 (“Distance: ”, 视_文本格式化 (IntermedDist, “4.2f”)), “ px”)), 假)
dev_set_line_width (1)
dev_set_color (“blue”)
disp_line (WindowHandle, 222, 427, 196, 476)
close_measure (MeasureHandle)
wait_seconds (3)
dev_close_window ()


返回 ()

.子程序 p_do_measure_rim
.局部变量 Circles, obj
.局部变量 Column, tuple
.局部变量 Dark, obj
.局部变量 DarkRegions, obj
.局部变量 Diameter, tuple
.局部变量 Edges, obj
.局部变量 EndPhi, tuple
.局部变量 Height, tuple
.局部变量 Phi, tuple
.局部变量 PointOrder, tuple
.局部变量 Pointer, tuple
.局部变量 ROI, obj
.局部变量 ROIEdges, obj
.局部变量 ROIInner, obj
.局部变量 ROIOuter, obj
.局部变量 Ra, tuple
.局部变量 Rb, tuple
.局部变量 RelEdges, obj
.局部变量 Rim, obj
.局部变量 RimReduced, obj
.局部变量 Row, tuple
.局部变量 StartPhi, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型

dev_update_window (“off”)
read_image (Rim, “rim”)
get_image_pointer1 (Rim, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Rim)
p_set_font (WindowHandle)

dev_set_color (“red”)
disp_message (WindowHandle, “Measure the diameter of holes”, “window”, -1, -1, “black”, “true”)
wait_seconds (3)
threshold (Rim, Dark, 0, 128)
dev_display (Rim)
dev_set_color (“green”)
dev_set_draw (“fill”)
dev_display (Dark)
disp_message (WindowHandle, “Measure the diameter of holes”, “window”, -1, -1, “black”, “true”)
wait_seconds (1)
connection (Dark, DarkRegions)
select_shape (DarkRegions, Circles, G (“circularity”, “area”), “and”, G (0.85, 50), G (到小数 (1), 99999))
dev_display (Rim)
disp_message (WindowHandle, “Measure the diameter of holes”, “window”, -1, -1, “black”, “true”)
dev_set_colored (12)
dev_display (Circles)
wait_seconds (1)
dilation_circle (Circles, ROIOuter, 8.5)
erosion_circle (Circles, ROIInner, 8.5)
difference (ROIOuter, ROIInner, ROI)
union1 (ROI, ROIEdges)
dev_display (Rim)
disp_message (WindowHandle, “Measure the diameter of holes”, “window”, -1, -1, “black”, “true”)
dev_set_draw (“margin”)
dev_set_line_width (3)
dev_set_color (“green”)
dev_display (ROIEdges)
wait_seconds (1)
reduce_domain (Rim, ROIEdges, RimReduced)
edges_sub_pix (RimReduced, Edges, “lanser2”, 0.3, 10, 20)
select_contours_xld (Edges, RelEdges, “length”, 30, 999999, 0, 0)
dev_display (Rim)
disp_message (WindowHandle, “Measure the diameter of holes”, “window”, -1, -1, “black”, “true”)
dev_set_colored (6)
dev_display (RelEdges)
wait_seconds (1)
fit_ellipse_contour_xld (RelEdges, “ftukey”, -1, 2, 0, 200, 3, 2, Row, Column, Phi, Ra, Rb, StartPhi, EndPhi, PointOrder)
视_设值 (Diameter, 视_乘 (2, Ra))
dev_display (Rim)
disp_message (WindowHandle, “Measure the diameter of holes”, “window”, -1, -1, “black”, “true”)
dev_set_color (“green”)
disp_ellipse (WindowHandle, Row, Column, Phi, Ra, Rb)
dev_set_color (“cyan”)
disp_arrow (WindowHandle, 视_减 (Row, 视_乘 (Ra, sin (Phi))), 视_加 (Column, 视_乘 (Ra, cos (Phi))), 视_加 (Row, 视_乘 (Ra, sin (Phi))), 视_减 (Column, 视_乘 (Ra, cos (Phi))), 1)
disp_arrow (WindowHandle, 视_加 (Row, 视_乘 (Ra, sin (Phi))), 视_减 (Column, 视_乘 (Ra, cos (Phi))), 视_减 (Row, 视_乘 (Ra, sin (Phi))), 视_加 (Column, 视_乘 (Ra, cos (Phi))), 1)
dev_set_color (“yellow”)
.变量循环首 (1, DD (视_取元素总数 (Row), ), 1, i)
    disp_message (WindowHandle, 视_加 (视_加 (“Diameter: ”, 视_文本格式化 (视_取元素 (Diameter, 视_减 (i, 1)), “5.2f”)), “ px”), “image”, 视_加 (视_加 (视_取元素 (Row, 视_减 (i, 1)), 视_取元素 (Ra, 视_减 (i, 1))), 4), 视_减 (视_取元素 (Column, 视_减 (i, 1)), 210), “black”, “true”)
.变量循环尾 ()
wait_seconds (3)
dev_close_window ()
dev_set_line_width (1)


返回 ()

.子程序 p_do_clips
.局部变量 Area, tuple
.局部变量 Clip, obj
.局部变量 Column, tuple
.局部变量 Dark, obj
.局部变量 Height, tuple
.局部变量 Length, tuple
.局部变量 Number, tuple
.局部变量 Phi, tuple
.局部变量 Row, tuple
.局部变量 Selected, obj
.局部变量 Single, obj
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型

' Orientation of clips

dev_update_window (“off”)
read_image (Clip, “clip”)
get_image_size (Clip, Width, Height)

dev_open_window (0, 0, 视_除 (视_乘 (Width, 到小数 (560)), Height), 560, “black”, WindowHandle)

dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

dev_display (Clip)
disp_message (WindowHandle, “Determine orientation of clips”, “window”, -1, -1, “black”, “true”)
dev_set_color (“black”)
wait_seconds (3)
bin_threshold (Clip, Dark)
connection (Dark, Single)
select_shape (Single, Selected, “area”, “and”, 5000, 10000)
dev_set_draw (“fill”)
dev_set_colored (12)
dev_display (Clip)
dev_display (Selected)
count_obj (Single, Number)
disp_message (WindowHandle, 视_加 (视_加 (“Found ”, Number), “ clips”), “window”, -1, -1, “black”, “true”)
wait_seconds (3)
dev_display (Clip)

disp_message (WindowHandle, “Orientation of clips”, “window”, -1, -1, “black”, “true”)
dev_set_color (“green”)
dev_display (Selected)
orientation_region (Selected, Phi)
area_center (Selected, Area, Row, Column)
dev_set_line_width (3)
dev_set_draw (“margin”)
视_设值 (Length, 80)
.变量循环首 (0, DD (视_减 (视_取元素总数 (Phi), 1), ), 1, i)
    dev_set_color (“blue”)
    disp_arrow (WindowHandle, 视_取元素 (Row, i), 视_取元素 (Column, i), 视_减 (视_取元素 (Row, i), 视_乘 (Length, sin (视_取元素 (Phi, i)))), 视_加 (视_取元素 (Column, i), 视_乘 (Length, cos (视_取元素 (Phi, i)))), 4)
    .如果 (视_且 (视_大于 (deg (视_取元素 (Phi, i)), -45), 视_小于 (deg (视_取元素 (Phi, i)), 0)))
        disp_message (WindowHandle, 视_加 (视_文本格式化 (deg (视_取元素 (Phi, i)), “.2f”), “°”), “image”, 视_减 (视_取元素 (Row, i), 35), 视_取元素 (Column, i), “black”, “true”)
    .否则
        disp_message (WindowHandle, 视_加 (视_文本格式化 (deg (视_取元素 (Phi, i)), “.2f”), “°”), “image”, 视_加 (视_取元素 (Row, i), 5), 视_取元素 (Column, i), “black”, “true”)
    .如果结束

.变量循环尾 ()
dev_update_window (“on”)
wait_seconds (5)
dev_close_window ()
dev_set_line_width (1)

返回 ()

.子程序 p_do_razor_blades
.局部变量 Amp11, tuple
.局部变量 Amp12, tuple
.局部变量 Amp21, tuple
.局部变量 Amp22, tuple
.局部变量 AngleCheck, tuple
.局部变量 Area, tuple
.局部变量 CenterROIColumn, tuple
.局部变量 CenterROIRow, tuple
.局部变量 ColEdge11, tuple
.局部变量 ColEdge12, tuple
.局部变量 ColEdge21, tuple
.局部变量 ColEdge22, tuple
.局部变量 ColFault, tuple
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 ColumnCheck, tuple
.局部变量 DistColRect1Rect2, tuple
.局部变量 DistRect1CenterCol, tuple
.局部变量 DistRect1CenterRow, tuple
.局部变量 Distance1, tuple
.局部变量 Distance2, tuple
.局部变量 Height, tuple
.局部变量 ImageROI, obj
.局部变量 Indices, tuple
.局部变量 MeasureHandle1, tuple
.局部变量 MeasureHandle2, tuple
.局部变量 MeasureROI1, obj
.局部变量 MeasureROI1AtNewPosition, obj
.局部变量 MeasureROI2, obj
.局部变量 MeasureROI2AtNewPosition, obj
.局部变量 ModelAtNewPosition, obj
.局部变量 ModelID, tuple
.局部变量 ModelImage, obj
.局部变量 ModelROI, obj
.局部变量 MovementOfObject, tuple
.局部变量 NumberTeeth1, tuple
.局部变量 NumberTeeth2, tuple
.局部变量 Pointer, tuple
.局部变量 ROIPart1, obj
.局部变量 ROIPart2, obj
.局部变量 Rect1Col, tuple
.局部变量 Rect1Row, tuple
.局部变量 Rect2Col, tuple
.局部变量 Rect2ColCheck, tuple
.局部变量 Rect2ColTmp, tuple
.局部变量 Rect2Row, tuple
.局部变量 Rect2RowCheck, tuple
.局部变量 Rect2RowTmp, tuple
.局部变量 RectLength1, tuple
.局部变量 RectLength2, tuple
.局部变量 RectPhi, tuple
.局部变量 RectPhiCheck, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 RowCheck, tuple
.局部变量 RowEdge11, tuple
.局部变量 RowEdge12, tuple
.局部变量 RowEdge21, tuple
.局部变量 RowEdge22, tuple
.局部变量 RowFault, tuple
.局部变量 Score, tuple
.局部变量 SearchImage, obj
.局部变量 ShapeModel, obj
.局部变量 ShapeModelImage, obj
.局部变量 ShapeModelRegion, obj
.局部变量 Status, tuple
.局部变量 Type, tuple
.局部变量 USING_TRANSLATE_MEASURE, tuple
.局部变量 Width, tuple
.局部变量 Width1, tuple
.局部变量 Width2, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandleZoom, tuple
.局部变量 false, tuple
.局部变量 i, 整数型
.局部变量 j, 整数型
.局部变量 true, tuple


' ------------------------------------------------------------------------------------------------
' This example program uses shape-based matching to align ROIs for the measure
' tool, which then inspects individual razor blades.
' The program can be run in two modes: (1) with the full affine transformation
' (2) using translate_measure
' Modify the next line to switch between the modes.
视_设值 (USING_TRANSLATE_MEASURE, 0)
' ------------------------------------------------------------------------------------------------

dev_update_window (“off”)
' image acquisition and window size
read_image (ModelImage, “razors1”)
get_image_pointer1 (ModelImage, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
dev_display (ModelImage)

' colors and other settings for the visualization
dev_set_draw (“margin”)
dev_set_line_width (2)
' -------------------  start of the application  ----------------
' -> select the model object
视_设值 (Row1, 46)
视_设值 (Column1, 54)
视_设值 (Row2, 79)
视_设值 (Column2, 97)
gen_rectangle1 (ROIPart1, Row1, Column1, Row2, Column2)
gen_rectangle1 (ROIPart2, 视_加 (Row1, 364), 视_加 (Column1, 13), 视_加 (Row2, 364), 视_加 (Column2, 13))
union2 (ROIPart1, ROIPart2, ModelROI)
area_center (ModelROI, Area, CenterROIRow, CenterROIColumn)
dev_display (ModelImage)
p_write_message (WindowHandle, G (-1), G (-1), G (“Inspect a punching die of razors”), 真)
wait_seconds (3)
dev_display (ModelImage)
dev_set_color (“yellow”)
dev_display (ModelROI)
p_write_message (WindowHandle, G (-1), G (-1), G (“Define a model”), 真)
wait_seconds (2)
' -> create the model
reduce_domain (ModelImage, ModelROI, ImageROI)
create_shape_model (ImageROI, 4, 0, 0, “auto”, “none”, “use_polarity”, 30, 10, ModelID)
inspect_shape_model (ImageROI, ShapeModelImage, ShapeModelRegion, 1, 30)
gen_contours_skeleton_xld (ShapeModelRegion, ShapeModel, 1, “filter”)
dev_clear_window ()
p_write_message (WindowHandle, G (-1), G (-1), G (“Model contour”), 真)
dev_set_color (“blue”)
dev_display (ShapeModelRegion)
wait_seconds (2)
' step 1: create variables describing  the measurement ROIs and display them
视_设值 (Rect1Row, 244)
视_设值 (Rect1Col, 73)
视_设值 (DistColRect1Rect2, 17)
视_设值 (Rect2Row, Rect1Row)
视_设值 (Rect2Col, 视_加 (Rect1Col, DistColRect1Rect2))
视_设值 (RectPhi, rad (90))
视_设值 (RectLength1, 122)
视_设值 (RectLength2, 2)
gen_rectangle2 (MeasureROI1, Rect1Row, Rect1Col, RectPhi, RectLength1, RectLength2)
gen_rectangle2 (MeasureROI2, Rect2Row, Rect2Col, RectPhi, RectLength1, RectLength2)
dev_display (ModelImage)
dev_set_color (“yellow”)
dev_display (MeasureROI1)
dev_display (MeasureROI2)
.如果 (视_不等于 (USING_TRANSLATE_MEASURE, 0))
    ' -> measure objects are created only once in advance and then translated later
    gen_measure_rectangle2 (Rect1Row, Rect1Col, RectPhi, RectLength1, RectLength2, Width, Height, “bilinear”, MeasureHandle1)
    gen_measure_rectangle2 (Rect2Row, Rect2Col, RectPhi, RectLength1, RectLength2, Width, Height, “bilinear”, MeasureHandle2)
.否则

.如果结束
' step 2: move the reference point to the center of the first measure rectangle
视_设值 (DistRect1CenterRow, 视_减 (Rect1Row, CenterROIRow))
视_设值 (DistRect1CenterCol, 视_减 (Rect1Col, CenterROIColumn))
set_shape_model_origin (ModelID, DistRect1CenterRow, DistRect1CenterCol)
p_write_message (WindowHandle, G (-1), G (-1), G (“Define measurement rectangles”), 真)
wait_seconds (2)
' step 3: find the objects in another image
read_image (SearchImage, “razors2”)
dev_display (SearchImage)
p_write_message (WindowHandle, G (-1), G (-1), G (“Perform the quality measurement”), 真)
set_tposition (WindowHandle, 16, 12)
' * write_string (WindowHandle, 'Quality inspection of a punching die of razors')
find_shape_model (SearchImage, ModelID, 0, 0, 0.8, 0, 0.5, “interpolation”, 0, 0.7, RowCheck, ColumnCheck, AngleCheck, Score)
tuple_sort_index (ColumnCheck, Indices)
tuple_select (ColumnCheck, Indices, ColumnCheck)
tuple_select (RowCheck, Indices, RowCheck)
tuple_select (AngleCheck, Indices, AngleCheck)
.如果 (视_大于 (视_取元素总数 (Score), 0))
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Score), 1), ), 1, i)
        ' step 4: determine the affine transformation
        vector_angle_to_rigid (Rect1Row, Rect1Col, 0, 视_取元素 (RowCheck, i), 视_取元素 (ColumnCheck, i), 视_取元素 (AngleCheck, i), MovementOfObject)
        affine_trans_contour_xld (ShapeModel, ModelAtNewPosition, MovementOfObject)
        dev_set_color (“blue”)
        dev_display (ModelAtNewPosition)
        ' step 5: measure width and distance of the teeth
        ' -> display the moved ROIs
        affine_trans_region (MeasureROI1, MeasureROI1AtNewPosition, MovementOfObject, “true”)
        affine_trans_region (MeasureROI2, MeasureROI2AtNewPosition, MovementOfObject, “true”)
        dev_set_color (“yellow”)
        dev_display (MeasureROI1AtNewPosition)
        dev_display (MeasureROI2AtNewPosition)
        .如果 (视_不等于 (USING_TRANSLATE_MEASURE, 0))
            ' -> translate the already created measure objects
            translate_measure (MeasureHandle1, 视_取元素 (RowCheck, i), 视_取元素 (ColumnCheck, i))
            translate_measure (MeasureHandle2, 视_取元素 (RowCheck, i), 视_加 (视_取元素 (ColumnCheck, i), DistColRect1Rect2))
            measure_pairs (SearchImage, MeasureHandle1, 2, 25, “negative”, “all”, RowEdge11, ColEdge11, Amp11, RowEdge21, ColEdge21, Amp21, Width1, Distance1)
            measure_pairs (SearchImage, MeasureHandle2, 2, 25, “negative”, “all”, RowEdge12, ColEdge12, Amp12, RowEdge22, ColEdge22, Amp22, Width2, Distance2)
        .否则
            ' -> create new measure objects and destroy them after the measurement
            视_设值 (RectPhiCheck, 视_加 (RectPhi, 视_取元素 (AngleCheck, i)))
            gen_measure_rectangle2 (视_取元素 (RowCheck, i), 视_取元素 (ColumnCheck, i), RectPhiCheck, RectLength1, RectLength2, Width, Height, “bilinear”, MeasureHandle1)
            ' -> transform the center of the second measure ROIs
            affine_trans_point_2d (MovementOfObject, 视_加 (Rect2Row, 0.5), 视_加 (Rect2Col, 0.5), Rect2RowTmp, Rect2ColTmp)
            视_设值 (Rect2RowCheck, 视_减 (Rect2RowTmp, 0.5))
            视_设值 (Rect2ColCheck, 视_减 (Rect2ColTmp, 0.5))
            gen_measure_rectangle2 (Rect2RowCheck, Rect2ColCheck, RectPhiCheck, RectLength1, RectLength2, Width, Height, “bilinear”, MeasureHandle2)
            measure_pairs (SearchImage, MeasureHandle1, 2, 25, “negative”, “all”, RowEdge11, ColEdge11, Amp11, RowEdge21, ColEdge21, Amp21, Width1, Distance1)
            measure_pairs (SearchImage, MeasureHandle2, 2, 25, “negative”, “all”, RowEdge12, ColEdge12, Amp12, RowEdge22, ColEdge22, Amp22, Width2, Distance2)
            close_measure (MeasureHandle1)
            close_measure (MeasureHandle2)
        .如果结束
        ' step 6: check for too short or missing teeth
        视_设值 (NumberTeeth1, 视_取元素总数 (Width1))
        视_设值 (NumberTeeth2, 视_取元素总数 (Width2))
        dev_set_color (“red”)
        视_设值 (Status, 真)
        .如果 (视_小于 (NumberTeeth1, 37))
            .变量循环首 (0, DD (视_减 (NumberTeeth1, 2), ), 1, j)
                .如果 (视_大于 (视_取元素 (Distance1, j), 到小数 (4)))
                    视_设值 (RowFault, round (视_乘 (0.5, 视_加 (视_取元素 (RowEdge11, 视_加 (j, 1)), 视_取元素 (RowEdge21, j)))))
                    视_设值 (ColFault, round (视_乘 (0.5, 视_加 (视_取元素 (ColEdge11, 视_加 (j, 1)), 视_取元素 (ColEdge21, j)))))
                    disp_rectangle2 (WindowHandle, RowFault, ColFault, 0, 4, 4)
                    set_tposition (WindowHandle, 视_减 (视_取元素 (RowEdge11, 视_减 (NumberTeeth1, 1)), 30), 视_减 (视_取元素 (ColEdge11, 视_减 (NumberTeeth1, 1)), 12))
                    write_string (WindowHandle, “nok”)
                    dev_open_window (视_减 (RowFault, 40), 视_加 (ColFault, 30), 80, 80, “black”, WindowHandleZoom)
                    dev_set_part (视_减 (RowFault, 10), 视_减 (ColFault, 10), 视_加 (RowFault, 10), 视_加 (ColFault, 10))
                    dev_display (SearchImage)
                    disp_rectangle2 (WindowHandleZoom, RowFault, ColFault, 0, 4, 4)
                    wait_seconds (4)
                    dev_close_window ()
                    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
                    视_设值 (Status, 假)
                .否则

                .如果结束

            .变量循环尾 ()
        .否则

        .如果结束
        .如果 (视_小于 (NumberTeeth2, 37))
            .变量循环首 (0, DD (视_减 (NumberTeeth2, 2), ), 1, j)
                .如果 (视_大于 (视_取元素 (Distance2, j), 到小数 (4)))
                    视_设值 (RowFault, round (视_乘 (0.5, 视_加 (视_取元素 (RowEdge12, 视_加 (j, 1)), 视_取元素 (RowEdge22, j)))))
                    视_设值 (ColFault, round (视_乘 (0.5, 视_加 (视_取元素 (ColEdge12, 视_加 (j, 1)), 视_取元素 (ColEdge22, j)))))
                    disp_rectangle2 (WindowHandle, RowFault, ColFault, 0, 4, 4)
                    set_tposition (WindowHandle, 视_减 (视_取元素 (RowEdge12, 视_减 (NumberTeeth2, 1)), 30), 视_减 (视_取元素 (ColEdge12, 视_减 (NumberTeeth2, 1)), 25))
                    write_string (WindowHandle, “nok”)
                    dev_open_window (视_减 (RowFault, 40), 视_加 (ColFault, 30), 80, 80, “black”, WindowHandleZoom)
                    dev_set_part (视_减 (RowFault, 10), 视_减 (ColFault, 10), 视_加 (RowFault, 10), 视_加 (ColFault, 10))
                    dev_display (SearchImage)
                    disp_rectangle2 (WindowHandleZoom, RowFault, ColFault, 0, 4, 4)
                    dev_set_window (WindowHandle)
                    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
                    wait_seconds (3)
                    dev_set_window (WindowHandleZoom)
                    dev_close_window ()
                    视_设值 (Status, 假)
                .否则

                .如果结束

            .变量循环尾 ()
        .否则

        .如果结束
        dev_set_window (WindowHandle)
        .如果 (视_是否为真 (Status))
            dev_set_color (“green”)
            set_tposition (WindowHandle, 视_减 (视_取元素 (RowEdge11, 视_减 (NumberTeeth1, 1)), 30), 视_减 (视_取元素 (ColEdge11, 视_减 (NumberTeeth1, 1)), 3))
            write_string (WindowHandle, “ok”)
        .否则

        .如果结束
        dev_set_color (“yellow”)
        wait_seconds (0.3)
    .变量循环尾 ()
.否则

.如果结束
' -------------------  end of the application  -----------------
' clean up
.如果 (视_不等于 (USING_TRANSLATE_MEASURE, 0))
    close_measure (MeasureHandle1)
    close_measure (MeasureHandle2)
.否则

.如果结束
dev_update_window (“on”)
clear_shape_model (ModelID)
wait_seconds (2)
dev_close_window ()
dev_set_line_width (1)
返回 ()

.子程序 p_do_pcb
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 ConnectedRegions, obj
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 ImageClosing, obj
.局部变量 ImageOpening, obj
.局部变量 Number, tuple
.局部变量 ObjectSelected, obj
.局部变量 Pointer, tuple
.局部变量 RegionDynThresh, obj
.局部变量 Row, tuple
.局部变量 SelectedRegions, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 i, 整数型
.局部变量 true, tuple


dev_update_window (“off”)
read_image (Image, “pcb”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)

dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Image)
p_set_font (WindowHandle)
p_write_message (WindowHandle, G (-1), G (-1), G (“Detect defects on a Printed Circuit Board”), 真)
wait_seconds (3)

dev_set_color (“black”)
' * set_tposition (WindowHandle, 2, 12)
' * write_string (WindowHandle, 'PCB (Printed Circuit Board) inspection')
' detect defects...
gray_opening_shape (Image, ImageOpening, 7, 7, “octagon”)
gray_closing_shape (Image, ImageClosing, 7, 7, “octagon”)
dyn_threshold (ImageOpening, ImageClosing, RegionDynThresh, 75, “not_equal”)
connection (RegionDynThresh, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 3, 99999)
dev_open_window (220, 380, 256, 256, “black”, WindowHandle1)
count_obj (SelectedRegions, Number)
dev_set_draw (“margin”)
dev_set_line_width (2)
.变量循环首 (1, DD (Number, ), 1, i)
    dev_set_window (WindowHandle)
    dev_set_draw (“margin”)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    dev_display (Image)
    dev_set_color (“red”)
    select_obj (SelectedRegions, ObjectSelected, i)
    dev_display (SelectedRegions)
    area_center (ObjectSelected, Area, Row, Column)
    dev_set_color (“blue”)
    dev_set_line_width (3)
    disp_rectangle1 (WindowHandle, round (视_减 (Row, 11)), round (视_减 (Column, 11)), round (视_加 (Row, 11)), round (视_加 (Column, 11)))
    dev_set_line_width (2)
    p_write_message (WindowHandle, G (-1), G (-1), G (“Detect defects on a Printed Circuit Board”), 真)
    dev_set_window (WindowHandle1)
    dev_set_part (round (视_减 (Row, 10)), round (视_减 (Column, 10)), round (视_加 (Row, 10)), round (视_加 (Column, 10)))
    dev_display (Image)
    dev_set_color (“red”)
    dev_display (ObjectSelected)
    .如果 (视_小于 (i, 10))
        wait_seconds (0.9)
    .否则
        wait_seconds (0.1)
    .如果结束

.变量循环尾 ()
wait_seconds (1)
dev_set_window (WindowHandle1)
dev_close_window ()
dev_set_window (WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_close_window ()
dev_set_line_width (1)


返回 ()

.子程序 p_do_resistors
.局部变量 Confidence, obj
.局部变量 ConnectedRes, obj
.局部变量 ConnectedSol, obj
.局部变量 Depth, obj
.局部变量 DepthHighConf, obj
.局部变量 DepthMean, obj
.局部变量 Exception, tuple
.局部变量 FillUpSol, obj
.局部变量 FinalRes, obj
.局部变量 FinalSol, obj
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 Image1, obj
.局部变量 ImageExtended, obj
.局部变量 ImageScaleMax, obj
.局部变量 Names, tuple
.局部变量 Pointer, tuple
.局部变量 Resistor, obj
.局部变量 Selected, obj
.局部变量 SelectedSol, obj
.局部变量 Solder, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型
.局部变量 true, tuple


' Extract depth using mutiple focus levels

视_设值 (Names, G ())
.变量循环首 (1, 10, 1, i)
    视_设值 (Names, G (Names, 视_加 (“dff/focus_”, 视_文本格式化 (i, “.2”))))
.变量循环尾 ()
dev_update_window (“off”)
read_image (Image, Names)
channels_to_image (Image, Image)
get_image_pointer1 (Image, Pointer, Type, Width, Height)

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_set_window (WindowHandle)

p_set_font (WindowHandle)
' Access a channel of a multichannel image
dev_set_color (“red”)
.变量循环首 (1, 10, 1, i)
    access_channel (Image, Image1, i)
    dev_display (Image1)
    p_write_message (WindowHandle, G (-1), G (-1), G (“Reconstruct the height by depth from focus”), 真)
    p_write_message (WindowHandle, G (40), G (-1), G (视_加 (“Image ”, i)), 真)
    wait_seconds (0.3)
.变量循环尾 ()
depth_from_focus (Image, Depth, Confidence, “highpass”, “next_maximum”)
' Smooth by averaging
mean_image (Depth, DepthHighConf, 11, 11)
select_grayvalues_from_channels (Image, DepthHighConf, Selected)
scale_image_max (DepthHighConf, ImageScaleMax)
mean_image (ImageScaleMax, DepthMean, 51, 51)
threshold (DepthMean, Resistor, 158, 255)
connection (Resistor, ConnectedRes)
' Select regions of a given shape
select_shape_std (ConnectedRes, FinalRes, “max_area”, 0)
threshold (DepthMean, Solder, 125, 158)
connection (Solder, ConnectedSol)
select_shape_std (ConnectedSol, SelectedSol, “max_area”, 0)
' Fill up holes
fill_up (SelectedSol, FillUpSol)
opening_circle (FillUpSol, FinalSol, 7.5)
dev_display (Selected)
p_write_message (WindowHandle, G (-1), G (-1), G (“Reconstructed sharp image”), 真)
wait_seconds (3)
dev_set_color (“black”)
dev_clear_window ()
append_channel (DepthMean, Selected, ImageExtended)
' try
dev_set_paint (G (“3d_plot”, “texture”, 4, 0.9, 0.03, 0.45, -0.1, 0.4, -0.03, -0.08, 0.01))
' *' 不支持的方法：catch(Exception)
' dev_set_paint(G("3d_plot_lines",5,1,110,160,450,0,0))
' endtry
dev_display (ImageExtended)
p_write_message (WindowHandle, G (-1), G (-1), G (“Extracted height information”), 真)
p_write_message (WindowHandle, G (90), G (130), G (“Top of SMD”), 真)
p_write_message (WindowHandle, G (220), G (160), G (“Solder”), 真)
dev_set_color (“yellow”)
disp_line (WindowHandle, 146, 358, 112, 285)
disp_line (WindowHandle, 263, 368, 239, 264)
wait_seconds (5)
dev_set_paint (“default”)
dev_display (Selected)
dev_set_line_width (2)
dev_set_draw (“margin”)
p_write_message (WindowHandle, G (254), G (90), G (“Solder”), 真)
dev_set_color (“blue”)
dev_display (FinalSol)
dev_set_color (“coral”)
dev_display (FinalRes)
p_write_message (WindowHandle, G (120), G (15), G (“Top of solder”), 真)
p_write_message (WindowHandle, G (-1), G (-1), G (“Processed height information”), 真)
dev_set_color (“yellow”)
dev_set_line_width (2)
disp_line (WindowHandle, 114, 208, 122, 191)
disp_line (WindowHandle, 254, 232, 263, 195)
wait_seconds (4)
dev_close_window ()
dev_set_line_width (1)
dev_set_draw (“fill”)


返回 ()

.子程序 p_do_measure_board
.局部变量 AmplitudeFirst1, tuple
.局部变量 AmplitudeFirst2, tuple
.局部变量 AmplitudeSecond1, tuple
.局部变量 AmplitudeSecond2, tuple
.局部变量 AngleCheck, tuple
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 ColumnCheck, tuple
.局部变量 ColumnEdgeFirst1, tuple
.局部变量 ColumnEdgeFirst2, tuple
.局部变量 ColumnEdgeSecond1, tuple
.局部变量 ColumnEdgeSecond2, tuple
.局部变量 FileNames, tuple
.局部变量 Height, tuple
.局部变量 HomMat2DIdentity, tuple
.局部变量 HomMat2DRotate, tuple
.局部变量 HomMat2DTranslate, tuple
.局部变量 Image, obj
.局部变量 ImageCheck, obj
.局部变量 ImageReduced, obj
.局部变量 InterDistance1, tuple
.局部变量 InterDistance2, tuple
.局部变量 IntraDistance1, tuple
.局部变量 IntraDistance2, tuple
.局部变量 MeasureHandle1, tuple
.局部变量 MeasureHandle2, tuple
.局部变量 MinDistance, tuple
.局部变量 ModelID, tuple
.局部变量 NumLeads, tuple
.局部变量 Numbers, tuple
.局部变量 Paths, tuple
.局部变量 Pointer, tuple
.局部变量 Rect1Col, tuple
.局部变量 Rect1ColCheck, tuple
.局部变量 Rect1ColTmp, tuple
.局部变量 Rect1Row, tuple
.局部变量 Rect1RowCheck, tuple
.局部变量 Rect1RowTmp, tuple
.局部变量 Rect2Col, tuple
.局部变量 Rect2ColCheck, tuple
.局部变量 Rect2ColTmp, tuple
.局部变量 Rect2Row, tuple
.局部变量 Rect2RowCheck, tuple
.局部变量 Rect2RowTmp, tuple
.局部变量 RectLength1, tuple
.局部变量 RectLength2, tuple
.局部变量 RectPhi, tuple
.局部变量 Rectangle, obj
.局部变量 Rectangle1, obj
.局部变量 Rectangle1Check, obj
.局部变量 Rectangle2, obj
.局部变量 Rectangle2Check, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 RowCheck, tuple
.局部变量 RowEdgeFirst1, tuple
.局部变量 RowEdgeFirst2, tuple
.局部变量 RowEdgeSecond1, tuple
.局部变量 RowEdgeSecond2, tuple
.局部变量 S1, tuple
.局部变量 S2, tuple
.局部变量 S3, tuple
.局部变量 S4, tuple
.局部变量 Score, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 Sequence, tuple
.局部变量 ShapeModel, obj
.局部变量 ShapeModelImage, obj
.局部变量 ShapeModelTrans, obj
.局部变量 Time, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型


' This example program shows the use of pattern matching with shape models
' to locate an object. Furthermore, it shows how to use the detected position
' and rotation of the object to construct search spaces for inspection tasks.
' In this particular example, the print on an IC is used to find the IC.  From the
' found position and rotation, two measurement rectangles are constructed to
' measure the spacing between the leads of the IC.  Because of the lighting
' used in this example, the leads have the saturated gray value of 255 at several
' positions and rotations, which enlarges the apparent width of the leads, and
' hence seems to reduce the spacing between the leads, although the same
' board is used in all images.

dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)

视_设值 (Paths, G (“board/board-”))
tuple_gen_sequence (1, 20, 1, Sequence)
视_设值 (Numbers, 视_文本格式化 (Sequence, “.02”))
视_设值 (FileNames, 视_加 (Paths, Numbers))

read_image (Image, 视_取元素 (FileNames, 0))
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 视_除 (视_乘 (Height, 到小数 (640)), Width), “black”, WindowHandle)

dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
dev_display (Image)
disp_message (WindowHandle, “Create a model of the print”, “window”, -1, -1, “black”, “true”)
count_seconds (Seconds1)
视_设值 (Row1, 188)
视_设值 (Column1, 182)
视_设值 (Row2, 298)
视_设值 (Column2, 412)
gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)
dev_set_color (“green”)
dev_set_draw (“margin”)
dev_display (Rectangle)
area_center (Rectangle, Area, Row, Column)
视_设值 (Rect1Row, 视_减 (Row, 102))
视_设值 (Rect1Col, 视_加 (Column, 5))
视_设值 (Rect2Row, 视_加 (Row, 107))
视_设值 (Rect2Col, 视_加 (Column, 5))
视_设值 (RectPhi, 0)
视_设值 (RectLength1, 170)
视_设值 (RectLength2, 5)
gen_rectangle2 (Rectangle1, Rect1Row, Rect1Col, RectPhi, RectLength1, RectLength2)
gen_rectangle2 (Rectangle2, Rect2Row, Rect2Col, RectPhi, RectLength1, RectLength2)
reduce_domain (Image, Rectangle, ImageReduced)
inspect_shape_model (ImageReduced, ShapeModelImage, ShapeModel, 1, 30)
create_shape_model (ImageReduced, 4, 0, rad (360), rad (1), “none”, “use_polarity”, 30, 10, ModelID)
count_seconds (Seconds2)
视_设值 (Time, 视_减 (Seconds2, Seconds1))
wait_seconds (max (G (视_减 (3, Time), 0)))
dev_display (Image)
dev_set_color (“green”)
dev_display (ShapeModel)
dev_set_color (“blue”)
dev_set_draw (“margin”)
dev_set_line_width (3)
dev_display (Rectangle1)
dev_display (Rectangle2)
dev_set_draw (“fill”)
dev_set_line_width (1)
dev_set_color (“yellow”)
disp_message (WindowHandle, “Model and measurement rectangles”, “window”, -1, -1, “black”, “true”)
wait_seconds (2)

.变量循环首 (1, 75, 1, i)
    read_image (ImageCheck, 视_取元素 (FileNames, 视_求模 (i, 20)))

    count_seconds (S1)
    find_shape_model (ImageCheck, ModelID, 0, rad (360), 0.7, 1, 0.5, “least_squares”, 4, 0.7, RowCheck, ColumnCheck, AngleCheck, Score)
    count_seconds (S2)
    .如果 (视_大于 (视_取元素总数 (Score), 0))
        dev_set_color (“green”)
        hom_mat2d_identity (HomMat2DIdentity)
        hom_mat2d_translate (HomMat2DIdentity, 视_减 (RowCheck, Row), 视_减 (ColumnCheck, Column), HomMat2DTranslate)
        hom_mat2d_rotate (HomMat2DTranslate, AngleCheck, RowCheck, ColumnCheck, HomMat2DRotate)
        affine_trans_region (ShapeModel, ShapeModelTrans, HomMat2DRotate, “false”)
        affine_trans_point_2d (HomMat2DRotate, 视_加 (Rect1Row, 0.5), 视_加 (Rect1Col, 0.5), Rect1RowTmp, Rect1ColTmp)
        affine_trans_point_2d (HomMat2DRotate, 视_加 (Rect2Row, 0.5), 视_加 (Rect2Col, 0.5), Rect2RowTmp, Rect2ColTmp)
        视_设值 (Rect1RowCheck, 视_减 (Rect1RowTmp, 0.5))
        视_设值 (Rect1ColCheck, 视_减 (Rect1ColTmp, 0.5))
        视_设值 (Rect2RowCheck, 视_减 (Rect2RowTmp, 0.5))
        视_设值 (Rect2ColCheck, 视_减 (Rect2ColTmp, 0.5))
        gen_rectangle2 (Rectangle1Check, Rect1RowCheck, Rect1ColCheck, AngleCheck, RectLength1, RectLength2)
        gen_rectangle2 (Rectangle2Check, Rect2RowCheck, Rect2ColCheck, AngleCheck, RectLength1, RectLength2)

        ' Measure the width of the leads
        count_seconds (S3)
        gen_measure_rectangle2 (Rect1RowCheck, Rect1ColCheck, AngleCheck, RectLength1, RectLength2, Width, Height, “bilinear”, MeasureHandle1)
        gen_measure_rectangle2 (Rect2RowCheck, Rect2ColCheck, AngleCheck, RectLength1, RectLength2, Width, Height, “bilinear”, MeasureHandle2)
        measure_pairs (ImageCheck, MeasureHandle1, 2, 90, “positive”, “all”, RowEdgeFirst1, ColumnEdgeFirst1, AmplitudeFirst1, RowEdgeSecond1, ColumnEdgeSecond1, AmplitudeSecond1, IntraDistance1, InterDistance1)
        measure_pairs (ImageCheck, MeasureHandle2, 2, 90, “positive”, “all”, RowEdgeFirst2, ColumnEdgeFirst2, AmplitudeFirst2, RowEdgeSecond2, ColumnEdgeSecond2, AmplitudeSecond2, IntraDistance2, InterDistance2)
        close_measure (MeasureHandle1)
        close_measure (MeasureHandle2)
        视_设值 (NumLeads, 视_加 (视_取元素总数 (IntraDistance1), 视_取元素总数 (IntraDistance2)))
        视_设值 (MinDistance, min (G (InterDistance1, InterDistance2)))
        count_seconds (S4)

        ' Display results
        dev_set_window (WindowHandle)
        dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
        set_system (“flush_graphic”, “false”)
        dev_display (ImageCheck)
        dev_display (ShapeModelTrans)
        dev_set_color (“blue”)
        dev_set_draw (“margin”)
        dev_set_line_width (3)
        dev_display (Rectangle1Check)
        dev_display (Rectangle2Check)
        dev_set_draw (“fill”)
        dev_set_color (“yellow”)
        disp_line (WindowHandle, 视_减 (RowEdgeFirst1, 视_乘 (RectLength2, cos (AngleCheck))), 视_减 (ColumnEdgeFirst1, 视_乘 (RectLength2, sin (AngleCheck))), 视_加 (RowEdgeFirst1, 视_乘 (RectLength2, cos (AngleCheck))), 视_加 (ColumnEdgeFirst1, 视_乘 (RectLength2, sin (AngleCheck))))
        disp_line (WindowHandle, 视_减 (RowEdgeSecond1, 视_乘 (RectLength2, cos (AngleCheck))), 视_减 (ColumnEdgeSecond1, 视_乘 (RectLength2, sin (AngleCheck))), 视_加 (RowEdgeSecond1, 视_乘 (RectLength2, cos (AngleCheck))), 视_加 (ColumnEdgeSecond1, 视_乘 (RectLength2, sin (AngleCheck))))
        disp_line (WindowHandle, 视_减 (RowEdgeFirst2, 视_乘 (RectLength2, cos (AngleCheck))), 视_减 (ColumnEdgeFirst2, 视_乘 (RectLength2, sin (AngleCheck))), 视_加 (RowEdgeFirst2, 视_乘 (RectLength2, cos (AngleCheck))), 视_加 (ColumnEdgeFirst2, 视_乘 (RectLength2, sin (AngleCheck))))
        disp_line (WindowHandle, 视_减 (RowEdgeSecond2, 视_乘 (RectLength2, cos (AngleCheck))), 视_减 (ColumnEdgeSecond2, 视_乘 (RectLength2, sin (AngleCheck))), 视_加 (RowEdgeSecond2, 视_乘 (RectLength2, cos (AngleCheck))), 视_加 (ColumnEdgeSecond2, 视_乘 (RectLength2, sin (AngleCheck))))
        dev_set_line_width (1)
        disp_message (WindowHandle, 视_加 (视_加 (“IC found in ”, 视_文本格式化 (视_乘 (视_减 (S2, S1), 1000), “.1f”)), “ ms”), “window”, -1, -1, “black”, “true”)
        disp_message (WindowHandle, G (视_加 (视_加 (视_加 (视_文本格式化 (NumLeads, “2d”), “ leads measured in ”), 视_文本格式化 (视_乘 (视_减 (S4, S3), 1000), “4.1f”)), “ ms”), 视_加 (视_加 (“Minimum lead distance: ”, 视_文本格式化 (MinDistance, “.2f”)), “ px”)), “window”, 434, -1, “black”, “true”)

        set_system (“flush_graphic”, “true”)
        set_tposition (WindowHandle, -10, -10)
        write_string (WindowHandle, “”)
    .否则

    .如果结束
    .如果 (视_小于 (i, 3))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (4)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (1)

dev_set_window (WindowHandle)
dev_close_window ()
clear_shape_model (ModelID)
dev_update_pc (“on”)
dev_update_var (“on”)


返回 ()

.子程序 p_do_balls
.局部变量 Balls, obj
.局部变量 Bond, obj
.局部变量 Bright, obj
.局部变量 Column, tuple
.局部变量 Diameter, tuple
.局部变量 Die, obj
.局部变量 DieGrey, obj
.局部变量 FinalBalls, obj
.局部变量 Forbidden, obj
.局部变量 Height, tuple
.局部变量 ImageNames, tuple
.局部变量 IntermediateBalls, obj
.局部变量 Max, tuple
.局部变量 Min, tuple
.局部变量 NumBalls, tuple
.局部变量 ObjectSelected, obj
.局部变量 Radius, tuple
.局部变量 Range, tuple
.局部变量 Rect, obj
.局部变量 RegionExpand, obj
.局部变量 RoundBalls, obj
.局部变量 Row, tuple
.局部变量 SingleBalls, obj
.局部变量 StoreEmpty, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 Wires, obj
.局部变量 WiresFilled, obj
.局部变量 i, 整数型
.局部变量 j, 整数型
.局部变量 k, 整数型
.局部变量 meanDiameter, tuple
.局部变量 mimDiameter, tuple


' Inspection of Ball Bonding

视_设值 (ImageNames, G (“die/die_02”, “die/die_03”, “die/die_04”, “die/die_07”))
read_image (Bond, 视_取元素 (ImageNames, 0))
get_image_size (Bond, Width, Height)

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_update_var (“off”)
dev_update_window (“off”)

p_set_font (WindowHandle)
get_system (“store_empty_region”, StoreEmpty)
set_system (“store_empty_region”, “false”)
dev_set_draw (“margin”)
dev_set_line_width (3)
.变量循环首 (1, 1, 1, k)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (ImageNames), 1), ), 1, i)
        read_image (Bond, 视_取元素 (ImageNames, i))
        dev_display (Bond)
        min_max_gray (Bond, Bond, 0, Min, Max, Range)
        threshold (Bond, Bright, 视_减 (Max, 80), 255)
        shape_trans (Bright, Die, “rectangle2”)
        dev_set_color (“yellow”)
        dev_display (Die)
        reduce_domain (Bond, Die, DieGrey)
        min_max_gray (Die, Bond, 0, Min, Max, Range)
        threshold (DieGrey, Wires, 0, 视_加 (Min, 30))
        fill_up_shape (Wires, WiresFilled, “area”, 1, 100)
        opening_circle (WiresFilled, Balls, 9.5)
        connection (Balls, SingleBalls)
        select_shape_std (SingleBalls, Rect, “rectangle1”, 90)
        difference (SingleBalls, Rect, IntermediateBalls)
        gen_empty_region (Forbidden)
        expand_gray (IntermediateBalls, Bond, Forbidden, RegionExpand, 4, “image”, 6)
        opening_circle (RegionExpand, RoundBalls, 15.5)
        sort_region (RoundBalls, FinalBalls, “first_point”, “true”, “column”)
        smallest_circle (FinalBalls, Row, Column, Radius)
        视_设值 (NumBalls, 视_取元素总数 (Radius))
        视_设值 (Diameter, 视_乘 (2, Radius))
        视_设值 (meanDiameter, 视_除 (sum (Diameter), NumBalls))
        视_设值 (mimDiameter, min (Diameter))
        ' *         dev_display (RoundBalls)
        dev_set_draw (“fill”)
        dev_set_color (“light gray”)
        disp_rectangle1 (WindowHandle, 视_加 (视_减 (视_除 (Height, 2), 54), 3), 视_加 (视_除 (Width, 2), 3), 视_加 (视_加 (视_减 (视_除 (Height, 2), 54), 视_乘 (视_加 (视_取元素总数 (Radius), 1), 24)), 3), 视_加 (视_加 (视_除 (Width, 2), 250), 3))
        dev_set_color (“white”)
        disp_rectangle1 (WindowHandle, 视_减 (视_除 (Height, 2), 54), 视_除 (Width, 2), 视_加 (视_减 (视_除 (Height, 2), 54), 视_乘 (视_加 (视_取元素总数 (Radius), 1), 24)), 视_加 (视_除 (Width, 2), 250))
        dev_set_draw (“margin”)
        dev_set_color (“black”)
        disp_line (WindowHandle, 224, 365, 224, 611)
        disp_line (WindowHandle, 201, 415, 视_加 (201, 视_乘 (视_加 (视_取元素总数 (Radius), 1), 24)), 415)
        set_tposition (WindowHandle, 视_减 (视_除 (Height, 2), 54), 视_除 (Width, 2))
        write_string (WindowHandle, “No     Radius”)
        .变量循环首 (0, DD (视_减 (视_取元素总数 (Radius), 1), ), 1, j)
            select_obj (FinalBalls, ObjectSelected, 视_加 (j, 1))
            dev_set_color (“white”)
            set_tposition (WindowHandle, 视_减 (视_取元素 (Row, j), 10), 视_减 (视_取元素 (Column, j), 10))
            write_string (WindowHandle, 视_加 (j, 1))
            dev_set_color (“black”)
            set_tposition (WindowHandle, 视_加 (视_减 (视_除 (Height, 2), 30), 视_乘 (j, 24)), 视_除 (Width, 2))
            write_string (WindowHandle, 视_加 (视_加 (视_文本格式化 (视_加 (j, 1), “2d”), “   ”), 视_文本格式化 (视_取元素 (Radius, j), “.3f”)))
            .如果 (视_小于 (视_取元素 (Radius, j), 17))
                dev_set_color (“red”)
                write_string (WindowHandle, “ (nok)”)
            .否则
                dev_set_color (“green”)
                write_string (WindowHandle, “  (ok)”)
            .如果结束
            dev_display (ObjectSelected)
        .变量循环尾 ()
        disp_message (WindowHandle, “Inspect the radius of bonding balls on a die”, “window”, -1, -1, “black”, “true”)
        wait_seconds (3)
    .变量循环尾 ()
.变量循环尾 ()
dev_close_window ()
dev_set_line_width (1)
set_system (“store_empty_region”, StoreEmpty)


dev_update_pc (“on”)
dev_update_window (“off”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_world_plane
.局部变量 Angle, tuple
.局部变量 Area, tuple
.局部变量 C, tuple
.局部变量 CCoord, tuple
.局部变量 Caltab, obj
.局部变量 CaltabName, tuple
.局部变量 CamParam, tuple
.局部变量 Column, tuple
.局部变量 ColumnRef, tuple
.局部变量 Errors, tuple
.局部变量 HomMat2D, tuple
.局部变量 HomMat3D, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 ImageRectified, obj
.局部变量 ImageReduced, obj
.局部变量 ImgNo, tuple
.局部变量 J, 整数型
.局部变量 Map, obj
.局部变量 Message, tuple
.局部变量 Model, obj
.局部变量 ModelBorder, obj
.局部变量 ModelBorderTrans, obj
.局部变量 ModelID, tuple
.局部变量 ModelImages, obj
.局部变量 ModelRegions, obj
.局部变量 ModelWorld, obj
.局部变量 NCol, tuple
.局部变量 NFinalPose, tuple
.局部变量 NRow, tuple
.局部变量 NStartPose, tuple
.局部变量 Num, tuple
.局部变量 NumImages, tuple
.局部变量 PixelDist, tuple
.局部变量 Pose, tuple
.局部变量 PoseCalib, tuple
.局部变量 R, tuple
.局部变量 RCoord, tuple
.局部变量 Rectangle, obj
.局部变量 Row, tuple
.局部变量 RowRef, tuple
.局部变量 S1, tuple
.局部变量 S2, tuple
.局部变量 Score, tuple
.局部变量 StartCamPar, tuple
.局部变量 StartPose, tuple
.局部变量 Time, tuple
.局部变量 WindowHandle, tuple
.局部变量 X, tuple
.局部变量 Xc, tuple
.局部变量 Xs, tuple
.局部变量 Y, tuple
.局部变量 Yc, tuple
.局部变量 Ys, tuple
.局部变量 Z, tuple
.局部变量 Zc, tuple


' This example program shows how to recognize planar objects using HALCON's
' shape-based matching if the camera is not mounted perpendicular to the plane
' in which the objects lie. Tho recognize the objects, the images are rectified, i.e.,
' the perspective distortions are removed from the images.  To do so, the camera
' is calibrated and the plane in which the objects lie is obtained from the external
' camera parameters of the image in which the calibration target lies on this plane
' Once this plane is known, the image of the model object can be rectified and
' hence the model can be generated in the world plane, i.e., without distortions.
' Similarly, the search images are also rectified, and hence the shape-based
' matching becomes invariant to perspective distortions.

dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 481, 645)
p_set_font (WindowHandle)

dev_set_draw (“margin”)
dev_set_line_width (3)
' Perform the camera calibration.
视_设值 (CaltabName, “caltab_30mm.descr”)
视_设值 (StartCamPar, G (0.008, 0, 7.3e-006, 7.3e-006, 323, 241, 646, 482))
视_设值 (NStartPose, G ())
视_设值 (NRow, G ())
视_设值 (NCol, G ())
caltab_points (CaltabName, X, Y, Z)
视_设值 (NumImages, 15)
.变量循环首 (1, DD (NumImages, ), 1, I)
    read_image (Image, 视_加 (“radius-gauges/calib-”, 视_文本格式化 (I, “02d”)))
    dev_display (Image)
    disp_message (WindowHandle, “Recognize metal parts in 3D”, “window”, -1, -1, “black”, “true”)
    disp_message (WindowHandle, G (“Remove perspective distortions”, “via 3D camera calibration”), “window”, 45, -1, “black”, “true”)
    find_caltab (Image, Caltab, CaltabName, 3, 115, 5)
    dev_set_color (“green”)
    dev_display (Caltab)
    find_marks_and_pose (Image, Caltab, CaltabName, StartCamPar, 128, 10, 18, 0.9, 15, 100, RCoord, CCoord, StartPose)
    dev_set_color (“yellow”)
    disp_circle (WindowHandle, RCoord, CCoord, gen_tuple_const (视_取元素总数 (RCoord), 1.5))
    视_设值 (NStartPose, G (NStartPose, StartPose))
    视_设值 (NRow, G (NRow, RCoord))
    视_设值 (NCol, G (NCol, CCoord))
    wait_seconds (0.1)
.变量循环尾 ()
camera_calibration (X, Y, Z, NRow, NCol, StartCamPar, NStartPose, “all”, CamParam, NFinalPose, Errors)
wait_seconds (3)
read_image (Image, “radius-gauges/calib-01”)
dev_display (Image)
disp_message (WindowHandle, “Recognize metal parts in 3D”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Image defining the reference plane”, “window”, 45, -1, “black”, “true”)
wait_seconds (2)
' The pose of the calibration target in the first image defines a plane that is
' parallel to the plane in which the objects lie.  This pose can be used to see how
' much the camera is rotated with respect to this plane.
视_设值 (PoseCalib, 视_取元素范围 (NFinalPose, 0, 6))
' The pose of the calibration target in the first image defines a plane that is offset
' from the plane in which the objects lie by the thickness of the calibration target.
' Therefore, we need to shift the origin of the pose in the z direction by the
' thickness.  Furthermore, we need to shift the origin so that the top left corner
' of the image lies approximately in the top left corner of the rectified image.
set_origin_pose (PoseCalib, -0.066, -0.048, 0.00063, Pose)
' We also need to define the pixel spacing in the rectified image.  In this case,
' we set it to 0.2mm (i.e., 0.0002m).
视_设值 (PixelDist, 0.0002)
' We now can compute the mapping function to rectify the image because it does
' not change (the camera does not move with respect to the world plane).
gen_image_to_world_plane_map (Map, CamParam, Pose, 646, 482, 596, 448, PixelDist, “bilinear”)
' We also compute the transformation from the world coordinate system, i.e., the
' coordinate system of the plane, to the camera coordinate system.  This
' transformation is later used to visualize the recognized objects in the distorted
' (i.e., original, unrectified) images.
pose_to_hom_mat3d (Pose, HomMat3D)
' Now that we are able to rectify the images, we can create the shape model.
read_image (Image, “radius-gauges/radius-gauges-00”)
dev_display (Image)
' Display the pose of the world plane.
disp_message (WindowHandle, “Recognize metal parts in 3D”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Model image (generating shape model...)”, “window”, 45, -1, “black”, “true”)
视_设值 (Message, G (“Rotation of the camera:”, 视_加 (视_加 (“x axis: ”, 视_文本格式化 (视_取元素 (PoseCalib, 3), “7.1f”)), “°”), 视_加 (视_加 (“y axis: ”, 视_文本格式化 (视_取元素 (PoseCalib, 4), “7.1f”)), “°”), 视_加 (视_加 (“z axis: ”, 视_文本格式化 (视_取元素 (PoseCalib, 5), “7.1f”)), “°”)))
disp_message (WindowHandle, Message, “window”, 350, -1, “black”, “true”)
' We rectify the model image and create the shape model in the rectified image.
map_image (Image, Map, ImageRectified)
gen_rectangle1 (Rectangle, 120, 220, 340, 450)
area_center (Rectangle, Area, RowRef, ColumnRef)
reduce_domain (ImageRectified, Rectangle, ImageReduced)
inspect_shape_model (ImageReduced, ModelImages, ModelRegions, 1, 30)
' For visualization purposes, we also create a contour that corresponds to the
' outer boundary of the object.  This is done because the model contains a hole,
' and hence consists of multiple contours.  This allows us to visualize the
' recognized models in the original images in a simplified manner.
gen_contours_skeleton_xld (ModelRegions, Model, 1, “filter”)
select_contours_xld (Model, ModelBorder, “length”, 200, 1000, -0.5, 0.5)
create_shape_model (ImageReduced, 5, 0, rad (360), “auto”, “none”, “use_polarity”, 30, 5, ModelID)
' Now we are going to visualize the model in the original image.  To do so, we
' read out the coordinates of the model points.
get_contour_xld (ModelBorder, Ys, Xs)
' Since we have rectified the image, the pixel coordinates correspond to 0.2mm
' increments.  Sinc the projection operator expects coordinates in meters, we
' need to multiply them by the pixel distance.
视_设值 (X, 视_乘 (Xs, PixelDist))
视_设值 (Y, 视_乘 (Ys, PixelDist))
视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
' We now must transform the model points into the camera coordinate system.
affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
' Finally, we can project the points from the camera corrdinate system to the
' image plane.
project_3d_point (Xc, Yc, Zc, CamParam, R, C)
' We now create a contour from the projected points.
gen_contour_polygon_xld (ModelWorld, R, C)
' For visualization purposes, we also will display an arrow from the reference
' point of the model.  The arrow is exactly 10mm long and oriented horizontally in
' the world coordinate system.  As with the model, the arrow will be displayed in
' the original image, where it will not be horizontal because of the perspective
' distortion.
视_设值 (X, G (视_乘 (ColumnRef, PixelDist), 视_加 (视_乘 (ColumnRef, PixelDist), 视_除 (到小数 (1), 100))))
视_设值 (Y, G (视_乘 (RowRef, PixelDist), 视_乘 (RowRef, PixelDist)))
视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
project_3d_point (Xc, Yc, Zc, CamParam, R, C)
dev_set_color (“green”)
dev_display (ModelWorld)
dev_set_color (“coral”)
disp_arrow (WindowHandle, 视_取元素 (R, 0), 视_取元素 (C, 0), 视_取元素 (R, 1), 视_取元素 (C, 1), 2)
' The final part of the program performs the object recognition.  Up to three
' objects will be visible in the images.  Note that these objects are not exactly
' identical.  The circular indentations and protrusions have different radii (5.5mm,
' 6mm, and 6.5mm).  Therfore, in addition to the occlusions of the objects, the
' shape-based matching must compensate for these (significant) variations in
' the objects' shape.  The model was actually created from the object with the
' 6mm radii.
.变量循环首 (1, 3, 1, J)
    read_image (Image, 视_加 (“radius-gauges/radius-gauges-”, 视_文本格式化 (J, “02d”)))
    find_shape_model (ImageRectified, ModelID, 0, rad (360), 0.5, 0, 0.5, “interpolation”, 0, 0.9, Row, Column, Angle, Score)
.变量循环尾 ()
视_设值 (ImgNo, 11)
wait_seconds (3)
.变量循环首 (1, 48, 1, J)
    read_image (Image, 视_加 (“radius-gauges/radius-gauges-”, 视_文本格式化 (ImgNo, “02d”)))
    ' We will count the time to rectify the image and to find the objects.
    count_seconds (S1)
    map_image (Image, Map, ImageRectified)
    find_shape_model (ImageRectified, ModelID, 0, rad (360), 0.5, 0, 0.5, “least_squares”, 0, 0.8, Row, Column, Angle, Score)
    count_seconds (S2)
    dev_display (Image)
    视_设值 (Time, 视_减 (S2, S1))
    视_设值 (Num, 视_取元素总数 (Score))
    dev_set_color (“white”)
    disp_message (WindowHandle, 视_加 (视_加 (视_加 (视_文本格式化 (Num, “1d”), “ objects found in ”), 视_文本格式化 (视_乘 (1000, Time), “4.1f”)), “ ms”), “window”, -1, -1, “black”, “true”)
    ' We will now project the contours of the found instances of the model back to
    ' the perspectively distorted image plane.  The following code is identical to
    ' the code above that displays the model in the perspectively distorted image.
    视_设值 (Message, G ())
    .变量循环首 (0, DD (视_减 (Num, 1), ), 1, I)
        视_设值 (Message, G (Message, 视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (“Pose ”, I), “: (”), 视_文本格式化 (视_乘 (视_乘 (视_取元素 (Column, I), PixelDist), 1000), “3.2f”)), “, ”), 视_文本格式化 (视_乘 (视_乘 (视_取元素 (Row, I), PixelDist), 1000), “3.2f”)), “)[mm], ”), 视_文本格式化 (deg (视_取元素 (Angle, I)), “3.2f”)), “°”)))
    .变量循环尾 ()
    disp_message (WindowHandle, Message, “window”, 380, -1, “black”, “true”)
    .如果 (视_大于 (Num, 0))
        .变量循环首 (0, DD (视_减 (Num, 1), ), 1, I)
            vector_angle_to_rigid (RowRef, ColumnRef, 0, 视_取元素 (Row, I), 视_取元素 (Column, I), 视_取元素 (Angle, I), HomMat2D)
            affine_trans_contour_xld (ModelBorder, ModelBorderTrans, HomMat2D)
            get_contour_xld (ModelBorderTrans, Ys, Xs)
            视_设值 (X, 视_乘 (Xs, PixelDist))
            视_设值 (Y, 视_乘 (Ys, PixelDist))
            视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
            affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
            project_3d_point (Xc, Yc, Zc, CamParam, R, C)
            gen_contour_polygon_xld (ModelWorld, R, C)
            视_设值 (X, G (视_乘 (视_取元素 (Column, I), PixelDist), 视_加 (视_乘 (视_取元素 (Column, I), PixelDist), 视_除 (cos (视_取元素 (Angle, I)), 100))))
            视_设值 (Y, G (视_乘 (视_取元素 (Row, I), PixelDist), 视_减 (视_乘 (视_取元素 (Row, I), PixelDist), 视_除 (sin (视_取元素 (Angle, I)), 100))))
            视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
            affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
            project_3d_point (Xc, Yc, Zc, CamParam, R, C)
            dev_set_color (“green”)
            dev_display (ModelWorld)
            dev_set_color (“coral”)
            disp_arrow (WindowHandle, 视_取元素 (R, 0), 视_取元素 (C, 0), 视_取元素 (R, 1), 视_取元素 (C, 1), 2)
        .变量循环尾 ()
    .否则

    .如果结束
    视_设值 (ImgNo, 视_加 (ImgNo, 1))
    .如果 (视_大于 (ImgNo, 20))
        视_设值 (ImgNo, 1)
    .否则

    .如果结束
    .如果 (视_小于 (J, 3))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (3)
    .否则

    .如果结束
    ' *     stop ()
.变量循环尾 ()
clear_shape_model (ModelID)
wait_seconds (2)
dev_close_window ()
dev_set_line_width (1)


dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_multiple_parts
.局部变量 Angle, tuple
.局部变量 Area, tuple
.局部变量 Colors, tuple
.局部变量 Column, tuple
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 ColumnsRef, tuple
.局部变量 ConnectedRegions, obj
.局部变量 HomMat2D, tuple
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 ImgNo, tuple
.局部变量 IndexE, tuple
.局部变量 IndexS, tuple
.局部变量 J, 整数型
.局部变量 Model, tuple
.局部变量 ModelContours, obj
.局部变量 ModelID, tuple
.局部变量 ModelIDs, tuple
.局部变量 ModelImages, obj
.局部变量 ModelRegions, obj
.局部变量 ModelSelected, obj
.局部变量 ModelTrans, obj
.局部变量 Models, obj
.局部变量 Num, tuple
.局部变量 NumModel, tuple
.局部变量 NumModels, tuple
.局部变量 Rectangle, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 RowsRef, tuple
.局部变量 S1, tuple
.局部变量 S2, tuple
.局部变量 Score, tuple
.局部变量 SelectedRegions, obj
.局部变量 Time, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型
.局部变量 true, tuple


' This example program shows how to use HALCON's shape-based matching
' to find multiple different models in one call to find_shape_models.  Note that this
' is one mode of operation that is frequently useful.  However, the number of
' applications that can be solved with this mechanism is much larger.  For
' another application where finding multiple models in one call is useful are
' applications where the same object can only occur in small angle ranges
' around a discrete set of angles, e.g., 0°, 90°, 180°, and 270°.  In these cases,
' it would be wasteful to train the model for the full 360° rotataion range and to
' match the model in this range.  Instead, four models using the small angle
' ranges around the discrete set of angles should be generated from the same
' model image and used in the matching stage using four different angle ranges.

dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)

dev_open_window (0, 0, 640, 476, “black”, WindowHandle)
dev_set_part (0, 0, 481, 645)
p_set_font (WindowHandle)

dev_set_draw (“margin”)
dev_set_line_width (3)
' These colors will be used to graphically discern the different models in the
' visualization code below.
视_设值 (Colors, G (“blue”, “coral”, “yellow”))
' The models will be generated from hard-coded rectangles given by the
' following coordinates:
视_设值 (Row1, G (135, 150, 185))
视_设值 (Column1, G (250, 170, 220))
视_设值 (Row2, G (375, 310, 335))
视_设值 (Column2, G (355, 395, 375))
' The object Models will hold a set of XLD contours that represent the different
' models.  They are used below to overlay the found models on the current
' image.  XLD contours are used because they can be transformed much faster
' than regions.  This creates a slight problem because in general multiple XLD
' contours will represent one model.  Therefore, the start and end indices of the
' different models will be stored in IndexS and IndexE, respectively.
gen_empty_obj (Models)
视_设值 (IndexS, G ())
视_设值 (IndexE, G ())
' The variable ModelIDs holds the different models that are created below.
视_设值 (ModelIDs, G ())
' Likewise, RowsRef and ColumnsRef store the reference points of the different
' models.  They are necessary to transform the models to the found instances
' in the current image.
视_设值 (RowsRef, G ())
视_设值 (ColumnsRef, G ())
.变量循环首 (1, 3, 1, J)
    read_image (Image, 视_加 (“metal-parts/metal-part-model-”, 视_文本格式化 (J, “02d”)))
    dev_display (Image)
    p_write_message (WindowHandle, G (-1), G (-1), G (“Find multiple different metal parts”), 真)
    p_write_message (WindowHandle, G (40), G (-1), G (视_加 (“Generating shape model ”, 视_文本格式化 (J, “d”))), 真)
    gen_rectangle1 (Rectangle, 视_取元素 (Row1, 视_减 (J, 1)), 视_取元素 (Column1, 视_减 (J, 1)), 视_取元素 (Row2, 视_减 (J, 1)), 视_取元素 (Column2, 视_减 (J, 1)))
    area_center (Rectangle, Area, Row, Column)
    reduce_domain (Image, Rectangle, ImageReduced)
    inspect_shape_model (Image, ModelImages, ModelRegions, 1, 30)
    ' Since the shape models contain a few extraneous edges, they will be
    ' removed here to give a slightly nicer visualization.
    connection (ModelRegions, ConnectedRegions)
    select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 20, 100000)
    union1 (SelectedRegions, ModelRegions)
    gen_contours_skeleton_xld (ModelRegions, ModelContours, 1, “filter”)
    dev_set_color (视_取元素 (Colors, 视_减 (J, 1)))
    dev_display (ModelContours)
    ' Count how many XLD contours there are in the current model and in the
    ' already stored models.  This is necessary to compute IndexS and IndexE.
    count_obj (ModelContours, NumModel)
    count_obj (Models, NumModels)
    create_shape_model (ImageReduced, 5, rad (0), rad (360), 0, “pregeneration”, “use_polarity”, 30, 10, ModelID)
    concat_obj (Models, ModelContours, Models)
    视_设值 (IndexS, G (IndexS, 视_加 (NumModels, 1)))
    视_设值 (IndexE, G (IndexE, 视_加 (NumModels, NumModel)))
    视_设值 (ModelIDs, G (ModelIDs, ModelID))
    视_设值 (RowsRef, G (RowsRef, Row))
    视_设值 (ColumnsRef, G (ColumnsRef, Column))
.变量循环尾 ()
.变量循环首 (1, 3, 1, i)
    read_image (Image, 视_加 (“metal-parts/metal-parts-”, 视_文本格式化 (i, “02d”)))
    find_shape_models (Image, ModelIDs, rad (0), rad (360), 0.6, 0, 0.5, “interpolation”, 0, 0.6, Row, Column, Angle, Score, Model)
.变量循环尾 ()
dev_set_color (“red”)
视_设值 (ImgNo, 14)
.变量循环首 (1, 60, 1, i)
    read_image (Image, 视_加 (“metal-parts/metal-parts-”, 视_文本格式化 (ImgNo, “02d”)))
    count_seconds (S1)
    find_shape_models (Image, ModelIDs, rad (0), rad (360), 0.6, 0, 0.5, “interpolation”, 0, 0.6, Row, Column, Angle, Score, Model)
    count_seconds (S2)
    视_设值 (Time, 视_减 (S2, S1))
    dev_display (Image)
    视_设值 (Num, 视_取元素总数 (Score))
    .变量循环首 (0, DD (视_减 (Num, 1), ), 1, J)
        ' Select the correct XLD contours from the Models object.
        copy_obj (Models, ModelSelected, 视_取元素 (IndexS, 视_取元素 (Model, J)), 视_加 (视_减 (视_取元素 (IndexE, 视_取元素 (Model, J)), 视_取元素 (IndexS, 视_取元素 (Model, J))), 1))
        ' Compute the transformation from the model object to the current instance.
        vector_angle_to_rigid (视_取元素 (RowsRef, 视_取元素 (Model, J)), 视_取元素 (ColumnsRef, 视_取元素 (Model, J)), 0, 视_取元素 (Row, J), 视_取元素 (Column, J), 视_取元素 (Angle, J), HomMat2D)
        affine_trans_contour_xld (ModelSelected, ModelTrans, HomMat2D)
        dev_set_color (视_取元素 (Colors, 视_取元素 (Model, J)))
        dev_display (ModelTrans)
    .变量循环尾 ()
    dev_set_color (“yellow”)
    set_tposition (WindowHandle, 20, 20)
    .如果 (视_等于 (Num, 1))
        p_write_message (WindowHandle, G (-1), G (-1), G (视_加 (视_加 (视_加 (视_文本格式化 (Num, “1d”), “ object  found in ”), 视_文本格式化 (视_乘 (1000, Time), “4.2f”)), “ ms”)), 真)
    .否则
        p_write_message (WindowHandle, G (-1), G (-1), G (视_加 (视_加 (视_加 (视_文本格式化 (Num, “1d”), “ objects found in ”), 视_文本格式化 (视_乘 (1000, Time), “4.2f”)), “ ms”)), 真)
    .如果结束
    视_设值 (ImgNo, 视_加 (ImgNo, 1))
    .如果 (视_大于 (ImgNo, 15))
        视_设值 (ImgNo, 1)
    .否则

    .如果结束
    .如果 (视_小于 (i, 3))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (3)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (1)
.变量循环首 (0, DD (视_减 (视_取元素总数 (ModelIDs), 1), ), 1, J)
    clear_shape_model (视_取元素 (ModelIDs, J))
.变量循环尾 ()
wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_window (“off”)
dev_update_var (“on”)
dev_set_line_width (1)

返回 ()

.子程序 p_do_print_check
.局部变量 Angle, tuple
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 ColumnRef, tuple
.局部变量 ConnectedRegions, obj
.局部变量 Height, tuple
.局部变量 HomMat2D, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 ImageTrans, obj
.局部变量 MeanImage, obj
.局部变量 Model, obj
.局部变量 ModelImages, obj
.局部变量 ModelRegions, obj
.局部变量 NumError, tuple
.局部变量 Pointer, tuple
.局部变量 Region, obj
.局部变量 RegionDiff, obj
.局部变量 RegionDifference, obj
.局部变量 RegionDilation, obj
.局部变量 RegionFillUp, obj
.局部变量 RegionROI, obj
.局部变量 RegionTrans, obj
.局部变量 RegionsError, obj
.局部变量 Row, tuple
.局部变量 RowRef, tuple
.局部变量 Score, tuple
.局部变量 ShapeModelID, tuple
.局部变量 Type, tuple
.局部变量 VarImage, obj
.局部变量 VariationModelID, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 true, tuple


' This example program shows how to use HALCON's variation model operators
' to perform a typical print quality inspection.  The program detects incorrect
' prints on the clips of pens.  In the first step, the variation model is constructed
' from images of correct prints.  Since the position of the objects can vary, the
' images must be transformed to a reference position (the position of the print
' in the first image in this example).  HALCON's shape-based matching is used
' to detect the position and angle of the print in the images.  The found position
' and angle are used to transform the images to the reference position.
' In the second part of the program, the prints of the correct clips and of several
' incorect clips is checked and classified.

dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)

read_image (Image, “pen/pen-01”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

dev_display (Image)
dev_set_line_width (3)
dev_set_color (“green”)
p_write_message (WindowHandle, G (-1), G (-1), G (“Inspect the print on a pen clip”), 真)
wait_seconds (3)
' Note: the shape model will be constructed from a ROI that is computed
' automatically based on a simple image segmentation.
threshold (Image, Region, 100, 255)
fill_up (Region, RegionFillUp)
difference (RegionFillUp, Region, RegionDifference)
shape_trans (RegionDifference, RegionTrans, “convex”)
dilation_circle (RegionTrans, RegionDilation, 8.5)
reduce_domain (Image, RegionDilation, ImageReduced)
inspect_shape_model (ImageReduced, ModelImages, ModelRegions, 1, 20)
gen_contours_skeleton_xld (ModelRegions, Model, 1, “filter”)
area_center (RegionDilation, Area, RowRef, ColumnRef)
create_shape_model (ImageReduced, 5, rad (-10), rad (20), 0, “none”, “use_polarity”, 20, 10, ShapeModelID)
create_variation_model (Width, Height, “byte”, “standard”, VariationModelID)
.变量循环首 (1, 15, 1, I)
    read_image (Image, 视_加 (“pen/pen-”, 视_文本格式化 (I, “02d”)))
    find_shape_model (Image, ShapeModelID, rad (-30), rad (60), 0.5, 1, 0.5, “interpolation”, 0, 0.9, Row, Column, Angle, Score)
    .如果 (视_等于 (视_取元素总数 (Score), 1))
        vector_angle_to_rigid (Row, Column, Angle, RowRef, ColumnRef, 0, HomMat2D)
        affine_trans_image (Image, ImageTrans, HomMat2D, “constant”, “false”)
        train_variation_model (ImageTrans, VariationModelID)
        dev_display (ImageTrans)
        dev_set_color (“green”)
        dev_display (Model)
        p_write_message (WindowHandle, G (-1), G (-1), G (“Train a variation model”), 真)
        wait_seconds (0.25)
    .否则

    .如果结束

.变量循环尾 ()
get_variation_model (MeanImage, VarImage, VariationModelID)
prepare_variation_model (VariationModelID, 20, 3)
' Note: the checking of the print will be restricted to the region of the clip.
' Sometimes the print is also in an incorrect position of the clip.  This will lead
' to erroneous regions at the top or bottom border of the clip and hence can
' be detected easily.
erosion_rectangle1 (RegionFillUp, RegionROI, 1, 15)
dev_display (MeanImage)
p_write_message (WindowHandle, G (-1), G (-1), G (“Reference image”), 真)
wait_seconds (3)
dev_display (VarImage)
p_write_message (WindowHandle, G (-1), G (-1), G (“Variation image”), 真)
wait_seconds (3)
dev_set_draw (“margin”)
.变量循环首 (1, 30, 2, I)
    read_image (Image, 视_加 (“pen/pen-”, 视_文本格式化 (I, “02d”)))
    find_shape_model (Image, ShapeModelID, rad (-10), rad (20), 0.5, 1, 0.5, “interpolation”, 0, 0.9, Row, Column, Angle, Score)
    .如果 (视_等于 (视_取元素总数 (Score), 1))
        vector_angle_to_rigid (Row, Column, Angle, RowRef, ColumnRef, 0, HomMat2D)
        affine_trans_image (Image, ImageTrans, HomMat2D, “constant”, “false”)
        reduce_domain (ImageTrans, RegionROI, ImageReduced)
        compare_variation_model (ImageReduced, RegionDiff, VariationModelID)
        connection (RegionDiff, ConnectedRegions)
        select_shape (ConnectedRegions, RegionsError, “area”, “and”, 20, 1000000)
        count_obj (RegionsError, NumError)
        dev_clear_window ()
        dev_display (ImageTrans)
        dev_set_color (“red”)
        dev_display (RegionsError)
        set_tposition (WindowHandle, 20, 20)
        .如果 (视_等于 (NumError, 0))
            dev_set_color (“green”)
            write_string (WindowHandle, “Clip OK”)
            wait_seconds (0.2)
        .否则
            dev_set_color (“red”)
            write_string (WindowHandle, “Clip not OK”)
            wait_seconds (0.5)
        .如果结束

    .否则
    .如果结束

.变量循环尾 ()
clear_shape_model (ShapeModelID)
clear_variation_model (VariationModelID)
dev_set_line_width (1)
wait_seconds (1)
dev_close_window ()


dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_wood
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 ConnectedInters, obj
.局部变量 ConnectedRegions, obj
.局部变量 Dark, obj
.局部变量 DarkDilation, obj
.局部变量 Height, tuple
.局部变量 ImageMean, obj
.局部变量 ImageScaled, obj
.局部变量 Inters, obj
.局部变量 Line, obj
.局部变量 Max, tuple
.局部变量 Min, tuple
.局部变量 Number, tuple
.局部变量 Pointer, tuple
.局部变量 Range, tuple
.局部变量 RegionBright, obj
.局部变量 Regions, obj
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 SelectedRegions, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WoodPiece1, obj

' Determine the age of a tree by counting its annual rings

dev_update_window (“off”)

read_image (WoodPiece1, “woodring”)
get_image_pointer1 (WoodPiece1, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

min_max_gray (WoodPiece1, WoodPiece1, 2, Min, Max, Range)
scale_image (WoodPiece1, ImageScaled, 视_除 (255, 视_减 (Max, Min)), 视_乘 (视_除 (-255, 视_减 (Max, Min)), Min))
dev_display (ImageScaled)
disp_message (WindowHandle, “Count annual rings”, “window”, -1, -1, “black”, “true”)
wait_seconds (3)
' Segmentation of anual ring
mean_image (WoodPiece1, ImageMean, 9, 9)
dyn_threshold (WoodPiece1, ImageMean, Regions, 到小数 (5), “dark”)
threshold (WoodPiece1, Dark, 0, 90)
dilation_rectangle1 (Dark, DarkDilation, 30, 7)
difference (Regions, DarkDilation, RegionBright)
' Eliminate tiny regions that are no annual rings
connection (RegionBright, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 30, 10000000)
' Define the start and end point of a line across the annual rings
' using the mouse. The number of intersections with annual rings
' is counted along this line
' * draw_line (WindowHandle, Row1, Column1, Row2, Column2)
视_设值 (Row1, 290)
视_设值 (Column1, 6)
视_设值 (Row2, 69.5)
视_设值 (Column2, 1406.5)
gen_region_line (Line, Row1, Column1, Row2, Column2)
intersection (Line, SelectedRegions, Inters)
connection (Inters, ConnectedInters)
count_obj (ConnectedInters, Number)
dev_set_color (“green”)
dev_set_draw (“margin”)
dev_set_line_width (3)
dev_display (Line)
disp_message (WindowHandle, 视_加 (视_加 (“Age: ”, Number), “ years”), “window”, 100, 160, “black”, “true”)
wait_seconds (4)
dev_close_window ()
dev_set_line_width (1)


返回 ()

.子程序 p_do_angio
.局部变量 Angio, obj
.局部变量 Angle, tuple
.局部变量 Col, tuple
.局部变量 ColL, tuple
.局部变量 ColR, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 J, 整数型
.局部变量 Line, obj
.局部变量 Lines, obj
.局部变量 Number, tuple
.局部变量 ProcessedTime, tuple
.局部变量 Row, tuple
.局部变量 RowL, tuple
.局部变量 RowR, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 Width, tuple
.局部变量 WidthL, tuple
.局部变量 WidthR, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple


dev_update_pc (“off”)
dev_update_var (“off”)

read_image (Angio, “angio-part”)
get_image_size (Angio, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Angio)
dev_open_window (视_减 (480, 260), 视_减 (640, 260), 256, 256, “black”, WindowHandle1)
dev_set_window (WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

dev_set_color (“blue”)
lines_gauss (Angio, Lines, 2.3, 0, 0.7, “dark”, “true”, “true”, “true”)
count_obj (Lines, Number)
.变量循环首 (1, DD (Number, ), 1, I)
    disp_message (WindowHandle, “Measure Vessels in an Angiographic Image”, “window”, -1, -1, “black”, “true”)
    select_obj (Lines, Line, I)
    get_contour_xld (Line, Row, Col)
    get_contour_attrib_xld (Line, “angle”, Angle)
    get_contour_attrib_xld (Line, “width_left”, WidthL)
    get_contour_attrib_xld (Line, “width_right”, WidthR)
    ' To display the lines, the point at which the gray value drops to
    ' 25% of the contrast between the line and the background will be
    ' displayed.  This point is given by sqrt(3/4) for the parabolic
    ' line model.
    视_设值 (RowR, 视_加 (Row, 视_乘 (视_乘 (cos (Angle), WidthR), sqrt (0.75))))
    视_设值 (ColR, 视_加 (Col, 视_乘 (视_乘 (sin (Angle), WidthR), sqrt (0.75))))
    视_设值 (RowL, 视_减 (Row, 视_乘 (视_乘 (cos (Angle), WidthL), sqrt (0.75))))
    视_设值 (ColL, 视_减 (Col, 视_乘 (视_乘 (sin (Angle), WidthL), sqrt (0.75))))
    dev_set_color (“red”)
    dev_display (Line)
    dev_set_color (“green”)
    disp_polygon (WindowHandle, RowL, ColL)
    disp_polygon (WindowHandle, RowR, ColR)
.变量循环尾 ()
.变量循环首 (1, DD (Number, ), 1, I)
    select_obj (Lines, Line, I)
    get_contour_xld (Line, Row, Col)
    .如果 (视_且 (视_大于 (视_取元素总数 (Row), 100), 视_位取反 (视_求模 (I, 2))))
        get_contour_attrib_xld (Line, “angle”, Angle)
        get_contour_attrib_xld (Line, “width_left”, WidthL)
        get_contour_attrib_xld (Line, “width_right”, WidthR)
        视_设值 (RowR, 视_加 (Row, 视_乘 (cos (Angle), WidthR)))
        视_设值 (ColR, 视_加 (Col, 视_乘 (sin (Angle), WidthR)))
        视_设值 (RowL, 视_减 (Row, 视_乘 (cos (Angle), WidthL)))
        视_设值 (ColL, 视_减 (Col, 视_乘 (sin (Angle), WidthL)))
        .变量循环首 (0, DD (视_减 (视_取元素总数 (Row), 1), ), 1, J)
            count_seconds (Seconds1)
            dev_set_window (WindowHandle)
            dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
            dev_set_color (“red”)
            dev_display (Line)
            dev_set_color (“yellow”)
            disp_circle (WindowHandle, 视_取元素 (Row, J), 视_取元素 (Col, J), 1.5)
            dev_set_window (WindowHandle1)
            dev_set_part (round (视_减 (视_取元素 (Row, J), 12)), round (视_减 (视_取元素 (Col, J), 12)), round (视_加 (视_取元素 (Row, J), 12)), round (视_加 (视_取元素 (Col, J), 12)))
            dev_display (Angio)
            dev_set_color (“red”)
            dev_display (Line)
            dev_set_color (“green”)
            disp_polygon (WindowHandle1, RowL, ColL)
            disp_polygon (WindowHandle1, RowR, ColR)
            dev_set_color (“yellow”)
            disp_circle (WindowHandle1, 视_取元素 (Row, J), 视_取元素 (Col, J), 1.5)
            count_seconds (Seconds2)
            .如果 (视_等于 (I, 10))
                视_设值 (ProcessedTime, 视_减 (Seconds2, Seconds1))
                wait_seconds (max (G (视_减 (0.04, ProcessedTime), 0)))
            .否则

            .如果结束

        .变量循环尾 ()
        dev_set_window (WindowHandle)
        dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    .否则

    .如果结束

.变量循环尾 ()
dev_set_line_width (3)
dev_set_color (“yellow”)
dev_display (Lines)
dev_set_color (“red”)
dev_set_line_width (1)
dev_display (Lines)
wait_seconds (3)
dev_set_window (WindowHandle1)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()


dev_update_pc (“on”)
dev_update_window (“off”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_roads
.局部变量 Bright, obj
.局部变量 ClippedEdges, obj
.局部变量 ClippedRoadCenters, obj
.局部变量 EdgeRegion, obj
.局部变量 EdgeSkeleton, obj
.局部变量 ExtParallelRoadEdges, obj
.局部变量 HomMat2DIdentity, tuple
.局部变量 HomMat2DScale, tuple
.局部变量 HomMat2DTranslate, tuple
.局部变量 ModParallelRoadEdges, obj
.局部变量 Mreut43, obj
.局部变量 Mreut43Bright, obj
.局部变量 Mreut43Height, tuple
.局部变量 Mreut43Width, tuple
.局部变量 ParallelRoadEdges, obj
.局部变量 Part, obj
.局部变量 PartAmp, obj
.局部变量 PartDir, obj
.局部变量 PartHeight, tuple
.局部变量 PartWidth, tuple
.局部变量 RoadCenterPolygons, obj
.局部变量 RoadCenters, obj
.局部变量 RoadEdgePolygons, obj
.局部变量 RoadEdges, obj
.局部变量 RoadSides, obj
.局部变量 ScaledRoadCenters, obj
.局部变量 TopCol, tuple
.局部变量 TopRow, tuple
.局部变量 WindowHandle, tuple
.局部变量 true, tuple


dev_update_window (“off”)

视_设值 (PartWidth, 512)
视_设值 (PartHeight, 512)
视_设值 (TopRow, 250)
视_设值 (TopCol, 600)

read_image (Part, “mreut_y”)
read_image (Mreut43, “mreut4_3”)
get_image_size (Mreut43, Mreut43Width, Mreut43Height)

dev_open_window (0, 0, Mreut43Width, Mreut43Height, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Mreut43Height, 1), 视_减 (Mreut43Width, 1))
dev_display (Mreut43)
p_set_font (WindowHandle)

p_write_message (WindowHandle, G (-1), G (-1), G (“Extract road centers from aerial image”), 真)
dev_set_line_width (3)
wait_seconds (3)
threshold (Mreut43, Bright, 160, 255)
reduce_domain (Mreut43, Bright, Mreut43Bright)
lines_gauss (Mreut43Bright, RoadCenters, 1.2, 5, 14, “light”, “true”, “bar-shaped”, “true”)
hom_mat2d_identity (HomMat2DIdentity)
hom_mat2d_scale (HomMat2DIdentity, 8, 8, 0, 0, HomMat2DScale)
hom_mat2d_translate (HomMat2DScale, －DD (TopRow, ), －DD (TopCol, ), HomMat2DTranslate)
affine_trans_contour_xld (RoadCenters, ScaledRoadCenters, HomMat2DTranslate)
clip_contours_xld (ScaledRoadCenters, ClippedRoadCenters, 0, 0, PartWidth, PartHeight)
gen_polygons_xld (ClippedRoadCenters, RoadCenterPolygons, “ramer”, 2)
dev_set_colored (6)
dev_display (RoadCenters)
p_write_message (WindowHandle, G (-1), G (-1), G (“Extract road centers from aerial image”), 真)
wait_seconds (3)
dev_set_part (0, 0, 视_减 (PartHeight, 1), 视_减 (PartWidth, 1))
dev_display (Part)
p_write_message (WindowHandle, G (-1), G (-1), G (“Extract road sides from aerial image”), 真)
edges_image (Part, PartAmp, PartDir, “mderiche2”, 0.3, “nms”, 20, 40)
threshold (PartAmp, EdgeRegion, 1, 255)
clip_region (EdgeRegion, ClippedEdges, 2, 2, 视_减 (PartWidth, 3), 视_减 (PartHeight, 3))
skeleton (ClippedEdges, EdgeSkeleton)
gen_contours_skeleton_xld (EdgeSkeleton, RoadEdges, 1, “filter”)
gen_polygons_xld (RoadEdges, RoadEdgePolygons, “ramer”, 2)
gen_parallels_xld (RoadEdgePolygons, ParallelRoadEdges, 10, 30, 0.15, “true”)
mod_parallels_xld (ParallelRoadEdges, Part, ModParallelRoadEdges, ExtParallelRoadEdges, 0.3, 160, 220, 10)
combine_roads_xld (RoadEdgePolygons, ModParallelRoadEdges, ExtParallelRoadEdges, RoadCenterPolygons, RoadSides, rad (40), rad (20), 40, 40)
dev_set_color (“green”)
dev_display (RoadSides)
dev_set_line_width (1)
p_write_message (WindowHandle, G (-1), G (-1), G (“Extract road sides from aerial image”), 真)
wait_seconds (3)
dev_close_window ()


返回 ()

.子程序 p_do_xing
.局部变量 ActualImage, obj
.局部变量 BackGround, obj
.局部变量 BackGroundZoom, obj
.局部变量 BgEstiHandle, tuple
.局部变量 ConnectedRegions, obj
.局部变量 FinalConnected, obj
.局部变量 ForegroundRegion, obj
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 ImageZoomed, obj
.局部变量 Rects, obj
.局部变量 RegionClipped, obj
.局部变量 RegionDilation, obj
.局部变量 RegionIntersection, obj
.局部变量 RegionTrans, obj
.局部变量 RegionUnion, obj
.局部变量 RegionUnionFinal, obj
.局部变量 RegionZoom, obj
.局部变量 SelectedRegions, obj
.局部变量 SelectedRegionsGray, obj
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 XingRegion, obj
.局部变量 i, 整数型
.局部变量 true, tuple


dev_update_window (“off”)
dev_update_pc (“off”)
dev_update_time (“off”)
dev_update_var (“off”)

read_image (Image, “xing/init”)
get_image_size (Image, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)

read_region (XingRegion, “xing/xing”)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_set_draw (“margin”)
dev_set_colored (12)
dev_set_line_width (3)
dev_display (Image)
p_set_font (WindowHandle)

p_write_message (WindowHandle, G (-1), G (-1), G (“Monitor cars and people on a crossing”), 真)
wait_seconds (3)
zoom_image_factor (Image, ImageZoomed, 0.5, 0.5, “constant”)
create_bg_esti (ImageZoomed, 0.7, 0.7, “fixed”, 0.001, 0.03, “on”, 到小数 (8), 10, 3.25, 15, BgEstiHandle)
.变量循环首 (120, 420, 1, i)
    read_image (ActualImage, 视_加 (“xing/xing”, 视_文本格式化 (i, “03”)))
    zoom_image_factor (ActualImage, ImageZoomed, 0.5, 0.5, “constant”)
    run_bg_esti (ImageZoomed, ForegroundRegion, BgEstiHandle)
    zoom_region (ForegroundRegion, RegionZoom, 2, 2)
    intersection (RegionZoom, XingRegion, RegionIntersection)
    connection (RegionIntersection, ConnectedRegions)
    select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 20, 99999)
    shape_trans (SelectedRegions, RegionTrans, “convex”)
    union1 (RegionTrans, RegionUnion)
    connection (RegionUnion, FinalConnected)
    select_gray (FinalConnected, ActualImage, SelectedRegionsGray, “deviation”, “and”, 25, 1000)
    union1 (SelectedRegionsGray, RegionUnionFinal)
    dilation_rectangle1 (RegionUnionFinal, RegionDilation, 5, 5)
    complement (RegionDilation, BackGround)
    clip_region (BackGround, RegionClipped, 0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    zoom_region (RegionClipped, BackGroundZoom, 0.5, 0.5)
    update_bg_esti (ImageZoomed, BackGroundZoom, BgEstiHandle)
    shape_trans (SelectedRegionsGray, Rects, “rectangle1”)

    set_system (“flush_graphic”, “false”)
    dev_display (ActualImage)
    dev_set_color (“coral”)
    dev_display (Rects)
    p_write_message (WindowHandle, G (-1), G (-1), G (“Monitor cars and people on a crossing”), 真)
    set_system (“flush_graphic”, “true”)
    set_tposition (WindowHandle, -10, -10)
    write_string (WindowHandle, “”)
.变量循环尾 ()
close_bg_esti (BgEstiHandle)
wait_seconds (2)
dev_close_window ()
dev_set_line_width (1)


dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_write_message
.参数 WindowHandle, tuple
.参数 Row, tuple
.参数 Column, tuple
.参数 String, tuple
.参数 WindowCoordinates, 逻辑型
.局部变量 Ascent, tuple
.局部变量 C1, tuple
.局部变量 C1_S, tuple
.局部变量 C2, tuple
.局部变量 C2_S, tuple
.局部变量 Column1Part, tuple
.局部变量 Column2Part, tuple
.局部变量 ColumnWin, tuple
.局部变量 Descent, tuple
.局部变量 DrawMode, tuple
.局部变量 FactorColumn, tuple
.局部变量 FactorRow, tuple
.局部变量 Height, tuple
.局部变量 HeightWin, tuple
.局部变量 R1, tuple
.局部变量 R1_S, tuple
.局部变量 R2, tuple
.局部变量 R2_S, tuple
.局部变量 Row1Part, tuple
.局部变量 Row2Part, tuple
.局部变量 RowWin, tuple
.局部变量 Width, tuple
.局部变量 WidthWin, tuple

get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)
get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)
.如果 (视_等于 (Row, -1))
    视_设值 (Row, 12)
.否则

.如果结束
.如果 (视_等于 (Column, -1))
    视_设值 (Column, 12)
.否则

.如果结束
视_设值 (String, 视_加 (视_加 (“ ”, String), “ ”))
get_string_extents (WindowHandle, String, Ascent, Descent, Width, Height)
' Adapt Height for different font sizes!
视_设值 (Height, 24)
' Adapt text position and extents because of image zooming
视_设值 (FactorRow, 视_除 (视_乘 (到小数 (1), 视_加 (视_减 (Row2Part, Row1Part), 1)), HeightWin))
视_设值 (FactorColumn, 视_除 (视_乘 (到小数 (1), 视_加 (视_减 (Column2Part, Column1Part), 1)), WidthWin))
get_draw (WindowHandle, DrawMode)
dev_set_draw (“fill”)
.如果 (视_是否为真 (WindowCoordinates))
    dev_set_color (“light gray”)
    视_设值 (R1_S, 视_加 (视_加 (视_乘 (视_加 (Row, 3), FactorRow), 0.5), Row1Part))
    视_设值 (C1_S, 视_加 (视_加 (视_乘 (视_加 (Column, 3), FactorColumn), 0.5), Column1Part))
    视_设值 (R2_S, 视_加 (视_加 (视_乘 (视_减 (视_加 (视_加 (Row, 3), Height), 1), FactorRow), 0.5), Row1Part))
    视_设值 (C2_S, 视_加 (视_加 (视_乘 (视_减 (视_加 (视_加 (Column, 3), Width), 1), FactorColumn), 0.5), Column1Part))
    disp_rectangle1 (WindowHandle, R1_S, C1_S, R2_S, C2_S)
    dev_set_color (“white”)
    视_设值 (R1, 视_加 (视_加 (视_乘 (Row, FactorRow), 0.5), Row1Part))
    视_设值 (C1, 视_加 (视_加 (视_乘 (Column, FactorColumn), 0.5), Column1Part))
    视_设值 (R2, 视_加 (视_加 (视_乘 (视_减 (视_加 (Row, Height), 1), FactorRow), 0.5), Row1Part))
    视_设值 (C2, 视_加 (视_加 (视_乘 (视_减 (视_加 (Column, Width), 1), FactorColumn), 0.5), Column1Part))
    disp_rectangle1 (WindowHandle, R1, C1, R2, C2)
    dev_set_color (“black”)
    set_tposition (WindowHandle, R1, C1)
.否则
    dev_set_color (“light gray”)
    视_设值 (R1_S, 视_加 (Row, 3))
    视_设值 (C1_S, 视_加 (Column, 3))
    视_设值 (R2_S, 视_加 (视_加 (视_加 (Row, 3), 视_乘 (视_减 (Height, 1), FactorRow)), 0.5))
    视_设值 (C2_S, 视_加 (视_加 (视_加 (Column, 3), 视_乘 (视_减 (Width, 1), FactorColumn)), 0.5))
    disp_rectangle1 (WindowHandle, R1_S, C1_S, R2_S, C2_S)
    dev_set_color (“white”)
    视_设值 (R1, Row)
    视_设值 (C1, Column)
    视_设值 (R2, 视_加 (视_加 (Row, 视_乘 (视_减 (Height, 1), FactorRow)), 0.5))
    视_设值 (C2, 视_加 (视_加 (Column, 视_乘 (视_减 (Width, 1), FactorColumn)), 0.5))
    disp_rectangle1 (WindowHandle, R1, C1, R2, C2)
    dev_set_color (“black”)
    set_tposition (WindowHandle, Row, Column)
.如果结束
write_string (WindowHandle, String)
dev_set_draw (DrawMode)
返回 ()

.子程序 p_do_stereo
.局部变量 CamParamL, tuple
.局部变量 CamParamR, tuple
.局部变量 CamPoseRectL, tuple
.局部变量 CamPoseRectR, tuple
.局部变量 Circle, obj
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 DistanceImage, obj
.局部变量 DistanceImageCorrected, obj
.局部变量 Domain, obj
.局部变量 Height3D, tuple
.局部变量 HeightAboveReferencePlaneReduced, obj
.局部变量 HeightL, tuple
.局部变量 HeightR, tuple
.局部变量 Image3D, obj
.局部变量 ImageL, obj
.局部变量 ImageR, obj
.局部变量 ImageRectifiedL, obj
.局部变量 ImageRectifiedR, obj
.局部变量 ImageReduced, obj
.局部变量 ImgPath, tuple
.局部变量 MapL, obj
.局部变量 MapR, obj
.局部变量 MaskHeight, tuple
.局部变量 MaskWidth, tuple
.局部变量 MaxDisparity, tuple
.局部变量 MaxHeight, tuple
.局部变量 MinDisparity, tuple
.局部变量 MinHeight, tuple
.局部变量 NumLevels, tuple
.局部变量 Pointer, tuple
.局部变量 RectCamParL, tuple
.局部变量 RectCamParR, tuple
.局部变量 RectLPosRectR, tuple
.局部变量 Rectangle, obj
.局部变量 RegionComplement, obj
.局部变量 RegionDefiningReferencePlane, obj
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 ScoreImageDistance, obj
.局部变量 ScoreThresh, tuple
.局部变量 TextureThresh, tuple
.局部变量 Type, tuple
.局部变量 Width3D, tuple
.局部变量 WidthL, tuple
.局部变量 WidthR, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 WindowHandle2, tuple
.局部变量 cLPcR, tuple
.局部变量 true, tuple

' Application program to illustrate the segmentation of board components with stereo methods

' We have a stereo setup of two cameras ('camera1 is left of camera2').
' Both cameras have been calibrated by a couple of images of a 30mm calibration plate.
' The images of different boards will be rectified and the components segmentated.
dev_open_window (0, 0, 640, 112, “black”, WindowHandle)
p_set_font (WindowHandle)
disp_message (WindowHandle, “Extract board components using stereo images”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Image of left camera”, “window”, 72, 12, “black”, “true”)
disp_message (WindowHandle, “Image of right camera”, “window”, 72, 330, “black”, “true”)
视_设值 (ImgPath, “stereo/board/”)
read_image (ImageL, 视_加 (ImgPath, “board_l_01”))
read_image (ImageR, 视_加 (ImgPath, “board_r_01”))
' Reopen the windows with an appropriate size
dev_set_draw (“margin”)
get_image_size (ImageL, WidthL, HeightL)
get_image_size (ImageR, WidthR, HeightR)
dev_open_window (175, 0, 313, 视_加 (视_除 (视_乘 (HeightL, 到小数 (313)), WidthL), 0.5), “black”, WindowHandle1)
dev_set_part (0, 0, 视_减 (HeightL, 1), 视_减 (WidthL, 1))
dev_display (ImageL)
dev_open_window (175, 327, 313, 视_加 (视_除 (视_乘 (HeightR, 到小数 (313)), WidthR), 0.5), “black”, WindowHandle2)
dev_set_part (0, 0, 视_减 (HeightR, 1), 视_减 (WidthR, 1))
dev_display (ImageR)
wait_seconds (4)
视_设值 (CamParamL, G (0.013126, -621.5135, 1.4806e-005, 1.48e-005, 157.3783, 128.0285, 320, 240))
视_设值 (CamParamR, G (0.013168, -637.8497, 1.4826e-005, 1.48e-005, 160.9209, 114.756, 320, 240))
视_设值 (cLPcR, G (0.1528, -0.0038696, 0.045933, 0.61975, 319.7963, 0.13756, 0))
' Generate the rectification maps
gen_binocular_rectification_map (MapL, MapR, CamParamL, CamParamR, cLPcR, 1, “geometric”, “bilinear”, RectCamParL, RectCamParR, CamPoseRectL, CamPoseRectR, RectLPosRectR)
' Define parameter values for binocular_disparity and binocular_distance, respectively.
视_设值 (MaskWidth, 17)
视_设值 (MaskHeight, 17)
视_设值 (TextureThresh, 5)
视_设值 (MinDisparity, 10)
视_设值 (MaxDisparity, 40)
视_设值 (NumLevels, 1)
视_设值 (ScoreThresh, 0.1)
' Get stereo image pair
' * dev_set_window (WindowHandle1)
emphasize (ImageL, ImageL, 7, 7, 1)
map_image (ImageL, MapL, ImageRectifiedL)
' * dev_display (ImageRectifiedL)
dev_set_window (WindowHandle2)
emphasize (ImageR, ImageR, 7, 7, 1)
map_image (ImageR, MapR, ImageRectifiedR)
' Determine the disparity and the distance image.
binocular_distance (ImageRectifiedL, ImageRectifiedR, DistanceImage, ScoreImageDistance, RectCamParL, RectCamParR, RectLPosRectR, “ncc”, MaskWidth, MaskHeight, TextureThresh, MinDisparity, MaxDisparity, NumLevels, ScoreThresh, “left_right_check”, “interpolation”)
' Correct the distance image for the tilt of the stereo camera system.
' (Attention: the distance values are not measured in the rectified coordinate system anymore!!!)
get_domain (DistanceImage, Domain)
complement (Domain, RegionComplement)
gen_circle (Circle, G (15, 208, 80), G (58, 32, 186), G (10, 10, 10))
union1 (Circle, RegionDefiningReferencePlane)
p_stereo_tilt_correction (DistanceImage, RegionDefiningReferencePlane, DistanceImageCorrected)
视_设值 (MinHeight, -0.0005)
视_设值 (MaxHeight, 0.05)
' Transform the distances into heights above the reference plane.
p_stereo_height_range_above_reference_plane (DistanceImageCorrected, HeightAboveReferencePlaneReduced, MinHeight, MaxHeight)
dev_set_window (WindowHandle1)
dev_clear_window ()
' * dev_display (ImageL)
dev_set_window (WindowHandle2)
dev_set_line_width (1)
dev_set_paint (G (“3D-plot_hidden”, 7, 1, 110, 120, 200, -80, -25))
dev_set_color (“black”)
get_image_pointer1 (HeightAboveReferencePlaneReduced, Pointer, Type, Width3D, Height3D)
gen_image_const (Image3D, “real”, Width3D, Height3D)
smallest_rectangle1 (HeightAboveReferencePlaneReduced, Row1, Column1, Row2, Column2)
gen_rectangle1 (Rectangle, 视_加 (Row1, 2), 视_加 (Column1, 2), 视_减 (Row2, 2), 视_减 (Column2, 2))
reduce_domain (HeightAboveReferencePlaneReduced, Rectangle, ImageReduced)
overpaint_gray (Image3D, ImageReduced)
dev_clear_window ()
dev_set_lut (“sqrt”)
dev_display (Image3D)
dev_set_window (WindowHandle)
dev_set_lut (“default”)
dev_set_paint (“default”)
dev_clear_window ()
disp_message (WindowHandle, “Segment modules using stereo images”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Reconstructed height”, “window”, 72, 334, “black”, “true”)
wait_seconds (3)
dev_set_window (WindowHandle1)
p_stereo_visualize_height_ranges (ImageRectifiedL, HeightAboveReferencePlaneReduced, WindowHandle1, G (0.0004), G (0.0015), G (0.0015), G (0.0025), G (0.0025), G (0.004))
dev_set_window (WindowHandle)
dev_clear_window ()
p_write_message (WindowHandle, G (-1), G (-1), G (“Segment modules using stereo images”), 真)
p_write_message (WindowHandle, G (72), G (12), G (“Segmentation result”), 真)
p_write_message (WindowHandle, G (72), G (334), G (“Reconstructed height”), 真)
wait_seconds (5)
dev_set_window (WindowHandle2)
dev_close_window ()
dev_set_window (WindowHandle1)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()

返回 ()

.子程序 p_stereo_tilt_correction
.参数 DistanceImage, obj
.参数 RegionDefiningReferencePlane, obj
.参数 DistanceImageCorrected, obj, 参考
.局部变量 Alpha, tuple
.局部变量 Area, tuple
.局部变量 Beta, tuple
.局部变量 Column, tuple
.局部变量 CosGamma, tuple
.局部变量 DistanceImageWithoutTilt, obj
.局部变量 Domain, obj
.局部变量 Height, tuple
.局部变量 MCol, tuple
.局部变量 MRow, tuple
.局部变量 Mean, tuple
.局部变量 Pointer, tuple
.局部变量 ReferencePlaneDistance, obj
.局部变量 Row, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple

' Reduce the given region, which defines the reference plane to the domain of the distance image
get_domain (DistanceImage, Domain)
intersection (RegionDefiningReferencePlane, Domain, RegionDefiningReferencePlane)
' Determine the parameters of the reference plane
moments_gray_plane (RegionDefiningReferencePlane, DistanceImage, MRow, MCol, Alpha, Beta, Mean)
' Generate a distance image of the reference plane
get_image_pointer1 (DistanceImage, Pointer, Type, Width, Height)
area_center (RegionDefiningReferencePlane, Area, Row, Column)
gen_image_surface_first_order (ReferencePlaneDistance, Type, Alpha, Beta, Mean, Row, Column, Width, Height)
' Subtract the distance image of the reference plane from the distance image of the object
sub_image (DistanceImage, ReferencePlaneDistance, DistanceImageWithoutTilt, 1, 0)
' Determine the scale factor for the reduction of the distance values
视_设值 (CosGamma, 视_除 (到小数 (1), sqrt (视_加 (视_加 (视_乘 (Alpha, Alpha), 视_乘 (Beta, Beta)), 1))))
' Reduce the distance values
scale_image (DistanceImageWithoutTilt, DistanceImageCorrected, CosGamma, 0)
返回 ()

.子程序 p_stereo_height_range_above_reference_plane
.参数 DistanceImageCorrected, obj
.参数 HeightAboveReferencePlaneReduced, obj, 参考
.参数 MinHeight, tuple
.参数 MaxHeight, tuple
.局部变量 HeightAboveReferencePlane, obj
.局部变量 Region, obj

' This procedure may be useful if the reference plane is the ground plane
' of the object. Then, the inverted corrected distance values
' correspond to heights above the ground plane.
invert_image (DistanceImageCorrected, HeightAboveReferencePlane)
' Reduce the domain of the height image to a given height range.
threshold (HeightAboveReferencePlane, Region, MinHeight, MaxHeight)
reduce_domain (HeightAboveReferencePlane, Region, HeightAboveReferencePlaneReduced)
返回 ()

.子程序 p_stereo_visualize_height_ranges
.参数 ImageMapped1, obj
.参数 HeightAboveReferencePlaneReduced, obj
.参数 WindowHandle1, tuple
.参数 Height1_Min, tuple
.参数 Height1_Max, tuple
.参数 Height2_Min, tuple
.参数 Height2_Max, tuple
.参数 Height3_Min, tuple
.参数 Height3_Max, tuple
.局部变量 Height, tuple
.局部变量 Pointer, tuple
.局部变量 Range1, obj
.局部变量 Range2, obj
.局部变量 Range3, obj
.局部变量 Type, tuple
.局部变量 Width, tuple

dev_set_window (WindowHandle1)
dev_clear_window ()
get_image_pointer1 (HeightAboveReferencePlaneReduced, Pointer, Type, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (ImageMapped1)
dev_set_color (“blue”)
threshold (HeightAboveReferencePlaneReduced, Range1, Height1_Min, Height1_Max)
dev_display (Range1)
dev_set_color (“green”)
threshold (HeightAboveReferencePlaneReduced, Range2, Height2_Min, Height2_Max)
dev_display (Range2)
dev_set_color (“red”)
threshold (HeightAboveReferencePlaneReduced, Range3, Height3_Min, Height3_Max)
dev_display (Range3)
返回 ()

.子程序 p_proj_segment_soccer_field
.参数 Image, obj
.参数 CornerRowUL, tuple, 参考
.参数 CornerColUL, tuple, 参考
.参数 CornerRowUR, tuple, 参考
.参数 CornerColUR, tuple, 参考
.参数 CornerRowLL, tuple, 参考
.参数 CornerColLL, tuple, 参考
.参数 CornerRowLR, tuple, 参考
.参数 CornerColLR, tuple, 参考
.局部变量 ColBegHor, tuple
.局部变量 ColBegVer, tuple
.局部变量 ColEndHor, tuple
.局部变量 ColEndVer, tuple
.局部变量 ConnectedRegions, obj
.局部变量 ContoursSplit, obj
.局部变量 DistHor, tuple
.局部变量 DistVer, tuple
.局部变量 Edges, obj
.局部变量 Field, obj
.局部变量 FieldBorder, obj
.局部变量 FieldConvex, obj
.局部变量 FieldDilation, obj
.局部变量 GreenRegion, obj
.局部变量 HorizontalEdges, obj
.局部变量 ImageB, obj
.局部变量 ImageG, obj
.局部变量 ImageH, obj
.局部变量 ImageR, obj
.局部变量 ImageReduced, obj
.局部变量 ImageS, obj
.局部变量 ImageV, obj
.局部变量 IndexHor, tuple
.局部变量 IndexVer, tuple
.局部变量 IsParallel, tuple
.局部变量 NcHor, tuple
.局部变量 NcVer, tuple
.局部变量 NrHor, tuple
.局部变量 NrVer, tuple
.局部变量 RectangleRegions, obj
.局部变量 RegressContours, obj
.局部变量 RowBegHor, tuple
.局部变量 RowBegVer, tuple
.局部变量 RowEndHor, tuple
.局部变量 RowEndVer, tuple
.局部变量 SelectedContours, obj
.局部变量 SelectedEdges, obj
.局部变量 UnionContours, obj
.局部变量 VerticalEdges, obj

decompose3 (Image, ImageR, ImageG, ImageB)
trans_from_rgb (ImageR, ImageG, ImageB, ImageH, ImageS, ImageV, “hsv”)
threshold (ImageH, GreenRegion, 60, 90)
connection (GreenRegion, ConnectedRegions)
' Select the field region based on the fact that it is the largest component
' that roughly looks like a rotated rectangle.
select_shape_std (ConnectedRegions, RectangleRegions, “rectangle2”, 80)
select_shape_std (RectangleRegions, Field, “max_area”, 90)
' Construct a ROI for the color edge extraction from the boundary of the
' segmented field.
shape_trans (Field, FieldConvex, “convex”)
boundary (FieldConvex, FieldBorder, “inner”)
dilation_rectangle1 (FieldBorder, FieldDilation, 7, 7)
' Perform the color edge extraction.
reduce_domain (Image, FieldDilation, ImageReduced)
edges_color_sub_pix (ImageReduced, Edges, “canny”, 1.5, 20, 40)
' Now select straight edges from the extracted edges and group them into
' the four sides of the quadrilateral.
select_shape_xld (Edges, SelectedEdges, “contlength”, “and”, 15, 500)
' We first need to segment the edges into straight lines because the
' extracted edges may represent more than one side of the quadrilateral.
segment_contours_xld (SelectedEdges, ContoursSplit, “lines”, 5, 4, 2)
regress_contours_xld (ContoursSplit, RegressContours, “no”, 1)
' Weed out edges that are not straight enough.
select_contours_xld (RegressContours, SelectedContours, “curvature”, 0, 0.5, 0, 0)
' Select edges that are long enough to provide meaningful direction information.
select_shape_xld (SelectedContours, SelectedEdges, “contlength”, “and”, 15, 500)
' Group the straight lines into the quadrilateral's sides.
union_collinear_contours_xld (SelectedEdges, UnionContours, 30, 1, 4, 0.1, “attr_forget”)
' Now we need to determine the order of the sides because we want to
' intersect the sides to get the corners of the quadrilateral.  First, we
' separate the sides into roughly horizontal and roughly vertical sides.
select_shape_xld (UnionContours, HorizontalEdges, “phi”, “and”, rad (-20), rad (20))
select_shape_xld (UnionContours, VerticalEdges, G (“phi”, “phi”), “or”, G (rad (-90), rad (60)), G (rad (-60), rad (90)))
' Now we need to order the sides.  The horizontal sides are sorted based on
' their row coordinates, while the vertical sides are sorted based on their
' column coordinates.
fit_line_contour_xld (HorizontalEdges, “tukey”, -1, 0, 10, 2, RowBegHor, ColBegHor, RowEndHor, ColEndHor, NrHor, NcHor, DistHor)
视_设值 (IndexHor, sort_index (RowBegHor))
fit_line_contour_xld (VerticalEdges, “tukey”, -1, 0, 10, 2, RowBegVer, ColBegVer, RowEndVer, ColEndVer, NrVer, NcVer, DistVer)
视_设值 (IndexVer, sort_index (ColBegVer))
' After we have sorted the sides, we can intersect the appropriate sides
' to get the four corners of the quadrilateral.
intersection_ll (视_取元素 (RowBegHor, 视_取元素 (IndexHor, 0)), 视_取元素 (ColBegHor, 视_取元素 (IndexHor, 0)), 视_取元素 (RowEndHor, 视_取元素 (IndexHor, 0)), 视_取元素 (ColEndHor, 视_取元素 (IndexHor, 0)), 视_取元素 (RowBegVer, 视_取元素 (IndexVer, 0)), 视_取元素 (ColBegVer, 视_取元素 (IndexVer, 0)), 视_取元素 (RowEndVer, 视_取元素 (IndexVer, 0)), 视_取元素 (ColEndVer, 视_取元素 (IndexVer, 0)), CornerRowUL, CornerColUL, IsParallel)
intersection_ll (视_取元素 (RowBegHor, 视_取元素 (IndexHor, 0)), 视_取元素 (ColBegHor, 视_取元素 (IndexHor, 0)), 视_取元素 (RowEndHor, 视_取元素 (IndexHor, 0)), 视_取元素 (ColEndHor, 视_取元素 (IndexHor, 0)), 视_取元素 (RowBegVer, 视_取元素 (IndexVer, 1)), 视_取元素 (ColBegVer, 视_取元素 (IndexVer, 1)), 视_取元素 (RowEndVer, 视_取元素 (IndexVer, 1)), 视_取元素 (ColEndVer, 视_取元素 (IndexVer, 1)), CornerRowUR, CornerColUR, IsParallel)
intersection_ll (视_取元素 (RowBegHor, 视_取元素 (IndexHor, 1)), 视_取元素 (ColBegHor, 视_取元素 (IndexHor, 1)), 视_取元素 (RowEndHor, 视_取元素 (IndexHor, 1)), 视_取元素 (ColEndHor, 视_取元素 (IndexHor, 1)), 视_取元素 (RowBegVer, 视_取元素 (IndexVer, 0)), 视_取元素 (ColBegVer, 视_取元素 (IndexVer, 0)), 视_取元素 (RowEndVer, 视_取元素 (IndexVer, 0)), 视_取元素 (ColEndVer, 视_取元素 (IndexVer, 0)), CornerRowLL, CornerColLL, IsParallel)
intersection_ll (视_取元素 (RowBegHor, 视_取元素 (IndexHor, 1)), 视_取元素 (ColBegHor, 视_取元素 (IndexHor, 1)), 视_取元素 (RowEndHor, 视_取元素 (IndexHor, 1)), 视_取元素 (ColEndHor, 视_取元素 (IndexHor, 1)), 视_取元素 (RowBegVer, 视_取元素 (IndexVer, 1)), 视_取元素 (ColBegVer, 视_取元素 (IndexVer, 1)), 视_取元素 (RowEndVer, 视_取元素 (IndexVer, 1)), 视_取元素 (ColEndVer, 视_取元素 (IndexVer, 1)), CornerRowLR, CornerColLR, IsParallel)
返回 ()

.子程序 p_proj_create_mvtec_logo
.参数 MVTecLogo, obj, 参考
.参数 LogoImage, obj, 参考
.局部变量 Blue, obj
.局部变量 Characters, obj
.局部变量 Col, tuple
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 Green, obj
.局部变量 Height, tuple
.局部变量 HomMat2D, tuple
.局部变量 Image, obj
.局部变量 Length1, tuple
.局部变量 Length2, tuple
.局部变量 LogoImageOrig, obj
.局部变量 LogoImageTrans, obj
.局部变量 Phi, tuple
.局部变量 Pointer, tuple
.局部变量 Red, obj
.局部变量 RegionAffineTrans, obj
.局部变量 RegionUnion, obj
.局部变量 Regions, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 SelectedRegions, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 blue, tuple
.局部变量 orange, tuple

视_设值 (blue, G (0, 48, 117))
视_设值 (orange, G (255, 181, 41))
' read an image containing the logo
read_image (Image, “pen/pen-01”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
auto_threshold (Image, Regions, 10)
connection (Regions, Regions)
select_shape (Regions, SelectedRegions, G (“row1”, “holes_num”), “and”, G (80, 0), G (100, 0))
sort_region (SelectedRegions, SelectedRegions, “character”, “true”, “row”)
closing_rectangle1 (SelectedRegions, Characters, 3, 3)
opening_rectangle1 (Characters, Characters, 5, 5)
' create the colored image of the logo
gen_image_const (Red, “byte”, Width, Height)
gen_image_const (Green, “byte”, Width, Height)
gen_image_const (Blue, “byte”, Width, Height)
compose3 (Red, Green, Blue, LogoImageOrig)
paint_region (Characters, LogoImageOrig, LogoImage, G (blue, orange, blue, blue, blue), “fill”)
union1 (Characters, RegionUnion)
' crop the logo
smallest_rectangle2 (RegionUnion, Row, Col, Phi, Length1, Length2)
vector_angle_to_rigid (Row, Col, Phi, Length2, Length1, 到小数 (0), HomMat2D)
affine_trans_image (LogoImage, LogoImageTrans, HomMat2D, “constant”, “false”)
affine_trans_region (RegionUnion, RegionAffineTrans, HomMat2D, “false”)
reduce_domain (LogoImageTrans, RegionAffineTrans, LogoImageTrans)
smallest_rectangle1 (RegionAffineTrans, Row1, Column1, Row2, Column2)
crop_rectangle1 (LogoImageTrans, MVTecLogo, Row1, Column1, Row2, Column2)
返回 ()

.子程序 p_do_projective_trans
.局部变量 CharactersXLD, obj
.局部变量 Col, tuple
.局部变量 Col1, tuple
.局部变量 Col2, tuple
.局部变量 Contour, obj
.局部变量 CornerColLL, tuple
.局部变量 CornerColLR, tuple
.局部变量 CornerColUL, tuple
.局部变量 CornerColUR, tuple
.局部变量 CornerRowLL, tuple
.局部变量 CornerRowLR, tuple
.局部变量 CornerRowUL, tuple
.局部变量 CornerRowUR, tuple
.局部变量 Covariance, tuple
.局部变量 Factor, tuple
.局部变量 Height, tuple
.局部变量 HomMat2D, tuple
.局部变量 HomMat2DBack, tuple
.局部变量 Image, obj
.局部变量 ImageResult, obj
.局部变量 Length1, tuple
.局部变量 Length2, tuple
.局部变量 LogoCharacters, obj
.局部变量 LogoDomain, obj
.局部变量 LogoImage, obj
.局部变量 MVTecLogo, obj
.局部变量 Phi, tuple
.局部变量 Pointer, tuple
.局部变量 ProjCharactersXLD, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 StadiumAndLogo, obj
.局部变量 StadiumAndLogoRect, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 blue, tuple
.局部变量 orange, tuple
.局部变量 true, tuple

' This example program shows projective image distorion

read_image (Image, “olympic_stadium”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)

dev_open_window (0, 0, 640, 视_除 (视_乘 (Height, 到小数 (640)), Width), “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

' First, segment the soccerfield of the olympic stadium...
p_proj_segment_soccer_field (Image, CornerRowUL, CornerColUL, CornerRowUR, CornerColUR, CornerRowLL, CornerColLL, CornerRowLR, CornerColLR)
gen_contour_polygon_xld (Contour, G (CornerRowUL, CornerRowUR, CornerRowLR, CornerRowLL, CornerRowUL), G (CornerColUL, CornerColUR, CornerColLR, CornerColLL, CornerColUL))
' ... and get an MVTec logo to project onto the lawn:
p_proj_create_mvtec_logo (MVTecLogo, LogoImage)
dev_display (LogoImage)
p_write_message (WindowHandle, G (-1), G (-1), G (“Project the MVTec logo...”), 真)
wait_seconds (2)
dev_display (Image)
p_write_message (WindowHandle, G (-1), G (-1), G (“...onto the field of the olympic stadium”), 真)
wait_seconds (1)
get_domain (MVTecLogo, LogoDomain)
smallest_rectangle2 (LogoDomain, Row, Col, Phi, Length1, Length2)
视_设值 (Factor, 视_除 (180, 到小数 (300)))
视_设值 (Length1, 视_加 (Length1, 20))
视_设值 (Row1, 视_减 (Row, 视_乘 (Length1, Factor)))
视_设值 (Row2, 视_加 (Row, 视_乘 (Length1, Factor)))
视_设值 (Col1, 视_减 (Col, Length1))
视_设值 (Col2, 视_加 (Col, Length1))
connection (LogoDomain, LogoCharacters)
gen_contour_region_xld (LogoCharacters, CharactersXLD, “border”)
' Now we can determine a projective transformation that will map our Logo
' quadrilateral to a rectangle of given dimensions.  Note that we have to
' add 0.5 to the coordinates to make the extracted pixel positions fit the
' coordinate system that is used by perspective_trans_image.
vector_to_proj_hom_mat2d (视_加 (G (Row1, Row1, Row2, Row2), 0.5), 视_加 (G (Col1, Col2, Col1, Col2), 0.5), 视_加 (G (CornerRowUL, CornerRowUR, CornerRowLL, CornerRowLR), 0.5), 视_加 (G (CornerColUL, CornerColUR, CornerColLL, CornerColLR), 0.5), “normalized_dlt”, G (), G (), G (), G (), G (), G (), HomMat2D, Covariance)
projective_trans_contour_xld (CharactersXLD, ProjCharactersXLD, HomMat2D)
' paint the MVTec logo onto the lawn
视_设值 (blue, G (0, 48, 117))
视_设值 (orange, G (255, 181, 41))
paint_xld (ProjCharactersXLD, Image, ImageResult, G (blue, orange, blue, blue, blue))
add_image (Image, ImageResult, StadiumAndLogo, 0.5, 0)
dev_display (StadiumAndLogo)
p_write_message (WindowHandle, G (-1), G (-1), G (“...onto the field of the olympic stadium”), 真)
wait_seconds (3)
vector_to_proj_hom_mat2d (G (CornerRowUL, CornerRowUR, CornerRowLL, CornerRowLR), G (CornerColUL, CornerColUR, CornerColLL, CornerColLR), G (160, 160, 340, 340), G (250, 550, 250, 550), “normalized_dlt”, G (), G (), G (), G (), G (), G (), HomMat2DBack, Covariance)
projective_trans_image (StadiumAndLogo, StadiumAndLogoRect, HomMat2DBack, “bilinear”, “false”, “false”)
dev_display (StadiumAndLogoRect)
p_write_message (WindowHandle, G (-1), G (-1), G (“Top view”), 真)
wait_seconds (3)
dev_close_window ()
返回 ()

.子程序 p_set_font
.参数 WindowHandle, tuple
.局部变量 OS, tuple

get_system (“operating_system”, OS)
.如果 (视_等于 (视_取文本范围 (OS, 0, 2), “Win”))
    set_font (WindowHandle, “-Courier New-18-*-*-*-*-1-”)
.否则
    set_font (WindowHandle, “-adobe-courier-bold-r-normal--20-*-*-*-*-*-*-*”)
.如果结束
返回 ()

.子程序 p_do_component_matching
.局部变量 AngleComp, tuple
.局部变量 AngleCompInst, tuple
.局部变量 AngleExtent, tuple
.局部变量 AngleRef, tuple
.局部变量 AngleStart, tuple
.局部变量 Column, tuple
.局部变量 ColumnComp, tuple
.局部变量 ColumnCompInst, tuple
.局部变量 ColumnRef, tuple
.局部变量 ComponentModelID, tuple
.局部变量 ComponentTrainingID, tuple
.局部变量 EndNode, tuple
.局部变量 FoundComponents, obj
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 ImgNo, tuple
.局部变量 InitialComponentRegions, obj
.局部变量 J, 整数型
.局部变量 Length1, tuple
.局部变量 Length2, tuple
.局部变量 ModelComp, tuple
.局部变量 ModelComponents, obj
.局部变量 ModelEnd, tuple
.局部变量 ModelImage, obj
.局部变量 ModelStart, tuple
.局部变量 NumComp, tuple
.局部变量 NumFound, tuple
.局部变量 ObjectSelected, obj
.局部变量 Phi, tuple
.局部变量 Pregen, tuple
.局部变量 Rectangle2, obj
.局部变量 Rectangle3, obj
.局部变量 Rectangle4, obj
.局部变量 Relations, obj
.局部变量 RootRanking, tuple
.局部变量 Row, tuple
.局部变量 RowComp, tuple
.局部变量 RowCompInst, tuple
.局部变量 RowRef, tuple
.局部变量 Score, tuple
.局部变量 ScoreComp, tuple
.局部变量 ScoreCompInst, tuple
.局部变量 ScoreRef, tuple
.局部变量 SearchImage, obj
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 StartNode, tuple
.局部变量 Time, tuple
.局部变量 TrainingImage, obj
.局部变量 TrainingImages, obj
.局部变量 Tree, obj
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple

' This example shows how to use the component-based matching in order
' to locate a  pipe wrench that consists of two components. Because the relative
' movements of the components are complicated to describe manually, the
' relations are automatically trained by using four training images that
' show the extreme relative poses of the two components in order to cover
' all possible relative poses in a later run-time image. The example further
' shows how the obtained pose parameters of the components can be
' used to evaluate object specific features, e.g., the opening angle and
' the shift extent of the pliers.
dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)
dev_set_draw (“margin”)
read_image (ModelImage, “pipe_wrench/pipe_wrench_model”)
get_image_size (ModelImage, Width, Height)
dev_open_window (0, 0, Width, Height, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
' Define the initial components
gen_rectangle2 (InitialComponentRegions, 298, 363, 1.17, 162, 34)
gen_rectangle2 (Rectangle2, 212, 233, 0.62, 167, 29)
gen_rectangle2 (Rectangle3, 63, 444, -0.26, 50, 27)
gen_rectangle2 (Rectangle4, 120, 473, 0, 33, 20)
concat_obj (InitialComponentRegions, Rectangle2, InitialComponentRegions)
concat_obj (InitialComponentRegions, Rectangle3, InitialComponentRegions)
concat_obj (InitialComponentRegions, Rectangle4, InitialComponentRegions)
dev_set_line_width (3)
dev_set_colored (12)
dev_display (ModelImage)
dev_display (InitialComponentRegions)
disp_message (WindowHandle, G (“Locate a pipe wrench in different states”, “Model image”), “window”, -1, -1, “black”, “true”)
wait_seconds (3)
' Get the training images
gen_empty_obj (TrainingImages)
.变量循环首 (1, 4, 1, J)
    read_image (TrainingImage, 视_加 (“pipe_wrench/pipe_wrench_training_”, J))
    concat_obj (TrainingImages, TrainingImage, TrainingImages)
    dev_display (TrainingImage)
    disp_message (WindowHandle, “Provide training images”, “window”, -1, -1, “black”, “true”)
    wait_seconds (0.8)
.变量循环尾 ()
' The component-based matching uses the contours of the components
' as features for the matching. In order to make sure that only significant
' features are involved in the matching the parameters ContrastLow,
' ContrastHigh, and MinSize can be passed to the training. To inspect the
' effect of different values for these three parameters, and hence to find
' the optimum values for a certain application the following, two lines of
' code can be used:
' * add_channels (InitialComponentRegions, ModelImage, ModelImageInitComp)
' * gen_initial_components (ModelImageInitComp, InitialComponentEdges, 22, 60, 30, 'connection', [], [])
' Extract the model components and train the relations
' (This may take a few seconds!)
dev_display (ModelImage)
disp_message (WindowHandle, “Train the relative movements”, “window”, -1, -1, “black”, “true”)
' Due to perspective distortions of the 3d object pseudo movements of the
' initial components are introduced. Consequently, if the cluster threshold is
' set to a high value three model components are extracted. However, since
' the pliers consist of two components the cluster threshold is set to a lower
' value of 0.4, which is sufficient to obtain two model components. Nevertheless,
' the score values that must be expected for the components during the search
' is small due to the perspective distortions. Hence, the minimum score must be
' set to a small value in order to avoid missing matches. Furthermore, in order to
' accelerate the training the pregeneration of the shape models is switched off.
get_system (“pregenerate_shape_models”, Pregen)
set_system (“pregenerate_shape_models”, “false”)
train_model_components (ModelImage, InitialComponentRegions, TrainingImages, ModelComponents, 22, 60, 30, 0.65, -1, -1, rad (60), “speed”, “rigidity”, 0.2, 0.3, ComponentTrainingID)
set_system (“pregenerate_shape_models”, Pregen)
dev_display (ModelImage)
dev_set_colored (12)
get_training_components (ModelComponents, ComponentTrainingID, “model_components”, “model_image”, “false”, RowRef, ColumnRef, AngleRef, ScoreRef)
count_obj (ModelComponents, NumComp)
' Create the component model based on the training result.
create_trained_component_model (ComponentTrainingID, rad (-90), rad (180), 10, 0.6, 4, “auto”, “none”, “use_polarity”, “false”, ComponentModelID, RootRanking)
get_component_model_tree (Tree, Relations, ComponentModelID, 1, “model_image”, StartNode, EndNode, Row, Column, Phi, Length1, Length2, AngleStart, AngleExtent)
dev_display (ModelImage)
dev_set_line_width (2)
dev_set_color (“yellow”)
select_obj (ModelComponents, ObjectSelected, 1)
dev_display (ObjectSelected)
dev_set_color (“blue”)
select_obj (ModelComponents, ObjectSelected, 2)
dev_display (ObjectSelected)
disp_message (WindowHandle, “Component model”, “window”, -1, -1, “black”, “true”)
dev_set_line_width (2)
dev_set_color (“black”)
dev_display (Tree)
dev_display (Relations)
disp_message (WindowHandle, “Relative movement”, “window”, 280, 390, “black”, “true”)
disp_line (WindowHandle, 236, 431, 280, 452)
wait_seconds (4)
clear_training_components (ComponentTrainingID)
' Find the component model in a run-time image
.变量循环首 (1, 3, 1, I)
    read_image (SearchImage, 视_加 (“pipe_wrench/pipe_wrench_”, I))
    find_component_model (SearchImage, ComponentModelID, 1, rad (-90), rad (180), 0, 0, 1, “stop_search”, “prune_branch”, “none”, 0.6, “least_squares”, 0, 0.7, ModelStart, ModelEnd, Score, RowComp, ColumnComp, AngleComp, ScoreComp, ModelComp)
.变量循环尾 ()
dev_set_line_width (2)
视_设值 (ImgNo, 1)
.变量循环首 (1, 30, 1, I)
    .如果 (视_大于 (ImgNo, 4))
        read_image (SearchImage, 视_加 (“pipe_wrench/pipe_wrench_”, 视_减 (ImgNo, 4)))
    .否则
        ' For illustration purposes the pipe wrench is also searched
        ' in the training images.
        read_image (SearchImage, 视_加 (“pipe_wrench/pipe_wrench_training_”, ImgNo))
    .如果结束
    count_seconds (Seconds1)
    find_component_model (SearchImage, ComponentModelID, RootRanking, rad (-90), rad (180), 0, 0, 1, “stop_search”, “prune_branch”, “none”, 0.6, “interpolation”, 0, 0.7, ModelStart, ModelEnd, Score, RowComp, ColumnComp, AngleComp, ScoreComp, ModelComp)
    count_seconds (Seconds2)
    dev_display (SearchImage)
    视_设值 (NumFound, 视_取元素总数 (ModelStart))
    视_设值 (Time, 视_乘 (1000, 视_减 (Seconds2, Seconds1)))
    .如果 (视_是否为真 (NumFound))
        get_found_component_model (FoundComponents, ComponentModelID, ModelStart, ModelEnd, RowComp, ColumnComp, AngleComp, ScoreComp, ModelComp, 0, “false”, RowCompInst, ColumnCompInst, AngleCompInst, ScoreCompInst)
        select_obj (FoundComponents, ObjectSelected, 1)
        dev_set_color (“yellow”)
        dev_display (ObjectSelected)
        select_obj (FoundComponents, ObjectSelected, 2)
        dev_set_color (“blue”)
        dev_display (ObjectSelected)
        p_component_visualize_pliers_match (AngleCompInst, WindowHandle, RowCompInst, ColumnCompInst, RowRef, ColumnRef)
        disp_message (WindowHandle, 视_加 (视_加 (“Pipe wrench found in ”, 视_文本格式化 (Time, “.1f”)), “ ms”), “window”, -1, -1, “black”, “true”)
    .否则

    .如果结束
    视_设值 (ImgNo, 视_加 (ImgNo, 1))
    .如果 (视_大于 (ImgNo, 8))
        视_设值 (ImgNo, 1)
    .否则

    .如果结束
    .如果 (视_小于 (I, 3))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (3)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (2)
clear_component_model (ComponentModelID)
dev_close_window ()
dev_set_line_width (1)
dev_update_pc (“on”)
dev_update_window (“off”)
dev_update_var (“on”)
返回 ()

.子程序 p_component_visualize_pliers_match
.参数 AngleCompInst, tuple
.参数 WindowHandle, tuple
.参数 RowCompInst, tuple
.参数 ColumnCompInst, tuple
.参数 RowRef, tuple
.参数 ColumnRef, tuple
.局部变量 AngleOpen, tuple
.局部变量 Circle, obj
.局部变量 ColCent, tuple
.局部变量 ColCent_s, tuple
.局部变量 ContEllipse, obj
.局部变量 Contour1, obj
.局部变量 Contour2, obj
.局部变量 HomMat2D, tuple
.局部变量 Length, tuple
.局部变量 Message, tuple
.局部变量 PosCol, tuple
.局部变量 PosRow, tuple
.局部变量 Rectangle, obj
.局部变量 RowCent, tuple
.局部变量 RowCent_s, tuple
.局部变量 a1, tuple
.局部变量 alpha1, tuple
.局部变量 alpha2, tuple
.局部变量 c1, tuple
.局部变量 c1_1, tuple
.局部变量 c1_2, tuple
.局部变量 c2_1, tuple
.局部变量 c2_2, tuple
.局部变量 dc, tuple
.局部变量 distance, tuple
.局部变量 dr, tuple
.局部变量 r1, tuple
.局部变量 r1_1, tuple
.局部变量 r1_2, tuple
.局部变量 r2_1, tuple
.局部变量 r2_2, tuple

视_设值 (Length, 250)
视_设值 (PosCol, 550)
视_设值 (PosRow, 250)
视_设值 (ColCent, 420)
视_设值 (RowCent, 108)
' Display first component
视_设值 (alpha1, 视_加 (rad (34.7), 视_取元素 (AngleCompInst, 1)))
视_设值 (c1_1, 视_加 (PosCol, 视_乘 (视_除 (Length, 到小数 (3)), cos (alpha1))))
视_设值 (r1_1, 视_减 (PosRow, 视_乘 (视_除 (Length, 到小数 (3)), sin (alpha1))))
视_设值 (c1_2, 视_减 (PosCol, 视_乘 (视_除 (视_乘 (2, Length), 到小数 (3)), cos (alpha1))))
视_设值 (r1_2, 视_加 (PosRow, 视_乘 (视_除 (视_乘 (2, Length), 到小数 (3)), sin (alpha1))))
gen_contour_polygon_xld (Contour1, G (r1_1, r1_2), G (c1_1, c1_2))
dev_set_color (“blue”)
dev_display (Contour1)
' Display second component
视_设值 (alpha2, 视_加 (rad (61.7), 视_取元素 (AngleCompInst, 0)))
视_设值 (c2_1, 视_加 (PosCol, 视_乘 (视_除 (Length, 到小数 (3)), cos (alpha2))))
视_设值 (r2_1, 视_减 (PosRow, 视_乘 (视_除 (Length, 到小数 (3)), sin (alpha2))))
视_设值 (c2_2, 视_减 (PosCol, 视_乘 (视_除 (视_乘 (2, Length), 到小数 (3)), cos (alpha2))))
视_设值 (r2_2, 视_加 (PosRow, 视_乘 (视_除 (视_乘 (2, Length), 到小数 (3)), sin (alpha2))))
gen_contour_polygon_xld (Contour2, G (r2_1, r2_2), G (c2_1, c2_2))
dev_set_color (“yellow”)
dev_display (Contour2)
' Display opening angle
dev_set_color (“black”)
gen_ellipse_contour_xld (ContEllipse, PosRow, PosCol, 0, 80, 80, 视_加 (alpha1, 3.1416), 视_加 (alpha2, 3.1416), “positive”, 1.5)
dev_display (ContEllipse)
视_设值 (AngleOpen, deg (视_减 (alpha2, alpha1)))
视_设值 (Message, 视_加 (视_加 (“Opening angle: ”, 视_文本格式化 (AngleOpen, “8.1f”)), “°”))
' Display shift extent
视_设值 (r1, 视_取元素 (RowCompInst, 1))
视_设值 (c1, 视_取元素 (ColumnCompInst, 1))
视_设值 (a1, 视_取元素 (AngleCompInst, 1))
vector_angle_to_rigid (视_取元素 (RowRef, 1), 视_取元素 (ColumnRef, 1), 0, r1, c1, a1, HomMat2D)
affine_trans_point_2d (HomMat2D, RowCent, ColCent, RowCent_s, ColCent_s)
gen_circle (Circle, RowCent_s, ColCent_s, 10)
视_设值 (dr, 视_减 (RowCent_s, 视_取元素 (RowCompInst, 0)))
视_设值 (dc, 视_减 (ColCent_s, 视_取元素 (ColumnCompInst, 0)))
视_设值 (distance, 视_除 (视_减 (sqrt (视_加 (视_乘 (dr, dr), 视_乘 (dc, dc))), 72.9), 52.7))
gen_rectangle2 (Rectangle, 视_加 (PosRow, 视_乘 (视_乘 (60, 视_减 (distance, 0.5)), sin (alpha2))), 视_减 (PosCol, 视_乘 (视_乘 (60, 视_减 (distance, 0.5)), cos (alpha2))), alpha2, 35, 10)
gen_circle (Circle, PosRow, PosCol, 5)
dev_display (Rectangle)
dev_display (Circle)
视_设值 (Message, G (Message, 视_加 (“Shift extent [0;1]: ”, 视_文本格式化 (distance, “2.1f”))))
disp_message (WindowHandle, Message, “window”, 视_加 (PosRow, 170), 视_减 (PosCol, 250), “black”, “true”)
返回 ()

.子程序 p_do_mosaicking
.局部变量 Alpha, tuple
.局部变量 CamParOut, tuple
.局部变量 CamParam, tuple
.局部变量 ColF, tuple
.局部变量 ColFAll, tuple
.局部变量 ColMove, tuple
.局部变量 ColT, tuple
.局部变量 ColTAll, tuple
.局部变量 ColTolerance, tuple
.局部变量 Cols, tuple
.局部变量 Cols1, tuple
.局部变量 Cols2, tuple
.局部变量 DistanceThreshold, tuple
.局部变量 Error, tuple
.局部变量 F, tuple
.局部变量 FShiftC, tuple
.局部变量 FShiftR, tuple
.局部变量 From, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 ImageBlank, obj
.局部变量 ImageBorder, obj
.局部变量 ImageF, obj
.局部变量 ImageT, obj
.局部变量 Images, obj
.局部变量 ImagesBorder, obj
.局部变量 ImgName, tuple
.局部变量 ImgPath, tuple
.局部变量 J, 整数型
.局部变量 K, 整数型
.局部变量 MaskSize, tuple
.局部变量 Match, obj
.局部变量 MatchThreshold, tuple
.局部变量 Matches, obj
.局部变量 MosaicImage, obj
.局部变量 MosaicImageBorder, obj
.局部变量 MosaicMatrices2D, tuple
.局部变量 Num, tuple
.局部变量 NumCorrespondences, tuple
.局部变量 PartCenterCol, tuple
.局部变量 PartCenterRow, tuple
.局部变量 PartHeight, tuple
.局部变量 PartWidth, tuple
.局部变量 Pointer, tuple
.局部变量 Points1, tuple
.局部变量 Points2, tuple
.局部变量 PointsF, obj
.局部变量 PointsT, obj
.局部变量 ProjMatrices, tuple
.局部变量 ProjMatrix, tuple
.局部变量 RandSeed, tuple
.局部变量 Rectangle, obj
.局部变量 Rotation, tuple
.局部变量 RowF, tuple
.局部变量 RowFAll, tuple
.局部变量 RowMove, tuple
.局部变量 RowT, tuple
.局部变量 RowTAll, tuple
.局部变量 RowTolerance, tuple
.局部变量 Rows, tuple
.局部变量 Rows1, tuple
.局部变量 Rows2, tuple
.局部变量 Seams, obj
.局部变量 SelectedImages, tuple
.局部变量 SigmaGrad, tuple
.局部变量 SigmaSmooth, tuple
.局部变量 StackingOrder, tuple
.局部变量 StartImage, tuple
.局部变量 T, tuple
.局部变量 TShiftC, tuple
.局部变量 TShiftR, tuple
.局部变量 Threshold, tuple
.局部变量 TiledImage, obj
.局部变量 To, tuple
.局部变量 TransMat2D, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle1, tuple
.局部变量 WindowHandle2, tuple

' This example program shows how several images can be combined
' into a large mosaic image.  The program shows how to use
' proj_match_points_ransac, bundle_adjust_mosaic, and
' gen_bundle_adjusted_mosaic to achieve this.

' Set image path and name
视_设值 (ImgPath, “3d_machine_vision/mosaic/”)
视_设值 (ImgName, “bga_r_”)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle1)
dev_set_line_width (1)
dev_set_color (“green”)
p_set_font (WindowHandle1)
' The interior camera parameters of the used camera (necessary only, if the
' radial distortions are to be eliminated)
视_设值 (CamParam, G (0.0121693, -2675.63, 7.40046e-006, 7.4e-006, 290.491, 258.887, 640, 480))
change_radial_distortion_cam_par (“adaptive”, CamParam, 0, CamParOut)
' Read in the images and show them one-by-one.
gen_empty_obj (Images)
视_设值 (SelectedImages, G (1, 2, 3, 6, 7, 8))
.变量循环首 (1, 6, 1, J)
    I ＝ LL (视_取元素 (SelectedImages, 视_减 (J, 1)), )
    read_image (Image, 视_加 (视_加 (ImgPath, ImgName), 视_文本格式化 (I, “02”)))
    get_image_pointer1 (Image, Pointer, Type, Width, Height)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    change_radial_distortion_image (Image, Image, Image, CamParam, CamParOut)
    concat_obj (Images, Image, Images)
    dev_display (Image)
    disp_message (WindowHandle1, “Create mosaic from 6 images”, “window”, -1, -1, “black”, “true”)
    disp_message (WindowHandle1, 视_加 (“Image ”, 视_文本格式化 (J, “d”)), “window”, 40, -1, “black”, “true”)
    wait_seconds (0.7)
.变量循环尾 ()
' To show the point matches that are used to compute the projective
' transformation between the images, we will show all images in a large
' tiled image with some space between the images so that the extents
' of the images are easily visible.
dev_set_window_extents (-1, -1, 视_除 (1960, 3.0625), 视_除 (980, 3.0625))
dev_set_part (0, 0, 979, 1959)
tile_images_offset (Images, TiledImage, G (0, 0, 0, 500, 500, 500), G (0, 660, 1320, 0, 660, 1320), G (-1, -1, -1, -1, -1, -1), G (-1, -1, -1, -1, -1, -1), G (-1, -1, -1, -1, -1, -1), G (-1, -1, -1, -1, -1, -1), 1960, 980)
dev_clear_window ()
dev_display (TiledImage)
dev_set_color (“green”)
dev_set_draw (“margin”)
dev_set_line_width (2)
.变量循环首 (1, 6, 1, I)
    .如果 (视_小于 (I, 4))
        disp_rectangle1 (WindowHandle1, 0, 视_乘 (视_减 (I, 1), 660), 480, 视_减 (视_乘 (I, 660), 20))
    .否则
        disp_rectangle1 (WindowHandle1, 500, 视_乘 (视_减 (I, 4), 660), 980, 视_减 (视_乘 (视_减 (I, 3), 660), 20))
    .如果结束

.变量循环尾 ()
disp_message (WindowHandle1, “All 6 images”, “window”, -1, -1, “black”, “true”)
dev_set_line_width (1)
dev_set_draw (“fill”)
wait_seconds (3)
' Now we compute point matches between pairs of images and with this
' the projective transformation between the image pairs.
dev_clear_window ()
dev_display (TiledImage)
disp_message (WindowHandle1, “Point matches used for bundle adjustment”, “window”, -1, -1, “black”, “true”)
视_设值 (From, G (1, 1, 1, 4, 2, 2, 2, 2, 5, 3, 3))
视_设值 (To, G (4, 5, 2, 5, 4, 5, 6, 3, 6, 5, 6))
视_设值 (Num, 视_取元素总数 (From))
' We need a variable to accumulate the projective transformation matrices,
' the coordinates of the matched points, and the number of matched
' points for each image pair.
视_设值 (ProjMatrices, G ())
视_设值 (Rows1, G ())
视_设值 (Cols1, G ())
视_设值 (Rows2, G ())
视_设值 (Cols2, G ())
视_设值 (NumCorrespondences, G ())
' Now we can determine the transformations between the image pairs.
.变量循环首 (0, DD (视_减 (Num, 1), ), 1, J)
    视_设值 (F, 视_取元素 (From, J))
    视_设值 (T, 视_取元素 (To, J))
    select_obj (Images, ImageF, F)
    select_obj (Images, ImageT, T)
    ' Extract the points in both images.
    视_设值 (SigmaGrad, 1)
    视_设值 (SigmaSmooth, 3)
    视_设值 (Alpha, 0.04)
    视_设值 (Threshold, 0)
    points_harris (ImageF, SigmaGrad, SigmaSmooth, Alpha, Threshold, RowFAll, ColFAll)
    points_harris (ImageT, SigmaGrad, SigmaSmooth, Alpha, Threshold, RowTAll, ColTAll)
    ' Define initial values for the position of the search window
    .如果 (视_大于 (F, 3))
        视_设值 (FShiftR, 500)
        视_设值 (FShiftC, 视_乘 (视_减 (F, 4), 660))
    .否则
        视_设值 (FShiftR, 0)
        视_设值 (FShiftC, 视_乘 (视_减 (F, 1), 660))
    .如果结束
    .如果 (视_大于 (T, 3))
        视_设值 (TShiftR, 500)
        视_设值 (TShiftC, 视_乘 (视_减 (T, 4), 660))
    .否则
        视_设值 (TShiftR, 0)
        视_设值 (TShiftC, 视_乘 (视_减 (T, 1), 660))
    .如果结束
    视_设值 (RowMove, 视_除 (视_减 (FShiftR, TShiftR), 2.7))
    视_设值 (ColMove, 视_除 (视_减 (FShiftC, TShiftC), 2))
    ' Perform the matching
    视_设值 (MaskSize, 21)
    视_设值 (RowTolerance, 20)
    视_设值 (ColTolerance, 20)
    视_设值 (Rotation, 0)
    视_设值 (MatchThreshold, 50)
    视_设值 (DistanceThreshold, 0.25)
    视_设值 (RandSeed, 4364537)
    proj_match_points_ransac (ImageF, ImageT, RowFAll, ColFAll, RowTAll, ColTAll, “sad”, MaskSize, RowMove, ColMove, RowTolerance, ColTolerance, Rotation, MatchThreshold, “gold_standard”, DistanceThreshold, RandSeed, ProjMatrix, Points1, Points2)
    ' Accumulate the transformation matrices
    视_设值 (ProjMatrices, G (ProjMatrices, ProjMatrix))
    ' and the matched points.
    视_设值 (Rows1, G (Rows1, subset (RowFAll, Points1)))
    视_设值 (Cols1, G (Cols1, subset (ColFAll, Points1)))
    视_设值 (Rows2, G (Rows2, subset (RowTAll, Points2)))
    视_设值 (Cols2, G (Cols2, subset (ColTAll, Points2)))
    视_设值 (NumCorrespondences, G (NumCorrespondences, 视_取元素总数 (Points1)))
    ' Generate crosses that represent the extracted points in the tiled image.
    ' Note that we have to take the row offsets of the images in the tiled image
    ' into account.
    gen_cross_contour_xld (PointsF, 视_加 (RowFAll, FShiftR), 视_加 (ColFAll, FShiftC), 6, rad (45))
    gen_cross_contour_xld (PointsT, 视_加 (RowTAll, TShiftR), 视_加 (ColTAll, TShiftC), 6, rad (45))
    ' Generate a representation of the matched point pairs as lines.  We create
    ' XLD contours from the lines so that we can zoom into the graphics window
    ' to take a closer look at the matches.
    视_设值 (RowF, 视_加 (subset (RowFAll, Points1), FShiftR))
    视_设值 (ColF, 视_加 (subset (ColFAll, Points1), FShiftC))
    视_设值 (RowT, 视_加 (subset (RowTAll, Points2), TShiftR))
    视_设值 (ColT, 视_加 (subset (ColTAll, Points2), TShiftC))
    gen_empty_obj (Matches)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (RowF), 1), ), 1, K)
        gen_contour_polygon_xld (Match, G (视_取元素 (RowF, K), 视_取元素 (RowT, K)), G (视_取元素 (ColF, K), 视_取元素 (ColT, K)))
        concat_obj (Matches, Match, Matches)
    .变量循环尾 ()
    ' Now display the extracted data.
    dev_set_color (“blue”)
    dev_display (Matches)
    dev_set_color (“green”)
    dev_display (PointsF)
    dev_display (PointsT)
    disp_message (WindowHandle1, “Point matches used for bundle adjustment”, “window”, -1, -1, “black”, “true”)
.变量循环尾 ()
wait_seconds (3)
' Set the stacking order
视_设值 (StartImage, 2)
视_设值 (StackingOrder, G (4, 5, 6, 1, 2, 3))
' Finally, we can generate the bundle adjusted mosaic image from the projective transformations.
bundle_adjust_mosaic (6, StartImage, From, To, ProjMatrices, Rows1, Cols1, Rows2, Cols2, NumCorrespondences, “projective”, MosaicMatrices2D, Rows, Cols, Error)
gen_bundle_adjusted_mosaic (Images, MosaicImage, MosaicMatrices2D, StackingOrder, “false”, TransMat2D)
get_image_pointer1 (MosaicImage, Pointer, Type, Width, Height)
dev_set_window_extents (-1, -1, 640, 视_除 (视_乘 (Height, 到小数 (640)), Width))
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_clear_window ()
dev_display (MosaicImage)
disp_message (WindowHandle1, “Image mosaic”, “window”, -1, -1, “black”, “true”)
wait_seconds (4)
' To investigate the seam between two images, we first display the borders
' of the individual images.
' This can be done most easily by creating an image that contains the border
' of the images, generating a mosaic from it, and segmenting the resulting
' mosaic image.
get_image_pointer1 (Image, Pointer, Type, Width, Height)
gen_image_const (ImageBlank, “byte”, Width, Height)
gen_rectangle1 (Rectangle, 0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
paint_region (Rectangle, ImageBlank, ImageBorder, 255, “margin”)
gen_empty_obj (ImagesBorder)
.变量循环首 (1, 6, 1, J)
    concat_obj (ImagesBorder, ImageBorder, ImagesBorder)
.变量循环尾 ()
gen_bundle_adjusted_mosaic (ImagesBorder, MosaicImageBorder, MosaicMatrices2D, StackingOrder, “false”, TransMat2D)
threshold (MosaicImageBorder, Seams, 128, 255)
dev_clear_window ()
dev_display (MosaicImage)
set_tposition (WindowHandle1, 20, 10)
dev_set_color (“green”)
dev_display (Seams)
disp_message (WindowHandle1, “Seams between the images”, “window”, -1, -1, “black”, “true”)
dev_set_color (“blue”)
' Now, open a zoom window, showing the area around
' the seam between images 2,3,5,6.
get_image_pointer1 (MosaicImage, Pointer, Type, Width, Height)
视_设值 (PartHeight, 85)
视_设值 (PartWidth, 320)
视_设值 (PartCenterRow, 486)
视_设值 (PartCenterCol, 329)
dev_open_window (视_加 (视_除 (视_乘 (Height, 到小数 (640)), Width), 66), 0, 视_乘 (PartWidth, 2), 视_乘 (PartHeight, 2), “black”, WindowHandle2)
p_set_font (WindowHandle2)
dev_set_part (视_加 (视_减 (PartCenterRow, 视_除 (PartHeight, 2)), 1), 视_加 (视_减 (PartCenterCol, 视_除 (PartWidth, 2)), 1), 视_加 (PartCenterRow, 视_除 (PartHeight, 2)), 视_加 (PartCenterCol, 视_除 (PartWidth, 2)))
dev_display (MosaicImage)
dev_set_color (“green”)
dev_display (Seams)
disp_message (WindowHandle2, “Close-up view”, “window”, -1, -1, “black”, “true”)
dev_set_window (WindowHandle1)
get_image_size (MosaicImage, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_set_line_width (3)
' * dev_display (MosaicImage)
dev_set_draw (“margin”)
dev_set_color (“blue”)
disp_rectangle1 (WindowHandle1, 视_加 (视_减 (PartCenterRow, 视_除 (PartHeight, 2)), 1), 视_加 (视_减 (PartCenterCol, 视_除 (PartWidth, 2)), 1), 视_加 (PartCenterRow, 视_除 (PartHeight, 2)), 视_加 (PartCenterCol, 视_除 (PartWidth, 2)))
wait_seconds (6)
dev_set_line_width (1)
dev_set_window (WindowHandle2)
dev_close_window ()
dev_set_window (WindowHandle1)
dev_close_window ()
返回 ()

.子程序 p_do_grid_rectification
.局部变量 Col, tuple
.局部变量 ConnectingLines, obj
.局部变量 GridRegion, obj
.局部变量 GridSpacing, tuple
.局部变量 Image, obj
.局部变量 ImageCan, obj
.局部变量 ImageCanMapped, obj
.局部变量 ImageHeight, tuple
.局部变量 ImageMapped, obj
.局部变量 ImageReduced, obj
.局部变量 ImageWidth, tuple
.局部变量 Map, obj
.局部变量 MaxDist, tuple
.局部变量 Meshes, obj
.局部变量 MinContrast, tuple
.局部变量 NumSquares, tuple
.局部变量 Radius, tuple
.局部变量 Row, tuple
.局部变量 SaddlePoints, obj
.局部变量 SigmaConnectGridPoints, tuple
.局部变量 SigmaSaddlePoints, tuple
.局部变量 Threshold, tuple
.局部变量 WidthOfGrid, tuple
.局部变量 WindowID1, tuple
.局部变量 WindowID2, tuple
.局部变量 true, tuple

' This example illustrates how to use the operators for the grid-rectification.

' The following command creates a postscript file
' that contains the rectification grid. This grid must be
' printed. Then it must be mounted on the object surface.
视_设值 (WidthOfGrid, 0.17)
视_设值 (NumSquares, 17)

' Read the image of the object wrapped by the rectification grid
' and reopen the window with an appropriate size.
read_image (ImageCan, “can”)
get_image_size (ImageCan, ImageWidth, ImageHeight)
dev_open_window (0, 0, 640, 480, “black”, WindowID1)
dev_set_part (0, 0, 视_减 (ImageHeight, 1), 视_减 (ImageWidth, 1))
p_set_font (WindowID1)
dev_display (ImageCan)
p_write_message (WindowID1, G (-1), G (-1), G (“Rectify the surface of a can”), 真)
wait_seconds (3)

' Part 1: Determination of the image map
' The surface to be rectified is wrapped by a checkered pattern, which
' is used to determine the mapping between the distorted image and
' the rectified image. Note the orientation of the two circular marks. When
' in gen_grid_rectification_map() the parameter Rotation is 'auto', the rectified
' image is rotated such that the black mark is left of the white mark.

read_image (Image, “can_with_grid”)
dev_display (Image)
p_write_message (WindowID1, G (-1), G (-1), G (“Apply rectification grid”), 真)
wait_seconds (3)

' Determination of the region that contains the rectification grid.
视_设值 (MinContrast, 25)
视_设值 (Radius, 10)
find_rectification_grid (Image, GridRegion, MinContrast, Radius)
reduce_domain (Image, GridRegion, ImageReduced)

' Determination of the grid points.
视_设值 (SigmaSaddlePoints, 1.5)
视_设值 (Threshold, 5)
saddle_points_sub_pix (ImageReduced, “facet”, SigmaSaddlePoints, Threshold, Row, Col)
gen_cross_contour_xld (SaddlePoints, Row, Col, 6, 0.785398)

' Determination of the image map.
视_设值 (SigmaConnectGridPoints, 0.9)
视_设值 (MaxDist, 到小数 (5))
视_设值 (GridSpacing, 20)
connect_grid_points (ImageReduced, ConnectingLines, Row, Col, SigmaConnectGridPoints, MaxDist)
gen_grid_rectification_map (ImageReduced, ConnectingLines, Map, Meshes, GridSpacing, 0, Row, Col, “bilinear”)
map_image (ImageReduced, Map, ImageMapped)

p_grid_visualization_of_intermediate_results (Image, ConnectingLines, Meshes, Map, ImageMapped, SaddlePoints, WindowID1, ImageWidth, WindowID2)

' Part 2: Application of the image map
' The original surface (without the checkered pattern) is rectified
' using the previously calculated image map.

' Read in the image to be rectified.
p_write_message (WindowID1, G (-1), G (-1), G (“Original image”), 真)

' Rectification of the image using the previously calculated image map.
map_image (ImageCan, Map, ImageCanMapped)

p_grid_visualization_of_results (ImageCan, ImageCanMapped, WindowID1, WindowID2)

wait_seconds (3)
' Try to read the barcodes
' * gen_1d_bar_code_descr ('EAN 13', 13, 13, BarCodeDescr)
' * p_grid_read_and_display_1d_bar_code (ImageCanMapped, BarCodeDescr, WindowID2)
p_grid_read_and_display_1d_bar_code (ImageCanMapped, G (G ()), WindowID2)
wait_seconds (4)
dev_set_window (WindowID2)
dev_close_window ()
dev_set_window (WindowID1)
dev_close_window ()
返回 ()

.子程序 p_grid_visualization_of_intermediate_results
.参数 Image, obj
.参数 ConnectingLines, obj
.参数 Meshes, obj
.参数 Map, obj
.参数 ImageMapped, obj
.参数 SaddlePoints, obj
.参数 WindowID1, tuple
.参数 ImageWidth, tuple
.参数 WindowID2, tuple, 参考
.局部变量 Height, tuple
.局部变量 MapHeight, tuple
.局部变量 MapWidth, tuple
.局部变量 Pointer, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 true, tuple

dev_set_window (WindowID1)
dev_display (Image)
dev_set_color (“green”)
dev_display (Meshes)
p_write_message (WindowID1, G (-1), G (-1), G (“Meshes used for rectification”), 视_是否为真 (WindowID1))
wait_seconds (2)
dev_close_window ()
dev_open_window (0, 0, 320, 240, “black”, WindowID1)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowID1)
dev_display (Image)
dev_set_color (“green”)
dev_display (Meshes)
p_write_message (WindowID1, G (-1), G (-1), G (“Original grid”), 真)
get_image_size (Map, MapWidth, MapHeight)
dev_open_window (0, 334, 305, 视_除 (视_乘 (MapHeight, 到小数 (305)), MapWidth), “black”, WindowID2)
dev_set_part (0, 0, 视_减 (MapHeight, 1), 视_减 (MapWidth, 1))
p_set_font (WindowID2)
dev_display (ImageMapped)
p_write_message (WindowID2, G (-1), G (-1), G (“Rectified grid”), 真)
wait_seconds (3)
返回 ()

.子程序 p_grid_visualization_of_results
.参数 Image, obj
.参数 ImageMapped, obj
.参数 WindowID1, tuple
.参数 WindowID2, tuple
.局部变量 Height, tuple
.局部变量 Pointer, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 true, tuple

dev_set_window (WindowID1)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Image)
p_write_message (WindowID1, G (-1), G (-1), G (“Original image”), 真)
dev_set_window (WindowID2)
get_image_pointer1 (ImageMapped, Pointer, Type, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (ImageMapped)
p_write_message (WindowID2, G (-1), G (-1), G (“Rectified image”), 真)
返回 ()

.子程序 p_do_2dbarcode
.局部变量 ImageECC200, obj
.局部变量 ImagePDF417, obj
.局部变量 ImageQRCode, obj
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 WindowHandle2, tuple
.局部变量 WindowHandle3, tuple

read_image (ImageECC200, “datacode/ecc200/ecc200_disturbed_005”)
read_image (ImageQRCode, “datacode/qrcode/qr_workpiece_05”)
read_image (ImagePDF417, “datacode/pdf417/pdf417_misc_06”)

dev_open_window (0, 0, 640, 112, “black”, WindowHandle)
p_set_font (WindowHandle)
disp_message (WindowHandle, “Find and decode 2D data codes”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “ECC 200”, “window”, 70, 40, “black”, “true”)
disp_message (WindowHandle, “QR Code”, “window”, 70, 250, “black”, “true”)
disp_message (WindowHandle, “PDF417”, “window”, 70, 480, “black”, “true”)

dev_open_window (175, 0, 204, 204, “black”, WindowHandle1)
dev_set_part (116, 33, 视_加 (116, 290), 视_加 (33, 290))
dev_display (ImageECC200)

dev_open_window (175, 视_加 (204, 14), 204, 204, “black”, WindowHandle2)
dev_set_part (155, 135, 视_加 (155, 140), 视_加 (135, 140))
dev_display (ImageQRCode)

dev_open_window (175, 视_加 (408, 28), 204, 204, “black”, WindowHandle3)
dev_set_part (100, 140, 视_加 (100, 379), 视_加 (140, 410))
dev_display (ImagePDF417)

wait_seconds (4)
dev_set_window (WindowHandle)
dev_close_window ()
dev_set_window (WindowHandle3)
dev_close_window ()
dev_set_window (WindowHandle2)
dev_close_window ()
dev_set_window (WindowHandle1)
dev_close_window ()

p_do_ecc200 ()
p_do_qrcode ()
p_do_pdf417 ()

返回 ()

.子程序 p_do_match_coins
.局部变量 Angle, tuple
.局部变量 Column, tuple
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 Model, tuple
.局部变量 ModelID, tuple
.局部变量 Models, tuple
.局部变量 Names, tuple
.局部变量 NamesOrigin, tuple
.局部变量 Pointer, tuple
.局部变量 Row, tuple
.局部变量 Score, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型
.局部变量 true, tuple

' distinguishing of coins with the help of shape-based matching

clear_all_shape_models ()
read_image (Image, “coins/20cent_german”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
get_image_size (Image, Width, Height)
dev_open_window (0, 0, 640, 485, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
视_设值 (NamesOrigin, G (“Germany”, “Italy”, “Greece”, “Spain”))
视_设值 (Names, G (“german”, “italian”, “greek”, “spanish”))
视_设值 (Models, G ())
.变量循环首 (0, 3, 1, i)
    read_image (Image, 视_加 (“coins/20cent_”, 视_取元素 (Names, i)))
    dev_display (Image)
    p_write_message (WindowHandle, G (-1), G (-1), G (“Determine the regional origin of coins”), 真)
    p_write_message (WindowHandle, G (40), G (-1), G (“Train coins”), 真)
    p_coins_train_model (Image, ModelID)
    视_设值 (Models, G (Models, ModelID))
    wait_seconds (0.7)
.变量循环尾 ()
wait_seconds (1)
.变量循环首 (1, 13, 1, i)
    read_image (Image, 视_加 (视_加 (“coins/20cent_”, 视_文本格式化 (i, “.2”)), “.png”))
    p_coins_find_coin (Image, Models, Row, Column, Angle, Score, Model)
    p_coins_display_model (Image, G (视_取元素 (Models, Model)), Row, Column, Angle, NamesOrigin, WindowHandle)
    p_disp_pause_sign (WindowHandle, G (2))
    wait_seconds (0.7)
.变量循环尾 ()
wait_seconds (2)
' destroy models
.变量循环首 (0, 3, 1, i)
    clear_shape_model (视_取元素 (Models, i))
.变量循环尾 ()
dev_close_window ()
返回 ()

.子程序 p_coins_train_model
.参数 Image, obj
.参数 ModelID, tuple, 参考
.局部变量 Coin, obj
.局部变量 Contrast, tuple
.局部变量 HysteresisContrast, tuple
.局部变量 ImageReduced, obj

p_coins_locate_coin (Image, Coin)
视_设值 (Contrast, 20)
视_设值 (HysteresisContrast, G (视_除 (Contrast, 2), 视_加 (Contrast, 6), 10))
reduce_domain (Image, Coin, ImageReduced)
' Called during the test phase to see if Contrast is selected correctly
' * inspect_shape_model (ImageReduced, ModelImages, ModelRegions, 1, HysteresisContrast)
create_shape_model (ImageReduced, 0, 0, rad (360), 0, “no_pregeneration”, “ignore_local_polarity”, HysteresisContrast, 5, ModelID)
返回 ()

.子程序 p_coins_find_coin
.参数 Image, obj
.参数 Models, tuple
.参数 Row, tuple, 参考
.参数 Column, tuple, 参考
.参数 Angle, tuple, 参考
.参数 Score, tuple, 参考
.参数 Model, tuple, 参考
.局部变量 Area, tuple
.局部变量 Circle, obj
.局部变量 Coin, obj
.局部变量 ImageReduced, obj

p_coins_locate_coin (Image, Coin)
area_center (Coin, Area, Row, Column)
gen_circle (Circle, Row, Column, 35)
reduce_domain (Image, Circle, ImageReduced)
find_shape_models (ImageReduced, Models, 0, rad (360), 0.6, 1, 0, “interpolation”, 0, 1, Row, Column, Angle, Score, Model)
返回 ()

.子程序 p_coins_display_model
.参数 Image, obj
.参数 Model, tuple
.参数 Row, tuple
.参数 Column, tuple
.参数 Angle, tuple
.参数 Names, tuple
.参数 WindowHandle, tuple
.局部变量 ContoursAffinTrans, obj
.局部变量 HomMat2D, tuple
.局部变量 ModelContours, obj

get_shape_model_contours (ModelContours, Model, 1)
vector_angle_to_rigid (0, 0, 0, Row, Column, Angle, HomMat2D)
affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2D)
dev_display (Image)
dev_set_color (“green”)
dev_set_line_width (2)
dev_display (ContoursAffinTrans)
disp_message (WindowHandle, “Result of the recognition:”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, 视_加 (“Origin: ”, 视_取元素 (Names, Model)), “window”, 40, -1, “black”, “true”)
dev_set_line_width (1)
返回 ()

.子程序 p_coins_locate_coin
.参数 Image, obj
.参数 Coin, obj, 参考
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 ConnectedRegions, obj
.局部变量 Region, obj
.局部变量 RegionTrans, obj
.局部变量 Row, tuple
.局部变量 SelectedRegions, obj

threshold (Image, Region, 70, 255)
connection (Region, ConnectedRegions)
select_shape_std (ConnectedRegions, SelectedRegions, “max_area”, 0)
shape_trans (SelectedRegions, RegionTrans, “convex”)
area_center (RegionTrans, Area, Row, Column)
gen_circle (Coin, Row, Column, 120)
返回 ()

.子程序 p_do_projective_points
.局部变量 Alpha, tuple
.局部变量 Beta, tuple
.局部变量 CoCCArea, tuple
.局部变量 CoCCJunctions, tuple
.局部变量 CoRCArea, tuple
.局部变量 CoRCJunctions, tuple
.局部变量 CoRRArea, tuple
.局部变量 CoRRJunctions, tuple
.局部变量 Cols, tuple
.局部变量 ColsTrans, tuple
.局部变量 ColumnArea, tuple
.局部变量 D, tuple
.局部变量 DAlpha, tuple
.局部变量 DBeta, tuple
.局部变量 DGamma, tuple
.局部变量 Error, tuple
.局部变量 Focus, tuple
.局部变量 Gamma, tuple
.局部变量 H, tuple
.局部变量 Height, tuple
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 Iter, tuple
.局部变量 J, 整数型
.局部变量 M, tuple
.局部变量 N, tuple
.局部变量 Pointer, tuple
.局部变量 PrincipalColumn, tuple
.局部变量 PrincipalRow, tuple
.局部变量 ProjectionMatrix, tuple
.局部变量 RowArea, tuple
.局部变量 Rows, tuple
.局部变量 RowsTrans, tuple
.局部变量 T, tuple
.局部变量 TransImage, obj
.局部变量 Type, tuple
.局部变量 W, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandleBuffer, tuple
.局部变量 X, tuple
.局部变量 Y, tuple
.局部变量 Z, tuple
.局部变量 true, tuple

' This program shows how to use hom_mat3d_project and
' projective_trans_image to rotate an image in 3D.  Furthermore, it shows
' how to use projective_trans_pixel to transform pixel coordinates with a
' projective transformation.
dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)
read_image (Image, “mreut_y”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (0, 0, Width, Height, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Image)
p_set_font (WindowHandle)
p_write_message (WindowHandle, G (-1), G (-1), G (“Apply projective transformations”), 真)
' Extract the sub-pixel precise pixel-coordinates to be transformed.
points_foerstner (Image, 1, 2.5, 4, 300, 0.3, “gauss”, “true”, Rows, Cols, CoRRJunctions, CoRCJunctions, CoCCJunctions, RowArea, ColumnArea, CoRRArea, CoRCArea, CoCCArea)
wait_seconds (2)
' The transformed images will be displayed using a buffer window to create
' a smooth (i.e., flicker-free) display under both Windows and Unix.
open_window (0, 0, Width, Height, 0, “buffer”, “”, WindowHandleBuffer)
set_color (WindowHandleBuffer, “red”)
set_part (WindowHandleBuffer, 0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
视_设值 (Iter, 400)
' Set the increments for the 3D rotation angles.  Note that they are chosen such
' that their common divisor is as small as possible (0.1).  This leads to a
' sequence of images that has a maximum length before repeating itself.
视_设值 (DAlpha, 1.9)
视_设值 (DBeta, 1.7)
视_设值 (DGamma, 1.5)
' Initialize the 3D rotation angles.
视_设值 (Alpha, 到小数 (0))
视_设值 (Beta, 到小数 (0))
视_设值 (Gamma, 到小数 (0))
' Set the camera parameters of the virtual camera that looks at the plane
' of the image.
视_设值 (PrincipalRow, 视_除 (Height, 2))
视_设值 (PrincipalColumn, 视_除 (Width, 2))
视_设值 (Focus, 视_除 (视_加 (Width, Height), 2))
' Set the parameters of the torus knot on which the center of the image
' moves in 3D.
' This will generate the torus knot T(7,6).
视_设值 (M, 7)
视_设值 (N, 6)
' Set the dimensions of the torus knot.
视_设值 (H, 视_除 (Height, 到小数 (4)))
视_设值 (W, 视_除 (Width, 到小数 (4)))
视_设值 (D, 视_除 (视_加 (Width, Height), 到小数 (6)))
' Initialize the coordinates of the transformed centers of the image.
.变量循环首 (1, DD (Iter, ), 1, J)
    ' Rotate the plane in 3D.
    hom_mat3d_identity (HomMat3D)
    hom_mat3d_rotate (HomMat3D, rad (Gamma), “z”, PrincipalRow, PrincipalColumn, Focus, HomMat3D)
    hom_mat3d_rotate (HomMat3D, rad (Beta), “y”, PrincipalRow, PrincipalColumn, Focus, HomMat3D)
    hom_mat3d_rotate (HomMat3D, rad (Alpha), “x”, PrincipalRow, PrincipalColumn, Focus, HomMat3D)
    ' Translate the center of the image to a point on the torus knot.
    视_设值 (T, rad (视_除 (J, 到小数 (4))))
    视_设值 (X, 视_乘 (H, 视_加 (cos (视_乘 (N, T)), 视_乘 (视_乘 (0.5, cos (视_乘 (M, T))), cos (视_乘 (N, T))))))
    视_设值 (Y, 视_乘 (W, 视_加 (sin (视_乘 (N, T)), 视_乘 (视_乘 (0.5, cos (视_乘 (M, T))), sin (视_乘 (N, T))))))
    视_设值 (Z, 视_乘 (D, sin (视_乘 (M, T))))
    hom_mat3d_translate (HomMat3D, X, Y, Z, HomMat3D)
    ' Project the plane of the image, i.e., create a 2D projective transformation
    ' from the plane of the input image to the plane of the output image.
    hom_mat3d_project (HomMat3D, PrincipalRow, PrincipalColumn, Focus, ProjectionMatrix)
    ' Some transformations may result in a singular transformation matrix.
    ' Hence, we will need to perform error handling here.
    dev_set_check (“~give_error”)
    dev_error_var (Error, 1)
    projective_trans_image (Image, TransImage, ProjectionMatrix, “bilinear”, “false”, “false”)
    dev_error_var (Error, 0)
    dev_set_check (“give_error”)
    ' Transform the extracted points.
    projective_trans_pixel (ProjectionMatrix, Rows, Cols, RowsTrans, ColsTrans)
    .如果 (视_等于 (Error, #视_错误代码_无错误))
        ' Display the image in the buffer window and copy it to the visible window.
        clear_window (WindowHandleBuffer)
        disp_obj (TransImage, WindowHandleBuffer)
        disp_cross (WindowHandleBuffer, RowsTrans, ColsTrans, 6, rad (45))
        copy_rectangle (WindowHandleBuffer, WindowHandle, 0, 0, 视_减 (Height, 1), 视_减 (Width, 1), 0, 0)
    .否则

    .如果结束
    ' Increment the rotation angles.
    视_设值 (Alpha, fmod (视_加 (Alpha, DAlpha), 360))
    视_设值 (Beta, fmod (视_加 (Beta, DBeta), 360))
    视_设值 (Gamma, fmod (视_加 (Gamma, DGamma), 360))
.变量循环尾 ()
wait_seconds (1)
close_window (WindowHandleBuffer)
dev_set_window (WindowHandle)
dev_close_window ()
dev_update_pc (“on”)
dev_update_window (“off”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_color_lines
.局部变量 Angle, tuple
.局部变量 Col, tuple
.局部变量 EdgeL, obj
.局部变量 EdgeLC, tuple
.局部变量 EdgeLR, tuple
.局部变量 EdgeR, obj
.局部变量 EdgeRC, tuple
.局部变量 EdgeRR, tuple
.局部变量 EdgesL, obj
.局部变量 EdgesR, obj
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 K, 整数型
.局部变量 Line, obj
.局部变量 Lines, obj
.局部变量 LongLines, obj
.局部变量 Number, tuple
.局部变量 Row, tuple
.局部变量 Width, tuple
.局部变量 WidthL, tuple
.局部变量 WidthR, tuple
.局部变量 WindowHandle, tuple

' This example program shows how to use lines_color and the differences
' between the output of lines_color and lines_gauss using an image in which
' some lines can only be extracted from a color image.
read_image (Image, “cable2”)
get_image_size (Image, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
dev_display (Image)
disp_message (WindowHandle, “Extract lines in color image”, “window”, -1, -1, “black”, “true”)
wait_seconds (2)
' Extract color lines from the image.  Note that since the color line extractor
' cannot discern between bright or dark lines (in fact, this criterion does not
' even make sense for color lines), the lines corresponding to the colored
' cables are simply selected based on their length.
lines_color (Image, Lines, 3.5, 0, 12, “true”, “false”)
select_contours_xld (Lines, LongLines, “contour_length”, 450, 100000, 0, 0)
dev_clear_window ()
' * dev_display (Image)
dev_set_line_width (2)
dev_set_color (“yellow”)
dev_display (LongLines)
disp_message (WindowHandle, “Color lines”, “window”, -1, -1, “black”, “true”)
wait_seconds (2)
' Now construct XLD contours that are used to visualize the line width.  One
' contour for the left and right edge of the line is constructed based on the
' line position, angle, and width_* attributes.
' Note that when the width is visualized you will see several abruptly changing
' line widths.  This happens because the edges of the line merge with the
' edges of adjacent lines because of the scale-space effects induced by the
' smoothing that is used in lines_color to extract the lines.
count_obj (LongLines, Number)
gen_empty_obj (EdgesL)
gen_empty_obj (EdgesR)
.变量循环首 (1, DD (Number, ), 1, K)
    select_obj (LongLines, Line, K)
    get_contour_xld (Line, Row, Col)
    get_contour_attrib_xld (Line, “angle”, Angle)
    get_contour_attrib_xld (Line, “width_right”, WidthR)
    get_contour_attrib_xld (Line, “width_left”, WidthL)
    视_设值 (EdgeRR, 视_加 (Row, 视_乘 (cos (Angle), WidthR)))
    视_设值 (EdgeRC, 视_加 (Col, 视_乘 (sin (Angle), WidthR)))
    视_设值 (EdgeLR, 视_减 (Row, 视_乘 (cos (Angle), WidthL)))
    视_设值 (EdgeLC, 视_减 (Col, 视_乘 (sin (Angle), WidthL)))
    gen_contour_polygon_xld (EdgeR, EdgeRR, EdgeRC)
    gen_contour_polygon_xld (EdgeL, EdgeLR, EdgeLC)
    concat_obj (EdgesL, EdgeL, EdgesL)
    concat_obj (EdgesR, EdgeR, EdgesR)
.变量循环尾 ()
dev_display (Image)
dev_set_line_width (2)
dev_set_color (“yellow”)
dev_display (LongLines)
dev_set_color (“coral”)
dev_display (EdgesR)
dev_display (EdgesL)
disp_message (WindowHandle, “Extracted color lines”, “window”, -1, -1, “black”, “true”)
wait_seconds (4)
dev_close_window ()
dev_set_line_width (1)
返回 ()

.子程序 p_do_measure_3d
.局部变量 Alpha, tuple
.局部变量 AmplitudeFirst, tuple
.局部变量 AmplitudeSecond, tuple
.局部变量 CCS_HomMat_WCS, tuple
.局部变量 CCS_RectangleX, tuple
.局部变量 CCS_RectangleY, tuple
.局部变量 CCS_RectangleZ, tuple
.局部变量 CCoord, tuple
.局部变量 Caltab, obj
.局部变量 CaltabName, tuple
.局部变量 CamParam, tuple
.局部变量 CamParamUnchanged, tuple
.局部变量 ColCenterROI, tuple
.局部变量 ColPitchLine, tuple
.局部变量 ColumnEdgeFirst, tuple
.局部变量 ColumnEdgeSecond, tuple
.局部变量 DeltaThresh, tuple
.局部变量 Errors, tuple
.局部变量 FinalPose, tuple
.局部变量 FinalPoseFromCalibrationPlate, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 ImgPath, tuple
.局部变量 InitialPose, tuple
.局部变量 InterDistance, tuple
.局部变量 IntraDistance, tuple
.局部变量 J, 整数型
.局部变量 Length1ROI, tuple
.局部变量 Length2ROI, tuple
.局部变量 MarkThresh, tuple
.局部变量 MaxDiamMarks, tuple
.局部变量 MeasureHandle, tuple
.局部变量 MinContLength, tuple
.局部变量 MinDiamMarks, tuple
.局部变量 MinThresh, tuple
.局部变量 NCol, tuple
.局部变量 NFinalPose, tuple
.局部变量 NRow, tuple
.局部变量 NStartPose, tuple
.局部变量 NumImages, tuple
.局部变量 PhiROI, tuple
.局部变量 Pointer, tuple
.局部变量 RCoord, tuple
.局部变量 ROI, obj
.局部变量 ROI_X_WCS, tuple
.局部变量 ROI_Y_WCS, tuple
.局部变量 ROI_Z_WCS, tuple
.局部变量 RectangleCol, tuple
.局部变量 RectangleRow, tuple
.局部变量 RowCenterROI, tuple
.局部变量 RowEdgeFirst, tuple
.局部变量 RowEdgeSecond, tuple
.局部变量 RowPitchLine, tuple
.局部变量 SizeGauss, tuple
.局部变量 StartCamPar, tuple
.局部变量 StartPose, tuple
.局部变量 StartThresh, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 X, tuple
.局部变量 X1, tuple
.局部变量 Y, tuple
.局部变量 Y1, tuple
.局部变量 Z, tuple

视_设值 (ImgPath, “3d_machine_vision/calib/”)
read_image (Image, 视_加 (ImgPath, “calib_01”))
dev_open_window (0, 0, 640, 485, “black”, WindowHandle)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
dev_update_pc (“off”)
dev_update_window (“off”)
dev_update_var (“off”)
dev_set_draw (“margin”)
dev_set_line_width (3)

' Calibrate the camera.

视_设值 (CaltabName, “caltab_30mm.descr”)
视_设值 (StartCamPar, G (0.016, 0, 7.4e-006, 7.4e-006, 326, 247, 652, 494))
视_设值 (NStartPose, G ())
视_设值 (NRow, G ())
视_设值 (NCol, G ())
caltab_points (CaltabName, X, Y, Z)
视_设值 (NumImages, 10)
' parameter settings for find_caltab and find_marks_and_pose
视_设值 (SizeGauss, 3)
视_设值 (MarkThresh, 200)
视_设值 (MinDiamMarks, 10)
视_设值 (StartThresh, 128)
视_设值 (DeltaThresh, 10)
视_设值 (MinThresh, 18)
视_设值 (Alpha, 0.9)
视_设值 (MinContLength, 15)
视_设值 (MaxDiamMarks, 100)
' Note, we do not use the image from which the pose of the measurement plane can be derived
.变量循环首 (1, DD (NumImages, ), 1, I)
    read_image (Image, 视_加 (视_加 (ImgPath, “calib_”), 视_文本格式化 (I, “02d”)))
    find_caltab (Image, Caltab, CaltabName, SizeGauss, MarkThresh, MinDiamMarks)
    find_marks_and_pose (Image, Caltab, CaltabName, StartCamPar, StartThresh, DeltaThresh, MinThresh, Alpha, MinContLength, MaxDiamMarks, RCoord, CCoord, StartPose)
    dev_display (Image)
    dev_set_color (“green”)
    dev_display (Caltab)
    dev_set_color (“yellow”)
    disp_circle (WindowHandle, RCoord, CCoord, gen_tuple_const (视_取元素总数 (RCoord), 1.5))
    disp_message (WindowHandle, G (“Perform measurements in 3D world coordinates”, “by using camera calibration”), “window”, -1, -1, “black”, “true”)
    disp_message (WindowHandle, 视_加 (“Calibration image ”, I), “window”, 80, -1, “black”, “true”)
    视_设值 (NStartPose, G (NStartPose, StartPose))
    视_设值 (NRow, G (NRow, RCoord))
    视_设值 (NCol, G (NCol, CCoord))
    wait_seconds (0.1)
.变量循环尾 ()
camera_calibration (X, Y, Z, NRow, NCol, StartCamPar, NStartPose, “all”, CamParam, NFinalPose, Errors)
wait_seconds (1)

' Determine the exterior camera parameters and world coodinates from image points

' The exterior camera parameters can be determined from an image, where the
' calibration plate is positioned directly on the measurement plane
read_image (Image, 视_加 (ImgPath, “calib_11”))
dev_display (Image)
disp_message (WindowHandle, G (“Perform measurements in 3D world coordinates”, “by using camera calibration”), “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Image defining the reference plane”, “window”, 80, -1, “black”, “true”)
wait_seconds (2)
' parameter settings for find_caltab and find_marks_and_pose
find_caltab (Image, Caltab, CaltabName, SizeGauss, MarkThresh, MinDiamMarks)
' Here, the final camera parameters are already known and can be used instead of the starting values
find_marks_and_pose (Image, Caltab, CaltabName, CamParam, StartThresh, DeltaThresh, MinThresh, Alpha, MinContLength, MaxDiamMarks, RCoord, CCoord, FinalPoseFromCalibrationPlate)
dev_set_color (“red”)
' * disp_circle (WindowHandle, RCoord, CCoord, gen_tuple_const(|RCoord|,1.5))
caltab_points (CaltabName, X, Y, Z)
' To take the thickness of the calibration plate into account, the z-value
' of the origin given by the camera pose has to be translated by the
' thickness of the calibration plate.
' Deactivate the following line if you do not want to add the correction.
set_origin_pose (FinalPoseFromCalibrationPlate, 0, 0, 0.00075, FinalPoseFromCalibrationPlate)
' Alternatively, the exterior camera parameters can  be determined from
' at least three point correspondances between the WCS and the pixel coordinate system
read_image (Image, 视_加 (ImgPath, “caliper_01”))
dev_display (Image)
' Set the world coordinates system using three points on the rule
视_设值 (X, G (0, 50, 100))
视_设值 (Y, G (5, 0, 5))
视_设值 (Z, G (0, 0, 0))
' Set the respective image plane coordinates of the three points
视_设值 (RCoord, G (414, 227, 85))
视_设值 (CCoord, G (119, 318, 550))
create_pose (-50, 25, 400, 0, 0, -30, “Rp+T”, “gba”, “point”, InitialPose)
camera_calibration (X, Y, Z, RCoord, CCoord, CamParam, InitialPose, “pose”, CamParamUnchanged, FinalPose, Errors)
disp_message (WindowHandle, “Measure the position of the pitch lines”, “window”, -1, -1, “black”, “true”)
wait_seconds (3)
' Apply the measure tool and transform the resulting point coordinates
' into the WCS
' Set the world coordinates of four points defining a ROI for the measure tool
视_设值 (ROI_X_WCS, G (-2, -2, 112, 112))
视_设值 (ROI_Y_WCS, G (0, 0.5, 0.5, 0))
视_设值 (ROI_Z_WCS, G (0, 0, 0, 0))
' Determine the transformation matrix from the WCS into the CCS
pose_to_hom_mat3d (FinalPose, CCS_HomMat_WCS)
' Transform the point coordintes into the image coordinate system
affine_trans_point_3d (CCS_HomMat_WCS, ROI_X_WCS, ROI_Y_WCS, ROI_Z_WCS, CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ)
project_3d_point (CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ, CamParamUnchanged, RectangleRow, RectangleCol)
gen_region_polygon_filled (ROI, RectangleRow, RectangleCol)
smallest_rectangle2 (ROI, RowCenterROI, ColCenterROI, PhiROI, Length1ROI, Length2ROI)
' Create a measure
gen_measure_rectangle2 (RowCenterROI, ColCenterROI, PhiROI, Length1ROI, Length2ROI, 652, 494, “bilinear”, MeasureHandle)
measure_pairs (Image, MeasureHandle, 0.4, 5, “all_strongest”, “all”, RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)
close_measure (MeasureHandle)
dev_display (Image)
dev_set_line_width (3)
dev_set_color (“blue”)
视_设值 (RowPitchLine, 视_除 (视_加 (RowEdgeFirst, RowEdgeSecond), 到小数 (2)))
视_设值 (ColPitchLine, 视_除 (视_加 (ColumnEdgeFirst, ColumnEdgeSecond), 到小数 (2)))
disp_cross (WindowHandle, RowPitchLine, ColPitchLine, 8, 0)
image_points_to_world_plane (CamParam, FinalPose, RowPitchLine, ColPitchLine, 1, X1, Y1)
.变量循环首 (1, DD (视_取元素总数 (X1), ), 1, J)
    .如果 (视_大于 (J, 视_减 (视_取元素总数 (X1), 2)))
        disp_message (WindowHandle, 视_加 (视_文本格式化 (视_取元素 (X1, 视_减 (J, 1)), “.2f”), “mm”), “window”, 视_加 (视_取元素 (RowEdgeFirst, 视_减 (J, 1)), 10), 视_减 (视_取元素 (ColumnEdgeFirst, 视_减 (J, 1)), 170), “black”, “true”)
        dev_set_line_width (1)
        dev_set_color (“yellow”)
        disp_line (WindowHandle, 视_取元素 (RowPitchLine, 视_减 (J, 1)), 视_取元素 (ColPitchLine, 视_减 (J, 1)), 视_加 (视_取元素 (RowEdgeFirst, 视_减 (J, 1)), 15), 视_减 (视_取元素 (ColumnEdgeFirst, 视_减 (J, 1)), 52))
    .否则
        disp_message (WindowHandle, 视_加 (视_文本格式化 (视_取元素 (X1, 视_减 (J, 1)), “.2f”), “mm”), “window”, 视_加 (视_取元素 (RowEdgeFirst, 视_减 (J, 1)), 50), 视_加 (视_取元素 (ColumnEdgeFirst, 视_减 (J, 1)), 30), “black”, “true”)
        dev_set_line_width (1)
        dev_set_color (“yellow”)
        disp_line (WindowHandle, 视_取元素 (RowPitchLine, 视_减 (J, 1)), 视_取元素 (ColPitchLine, 视_减 (J, 1)), 视_加 (视_取元素 (RowEdgeFirst, 视_减 (J, 1)), 50.5), 视_加 (视_取元素 (ColumnEdgeFirst, 视_减 (J, 1)), 50.5))
    .如果结束

.变量循环尾 ()
disp_message (WindowHandle, “Measure the position of the pitch lines”, “window”, -1, -1, “black”, “true”)
wait_seconds (5)
dev_close_window ()
dev_set_line_width (1)
dev_update_pc (“on”)
dev_update_window (“off”)
dev_update_var (“on”)
返回 ()

.子程序 p_grid_read_and_display_1d_bar_code
.参数 Image, obj
.参数 BarCodeDescr, tuple
.参数 Window, tuple
.局部变量 BarCodeHandle, tuple
.局部变量 BarcodeFound, tuple
.局部变量 CodeRegion, obj
.局部变量 DecodedDataStrings, tuple

create_bar_code_model (G (), G (), BarCodeHandle)
set_bar_code_param (BarCodeHandle, “element_size_min”, 1.5)
find_bar_code (Image, CodeRegion, BarCodeHandle, “EAN-13”, DecodedDataStrings)
视_设值 (BarcodeFound, 视_大于 (视_取元素总数 (DecodedDataStrings), 0))
clear_bar_code_model (BarCodeHandle)
dev_set_line_width (2)
dev_set_draw (“margin”)
dev_set_color (“yellow”)
dev_display (CodeRegion)
.如果 (视_等于 (BarcodeFound, 1))
    disp_message (Window, G (“Bar code: ”, DecodedDataStrings), “window”, 40, -1, “black”, “true”)
.否则
    disp_message (Window, “No bar code found.”, “window”, 40, -1, “black”, “true”)
.如果结束
dev_set_draw (“fill”)
dev_set_line_width (2)
返回 ()

.子程序 p_do_ecc200
.局部变量 AllCandidates, obj
.局部变量 AllStatus, tuple
.局部变量 CandNum, tuple
.局部变量 Contrast, tuple
.局部变量 DataCodeHandle, tuple
.局部变量 DecodedDataStrings, tuple
.局部变量 DecodingError, tuple
.局部变量 FileNames, tuple
.局部变量 GenParamNames, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 K, 整数型
.局部变量 Mirrored, tuple
.局部变量 ModuleHeight, tuple
.局部变量 ModuleWidth, tuple
.局部变量 Numbers, tuple
.局部变量 Passes, tuple
.局部变量 Paths, tuple
.局部变量 Polarity, tuple
.局部变量 ResultHandles, tuple
.局部变量 ResultNum, tuple
.局部变量 ResultObjectNames, tuple
.局部变量 ResultParamNames, tuple
.局部变量 SL, tuple
.局部变量 Sequence, tuple
.局部变量 Slant, tuple
.局部变量 SymbolCols, tuple
.局部变量 SymbolRows, tuple
.局部变量 SymbolXLD, obj
.局部变量 SymbolXLDs, obj
.局部变量 T1, tuple
.局部变量 T2, tuple
.局部变量 THeight, tuple
.局部变量 TPosCol, tuple
.局部变量 TPosRow, tuple
.局部变量 TWidth, tuple
.局部变量 Time, tuple
.局部变量 UndecNum, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple

' *****************************************************************************
' Example programm for demonstrating the 2d data code operators.
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (ECC 200, data matrix).
' This program uses the model without any adaptions, tuning, or
' symbol specific modifications.
' Only the opportunity to switch the complete set of model
' parameters from the standard to the enhanced settings is
' demonstrated.
' Searching the symbols with the standard setting is faster,
' especially, if no readable symbol is found.  On the other hand,
' there are a number of restrictions concerning the symbol size,
' the module size, the polarity, and the minimum contrast, that
' prevent a number of symbols from being detected.

' Number of image files contained in the sequence
视_设值 (Paths, G (“datacode/ecc200/ecc200_disturbed_”, “datacode/ecc200/ecc200_cpu_”))
tuple_gen_sequence (1, 20, 1, Sequence)
视_设值 (Numbers, 视_文本格式化 (Sequence, “.03”))
视_设值 (FileNames, 视_加 (视_取元素 (Paths, 0), 视_取元素范围 (Numbers, 0, 16)))
视_设值 (FileNames, G (FileNames, 视_加 (视_取元素 (Paths, 1), Numbers)))

' The first two images in the array are specially illustrative of
' the difficulty of the task at hand, therefore there will be shown
' in more detail
视_设值 (FileNames, G (视_取元素 (FileNames, 12), 视_取元素 (FileNames, 19), FileNames))

read_image (Image, 视_取元素 (FileNames, 2))
get_image_size (Image, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' You can choose between two default parameter settings:
' the standard and an enhanced one.
' --------------------------------------------------
' --------   ATTENTION !!!   --------
' --------------------------------------------------
' Please recognize that there are symbols that cannot be found with the
' standard default parameters.
' The reasons for that are:
' + the contrast is too low
' + some symbols are printed light on dark, which is not covered by
' the standard model
' + the symbols are too big (>48x48 modules)
' + the modules are printed as small unconnected dots
' Changing the default parameter set to 'enhanced recognition' enables
' HALCON to find most of the symbols that couldn't be detected before.
' The price for the improved recognition rate is an increasing runtime,
' especially when no datacode symbols are found.
' --------------------------------------------------

create_data_code_2d_model (“Data Matrix ECC 200”, G (), G (), DataCodeHandle)

' by (un)commenting the appropriate command line one can
' switch between standard and enhanced mode
' The standard mode is the default!

set_data_code_2d_param (DataCodeHandle, “default_parameters”, “enhanced_recognition”)

' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.

query_data_code_2d_params (DataCodeHandle, “get_model_params”, GenParamNames)
query_data_code_2d_params (DataCodeHandle, “get_result_params”, ResultParamNames)
query_data_code_2d_params (DataCodeHandle, “get_result_objects”, ResultObjectNames)


.变量循环首 (0, DD (视_减 (视_取元素总数 (FileNames), 1), ), 1, I)

    ' read the next image
    read_image (Image, 视_取元素 (FileNames, I))


    ' in the sequence 'datacode/ecc200/ecc200_cpu_007', ..., there is inversion of polarity
    .如果 (视_且 (视_大于 (I, 24), 视_小于 (I, 35)))
        set_data_code_2d_param (DataCodeHandle, “polarity”, “light_on_dark”)
    .否则
        set_data_code_2d_param (DataCodeHandle, “polarity”, “dark_on_light”)
    .如果结束


    ' look for the 2d data code symbols
    ' - stop after finding the expected number of symbols (or after the last search pass)
    ' - measure the run time of find_data_code_2d

    dev_update_var (“off”)
    count_seconds (T1)
    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, G (), G (), ResultHandles, DecodedDataStrings)
    count_seconds (T2)
    dev_update_var (“on”)
    视_设值 (Time, 视_乘 (1000, 视_减 (T2, T1)))

    ' get some interesting information about the search in general

    get_data_code_2d_results (DataCodeHandle, “general”, “result_num”, ResultNum)
    get_data_code_2d_results (DataCodeHandle, “general”, “candidate_num”, CandNum)
    get_data_code_2d_results (DataCodeHandle, “general”, “pass_num”, Passes)
    get_data_code_2d_results (DataCodeHandle, “general”, “undecoded_num”, UndecNum)
    get_data_code_2d_results (DataCodeHandle, “general”, G (“search_level”, “min_search_level”, “max_search_level”), SL)

    ' get some interesting information about all succesfully detected symbols

    get_data_code_2d_results (DataCodeHandle, “all_results”, “symbol_rows”, SymbolRows)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “symbol_cols”, SymbolCols)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_height”, ModuleHeight)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_width”, ModuleWidth)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “mirrored”, Mirrored)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “contrast”, Contrast)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “decoding_error”, DecodingError)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “slant”, Slant)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “polarity”, Polarity)

    ' get some information about all investigated symbol candidates in order to get a first
    ' hint why a symbol could not be read

    get_data_code_2d_results (DataCodeHandle, “all_candidates”, “status”, AllStatus)
    get_data_code_2d_objects (AllCandidates, DataCodeHandle, “all_candidates”, “candidate_xld”)

    ' display some of the general information (runtime, number of found symbols and passes)
    ' and display all candidates that were investigated (red) and the decoded symbols (green)

    dev_display (Image)
    disp_message (WindowHandle, 视_加 (视_加 (“ECC 200 found and decoded in ”, 视_文本格式化 (Time, “.1f”)), “ ms”), “window”, -1, -1, “black”, “true”)
    dev_set_color (“green”)
    dev_set_line_width (3)
    dev_display (SymbolXLDs)
    dev_set_line_width (1)

    ' for all symbols display the encoded data string and some
    ' info about the symbol and the reading process

    .变量循环首 (0, DD (视_减 (视_取元素总数 (ResultHandles), 1), ), 1, K)
        select_obj (SymbolXLDs, SymbolXLD, 视_加 (K, 1))
        dev_set_window (WindowHandle)
        dev_set_color (“coral”)
        p_datacode_result_pos (SymbolXLD, G (视_乘 (1.7, TWidth)), THeight, G (7), Width, Height, TPosRow, TPosCol)
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (0), TWidth, THeight, G (“symbol:”), G (视_加 (视_加 (视_取元素 (SymbolRows, K), “x”), 视_取元素 (SymbolCols, K))))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (1), TWidth, THeight, G (“modules:”), G (视_加 (视_加 (视_文本格式化 (视_取元素 (ModuleHeight, K), “.1f”), “x”), 视_文本格式化 (视_取元素 (ModuleWidth, K), “.1f”))))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (2), TWidth, THeight, G (“mirrored:”), G (视_取元素 (Mirrored, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (3), TWidth, THeight, G (“contrast:”), G (视_取元素 (Contrast, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (4), TWidth, THeight, G (“decode-err:”), G (视_取元素 (DecodingError, K)))
        dev_set_color (“green”)
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (6), TWidth, THeight, G (“result:”), G (视_取元素 (DecodedDataStrings, K)))
    .变量循环尾 ()

    ' make a pause when displaying results on the two illustrative images
    .如果 (视_小于等于 (I, 1))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (4)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (2)

' cleanup: close the 2d data code model

clear_data_code_2d_model (DataCodeHandle)
dev_set_window (WindowHandle)
dev_close_window ()

dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_qrcode
.局部变量 AllCandidates, obj
.局部变量 AllStatus, tuple
.局部变量 CandNum, tuple
.局部变量 Contrast, tuple
.局部变量 DataCodeHandle, tuple
.局部变量 DecodedDataStrings, tuple
.局部变量 DecodingError, tuple
.局部变量 ErrorCorrectionLevel, tuple
.局部变量 FileNames, tuple
.局部变量 GenParamNames, tuple
.局部变量 GenParamValues, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 K, 整数型
.局部变量 MaskPattern, tuple
.局部变量 Mirrored, tuple
.局部变量 ModelType, tuple
.局部变量 ModuleHeight, tuple
.局部变量 ModuleWidth, tuple
.局部变量 Numbers, tuple
.局部变量 Passes, tuple
.局部变量 Paths, tuple
.局部变量 Pointer, tuple
.局部变量 Polarity, tuple
.局部变量 ResultHandles, tuple
.局部变量 ResultNum, tuple
.局部变量 ResultObjectNames, tuple
.局部变量 ResultParamNames, tuple
.局部变量 SL, tuple
.局部变量 Sequence, tuple
.局部变量 SymbolXLD, obj
.局部变量 SymbolXLDs, obj
.局部变量 T1, tuple
.局部变量 T2, tuple
.局部变量 THeight, tuple
.局部变量 TPosCol, tuple
.局部变量 TPosRow, tuple
.局部变量 TWidth, tuple
.局部变量 Time, tuple
.局部变量 Type, tuple
.局部变量 UndecNum, tuple
.局部变量 Version, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 true, tuple


' *****************************************************************************
' Example programm for demonstrating the 2d data code operators.
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (QR code).
' This program uses the model without any adaptions, tuning, or
' symbol specific modifications.
' Only the opportunity to switch the complete set of model
' parameters from the standard to the enhanced settings is
' demonstrated.
' Searching the symbols with the standard setting is faster,
' especially, if no readable symbol is found.  On the other hand,
' there are a number of restrictions concerning the symbol size,
' the module size, the polarity, and the minimum contrast, that
' prevent a number of symbols from being detected.

' The first two images in the array are specially illustrative of
' the difficulty of the task at hand, therefore there will be shown
' in more detail
视_设值 (Paths, G (“datacode/qrcode/qr_workpiece_”))
tuple_gen_sequence (1, 9, 1, Sequence)
视_设值 (Numbers, 视_文本格式化 (Sequence, “.02”))
视_设值 (FileNames, 视_加 (视_取元素 (Paths, 0), Numbers))
视_设值 (FileNames, G (视_取元素 (FileNames, 0), 视_取元素 (FileNames, 8), FileNames, 视_取元素范围 (FileNames, 0, 5)))


read_image (Image, 视_取元素 (FileNames, 0))
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.
' For the model, you can choose between two default parameter settings:
' the standard and an enhanced one.  The standard mode is the default
' mode that is choosen if no parameter setting is explicitely specified.
' --------------------------------------------------
' --------   ATTENTION !!!   --------
' --------------------------------------------------
' Please recognize that there are symbols that cannot be found with the
' standard default parameters.
' The reasons for that are:
' + the contrast is too low
' + some symbols are printed light on dark, which is not covered by
' the standard model
' + the symbols are too big (>version 15 = >71x71 modules)
' + the modules are printed as small unconnected dots
' Changing the default parameter set to 'enhanced recognition' enables
' HALCON to find most ofl the symbols that couldn't be detected before.
' The price for the improved recognition rate is an increasing runtime,
' especially if no datacode symbols are found.
' --------------------------------------------------

create_data_code_2d_model (“QR Code”, G (), G (), DataCodeHandle)

' by (un)commenting the appropriate command line one can
' switch between standard and enhanced mode
' After the model creation the standard mode is the default!

set_data_code_2d_param (DataCodeHandle, “default_parameters”, “enhanced_recognition”)

' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.

query_data_code_2d_params (DataCodeHandle, “get_model_params”, GenParamNames)
query_data_code_2d_params (DataCodeHandle, “get_result_params”, ResultParamNames)
query_data_code_2d_params (DataCodeHandle, “get_result_objects”, ResultObjectNames)

' within a loop:
' + read the next image from the image sequence file
' + try to recognise the data code symbol(s)
' + for every image display the recognized symbol, the decoded string,
' and some data about the symbol and the search process

.变量循环首 (0, DD (视_减 (视_取元素总数 (FileNames), 1), ), 1, I)

    ' read the next image
    read_image (Image, 视_取元素 (FileNames, I))


    ' re-read the current settings of the model
    get_data_code_2d_param (DataCodeHandle, GenParamNames, GenParamValues)

    ' look for the 2d data code symbols
    ' - stop after finding the expected number of symbols (or after the last search pass)
    ' - measure the run time of find_data_code_2d

    dev_update_var (“off”)
    count_seconds (T1)
    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, G (), G (), ResultHandles, DecodedDataStrings)
    count_seconds (T2)
    dev_update_var (“on”)
    视_设值 (Time, 视_乘 (1000, 视_减 (T2, T1)))

    ' get some interesting information about the search in general

    get_data_code_2d_results (DataCodeHandle, “general”, “result_num”, ResultNum)
    get_data_code_2d_results (DataCodeHandle, “general”, “candidate_num”, CandNum)
    get_data_code_2d_results (DataCodeHandle, “general”, “pass_num”, Passes)
    get_data_code_2d_results (DataCodeHandle, “general”, “undecoded_num”, UndecNum)
    get_data_code_2d_results (DataCodeHandle, “general”, G (“search_level”, “min_search_level”, “max_search_level”), SL)

    ' get some interesting information about all succesfully detected symbols

    get_data_code_2d_results (DataCodeHandle, “all_results”, “model_type”, ModelType)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “version”, Version)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_height”, ModuleHeight)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_width”, ModuleWidth)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “mirrored”, Mirrored)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “contrast”, Contrast)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “decoding_error”, DecodingError)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “mask_pattern_ref”, MaskPattern)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “error_correction_level”, ErrorCorrectionLevel)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “polarity”, Polarity)

    ' get some information about all investigated symbol candidates in order to get a first
    ' hint why a symbol could not be read

    get_data_code_2d_results (DataCodeHandle, “all_candidates”, “status”, AllStatus)
    get_data_code_2d_objects (AllCandidates, DataCodeHandle, “all_candidates”, “candidate_xld”)

    ' display some of the general information (runtime, number of found symbols and passes)
    ' and display all candidates that were investigated (red) and the decoded symbols (green)

    dev_display (Image)
    p_write_message (WindowHandle, G (-1), G (-1), G (视_加 (视_加 (“QR Code found and decoded in ”, 视_文本格式化 (Time, “.1f”)), “ ms”)), 真)
    dev_set_color (“green”)
    dev_set_line_width (3)
    dev_display (SymbolXLDs)
    dev_set_line_width (1)

    ' for all symbols display the encoded data string and some
    ' info about the symbol and the reading process

    .变量循环首 (0, DD (视_减 (视_取元素总数 (ResultHandles), 1), ), 1, K)
        select_obj (SymbolXLDs, SymbolXLD, 视_加 (K, 1))
        dev_set_window (WindowHandle)
        dev_set_color (“coral”)
        p_datacode_result_pos (SymbolXLD, G (视_乘 (1.7, TWidth)), THeight, G (10), Width, Height, TPosRow, TPosCol)
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (0), TWidth, THeight, G (“model type:”), G (视_取元素 (ModelType, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (1), TWidth, THeight, G (“version:”), G (视_加 (视_加 (视_加 (视_加 (视_加 (视_取元素 (Version, K), “  (”), 视_加 (视_乘 (视_取元素 (Version, K), 4), 17)), “x”), 视_加 (视_乘 (视_取元素 (Version, K), 4), 17)), “)”)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (2), TWidth, THeight, G (“modules:”), G (视_加 (视_加 (视_文本格式化 (视_取元素 (ModuleHeight, K), “.1f”), “x”), 视_文本格式化 (视_取元素 (ModuleWidth, K), “.1f”))))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (3), TWidth, THeight, G (“mirrored:”), G (视_取元素 (Mirrored, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (4), TWidth, THeight, G (“contrast:”), G (视_取元素 (Contrast, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (5), TWidth, THeight, G (“decod.err:”), G (视_取元素 (DecodingError, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (6), TWidth, THeight, G (“mask pattern:”), G (视_取元素 (MaskPattern, K)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (7), TWidth, THeight, G (“err-corr-level:”), G (视_取元素 (ErrorCorrectionLevel, K)))
        dev_set_color (“green”)
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (9), TWidth, THeight, G (“result:”), G (视_取元素 (DecodedDataStrings, K)))
    .变量循环尾 ()

    .如果 (视_小于等于 (I, 1))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (4)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (2)

' cleanup: close the 2d data code model

clear_data_code_2d_model (DataCodeHandle)
dev_set_window (WindowHandle)
dev_close_window ()

返回 ()

.子程序 p_datacode_write_result
.参数 WindowHandle, tuple
.参数 Row, tuple
.参数 Col, tuple
.参数 Number, tuple
.参数 Width, tuple
.参数 Height, tuple
.参数 Name, tuple
.参数 Value, tuple


set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Number, Height)), Col)
write_string (WindowHandle, Name)
set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Number, Height)), 视_加 (Col, Width))
write_string (WindowHandle, Value)

返回 ()

.子程序 p_datacode_result_pos
.参数 DataCode, obj
.参数 TWidth, tuple
.参数 THeight, tuple
.参数 Num, tuple
.参数 Width, tuple
.参数 Height, tuple
.参数 PosRow, tuple, 参考
.参数 PosCol, tuple, 参考
.局部变量 Col, tuple
.局部变量 Cut, tuple
.局部变量 Max, tuple
.局部变量 Row, tuple

get_contour_xld (DataCode, Row, Col)
视_设值 (PosRow, mean (Row))
视_设值 (PosCol, mean (Col))
视_设值 (Max, 视_除 (视_乘 (视_乘 (－DD (Num, ), THeight), TWidth), 2))
' Above
视_设值 (Cut, min (G (视_乘 (视_减 (min (Row), 视_乘 (Num, THeight)), TWidth), 视_乘 (视_减 (Width, 视_加 (min (Col), TWidth)), THeight))))
.如果 (视_大于 (Cut, Max))
    视_设值 (PosRow, 视_减 (min (Row), 视_乘 (Num, THeight)))
    视_设值 (PosCol, min (Col))
    视_设值 (Max, Cut)
.否则

.如果结束
' Below
视_设值 (Cut, min (G (视_乘 (视_减 (Height, 视_加 (max (Row), 视_乘 (Num, THeight))), TWidth), 视_乘 (视_减 (Width, 视_加 (min (Col), TWidth)), THeight))))
.如果 (视_大于 (Cut, Max))
    视_设值 (PosRow, max (Row))
    视_设值 (PosCol, min (Col))
    视_设值 (Max, Cut)
.否则

.如果结束
' Left
视_设值 (Cut, min (G (视_乘 (视_乘 (视_减 (min (Col), TWidth), Num), THeight), 视_乘 (视_减 (Height, 视_加 (min (Row), 视_乘 (Num, THeight))), TWidth))))
.如果 (视_大于 (Cut, Max))
    视_设值 (PosRow, min (Row))
    视_设值 (PosCol, 视_减 (min (Col), TWidth))
    视_设值 (Max, Cut)
.否则

.如果结束
' Right
视_设值 (Cut, min (G (视_乘 (视_乘 (视_减 (Width, 视_加 (max (Col), TWidth)), Num), THeight), 视_乘 (视_减 (Height, 视_加 (min (Row), 视_乘 (Num, THeight))), TWidth))))
.如果 (视_大于 (Cut, Max))
    视_设值 (PosRow, min (Row))
    视_设值 (PosCol, max (Col))
    视_设值 (Max, Cut)
.否则

.如果结束
返回 ()

.子程序 p_disp_pause_sign
.参数 WindowHandle, tuple
.参数 Position, tuple
.局部变量 Ascent, tuple
.局部变量 C1, tuple
.局部变量 C1_S, tuple
.局部变量 C2, tuple
.局部变量 C2_S, tuple
.局部变量 Column, tuple
.局部变量 Column1Part, tuple
.局部变量 Column2Part, tuple
.局部变量 ColumnWin, tuple
.局部变量 Descent, tuple
.局部变量 DrawMode, tuple
.局部变量 FactorColumn, tuple
.局部变量 FactorRow, tuple
.局部变量 Height, tuple
.局部变量 HeightWin, tuple
.局部变量 OS, tuple
.局部变量 R1, tuple
.局部变量 R1_S, tuple
.局部变量 R2, tuple
.局部变量 R2_S, tuple
.局部变量 Row, tuple
.局部变量 Row1Part, tuple
.局部变量 Row2Part, tuple
.局部变量 RowWin, tuple
.局部变量 String, tuple
.局部变量 Width, tuple
.局部变量 WidthWin, tuple

get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)
get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)
get_system (“operating_system”, OS)
.如果 (视_等于 (视_取文本范围 (OS, 0, 2), “Win”))
    set_font (WindowHandle, “-Courier New-12-*-*-*-*-1-”)
.否则
    set_font (WindowHandle, “-adobe-courier-bold-r-normal--14-*-*-*-*-*-*-*”)
.如果结束
视_设值 (String, “ slow motion ”)
get_string_extents (WindowHandle, String, Ascent, Descent, Width, Height)
视_设值 (Row, 12)
视_设值 (Column, 视_减 (视_减 (WidthWin, 12), Width))
' Adapt Height for different font sizes!
视_设值 (Height, 15)
' Adapt text position and extents because of image zooming
视_设值 (FactorRow, 视_除 (视_乘 (到小数 (1), 视_加 (视_减 (Row2Part, Row1Part), 1)), HeightWin))
视_设值 (FactorColumn, 视_除 (视_乘 (到小数 (1), 视_加 (视_减 (Column2Part, Column1Part), 1)), WidthWin))
get_draw (WindowHandle, DrawMode)
dev_set_draw (“fill”)
dev_set_color (“light gray”)
视_设值 (R1_S, 视_加 (视_加 (视_乘 (视_加 (Row, 3), FactorRow), 0.5), Row1Part))
视_设值 (C1_S, 视_加 (视_加 (视_乘 (视_加 (Column, 3), FactorColumn), 0.5), Column1Part))
视_设值 (R2_S, 视_加 (视_加 (视_乘 (视_减 (视_加 (视_加 (Row, 3), Height), 1), FactorRow), 0.5), Row1Part))
视_设值 (C2_S, 视_加 (视_加 (视_乘 (视_减 (视_加 (视_加 (Column, 3), Width), 1), FactorColumn), 0.5), Column1Part))
disp_rectangle1 (WindowHandle, R1_S, C1_S, R2_S, C2_S)
set_rgb (WindowHandle, 245, 214, 27)
视_设值 (R1, 视_加 (视_加 (视_乘 (Row, FactorRow), 0.5), Row1Part))
视_设值 (C1, 视_加 (视_加 (视_乘 (Column, FactorColumn), 0.5), Column1Part))
视_设值 (R2, 视_加 (视_加 (视_乘 (视_减 (视_加 (Row, Height), 1), FactorRow), 0.5), Row1Part))
视_设值 (C2, 视_加 (视_加 (视_乘 (视_减 (视_加 (Column, Width), 1), FactorColumn), 0.5), Column1Part))
disp_rectangle1 (WindowHandle, R1, C1, R2, C2)
dev_set_color (“black”)
set_tposition (WindowHandle, R1, C1)
dev_set_color (“black”)
write_string (WindowHandle, String)
dev_set_draw (DrawMode)
p_set_font (WindowHandle)
返回 ()

.子程序 p_show_intro
.局部变量 Height, tuple
.局部变量 Path, tuple
.局部变量 Pointer, tuple
.局部变量 Slide, obj
.局部变量 TimeToWait, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型

dev_close_window ()
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_window (WindowHandle)
dev_update_window (“off”)

视_设值 (Path, “explore_10/”)
视_设值 (TimeToWait, G (2, 8, 6, 10, 12, 12, 8))
.变量循环首 (1, 7, 1, i)
    read_image (Slide, 视_加 (视_加 (视_加 (Path, “explore_halcon_”), 视_文本格式化 (i, “.2”)), “_start”))
    get_image_pointer1 (Slide, Pointer, Type, Width, Height)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    dev_display (Slide)
    wait_seconds (0.1)
    read_image (Slide, 视_加 (视_加 (Path, “explore_halcon_”), 视_文本格式化 (i, “.2”)))
    dev_display (Slide)
    p_wait_mouse_click (WindowHandle, G (452), G (379), G (470), G (419), G (视_取元素 (TimeToWait, 视_减 (i, 1))))
.变量循环尾 ()

dev_close_window ()

返回 ()

.子程序 p_show_end
.局部变量 Height, tuple
.局部变量 Path, tuple
.局部变量 Pointer, tuple
.局部变量 Slide, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型

dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_window (WindowHandle)
dev_update_window (“off”)

视_设值 (Path, “explore_10/”)
.变量循环首 (1, 6, 1, i)
    read_image (Slide, 视_加 (视_加 (Path, “explore_halcon_more_”), 视_文本格式化 (i, “.2”)))
    get_image_pointer1 (Slide, Pointer, Type, Width, Height)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    dev_display (Slide)
    wait_seconds (1)
.变量循环尾 ()

' * dev_close_window ()

返回 ()

.子程序 p_wait_mouse_click
.参数 WindowHandle, tuple
.参数 RectR1, tuple
.参数 RectC1, tuple
.参数 RectR2, tuple
.参数 RectC2, tuple
.参数 WaitSeconds, tuple
.局部变量 Button, tuple
.局部变量 Clicked, tuple
.局部变量 Col, tuple
.局部变量 Error, tuple
.局部变量 Information, tuple
.局部变量 Rectangle, obj
.局部变量 Row, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 Time, tuple
.局部变量 false, tuple
.局部变量 true, tuple

dev_update_pc (“off”)
dev_update_var (“off”)
dev_update_window (“off”)
dev_update_time (“off”)
gen_rectangle1 (Rectangle, RectR1, RectC1, RectR2, RectC2)
get_system (“clock_mode”, Information)
set_system (“clock_mode”, “elapsed_time”)
count_seconds (Seconds1)
视_设值 (Time, 0)
视_设值 (Clicked, 假)
.判断循环首 (视_且 (视_小于 (Time, WaitSeconds), 视_位取反 (Clicked)))
    ' *     wait_seconds (0.2)
    count_seconds (Seconds2)
    视_设值 (Time, 视_减 (Seconds2, Seconds1))
    dev_error_var (Error, 1)
    dev_set_check (“~give_error”)
    get_mposition (WindowHandle, Row, Col, Button)
    dev_error_var (Error, 0)
    dev_set_check (“give_error”)
    .如果 (视_不等于 (Error, #视_错误代码_无错误))
        视_设值 (Button, 0)
    .否则

    .如果结束
    .如果 (视_且 (视_且 (视_且 (视_且 (视_等于 (Button, 1), 视_大于 (Row, RectR1)), 视_小于 (Row, RectR2)), 视_大于 (Col, RectC1)), 视_小于 (Col, RectC2)))
        视_设值 (Clicked, 真)
    .否则

    .如果结束

.判断循环尾 ()
set_system (“clock_mode”, Information)
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_pdf417
.局部变量 AllCandidates, obj
.局部变量 AllStatus, tuple
.局部变量 CandNum, tuple
.局部变量 Col, tuple
.局部变量 Contrast, tuple
.局部变量 DataCodeHandle, tuple
.局部变量 DecodedData, tuple
.局部变量 DecodedDataStrings, tuple
.局部变量 DecodingError, tuple
.局部变量 ErrorCorrectionLevel, tuple
.局部变量 FileNames, tuple
.局部变量 GenParamNames, tuple
.局部变量 GenParamValues, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 Image, obj
.局部变量 ImageEmpty, obj
.局部变量 MacroExist, tuple
.局部变量 Mirrored, tuple
.局部变量 ModuleAspect, tuple
.局部变量 ModuleHeight, tuple
.局部变量 ModuleWidth, tuple
.局部变量 Numbers, tuple
.局部变量 OpSystem, tuple
.局部变量 Passes, tuple
.局部变量 Paths, tuple
.局部变量 Pointer, tuple
.局部变量 ResultHandles, tuple
.局部变量 ResultNum, tuple
.局部变量 ResultObjectNames, tuple
.局部变量 ResultParamNames, tuple
.局部变量 Row, tuple
.局部变量 SL, tuple
.局部变量 Sequence, tuple
.局部变量 SymbolColumns, tuple
.局部变量 SymbolRows, tuple
.局部变量 SymbolXLD, obj
.局部变量 SymbolXLDs, obj
.局部变量 T1, tuple
.局部变量 T2, tuple
.局部变量 THeight, tuple
.局部变量 THeightResult, tuple
.局部变量 TPosCol, tuple
.局部变量 TPosRow, tuple
.局部变量 TWidth, tuple
.局部变量 TWidthResult, tuple
.局部变量 Time, tuple
.局部变量 Type, tuple
.局部变量 UndecNum, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandleResult, tuple
.局部变量 i, 整数型
.局部变量 true, tuple


' *****************************************************************************
' Example program for demonstrating the 2d data code operators
' *****************************************************************************
' This example program runs through an image sequence looking for
' 2d data code symbols (PDF417). To optimize the run time the
' parameters are set manually.
' In particular, the setting of the polarity helps to reduce the run time.
' In this example the polarity, the symbol size, the module size, and
' the minimum contrast are set.
' Note that in general the parameters can be chosen even more restrictive
' because the symbol variations in practice are smaller than in this example.

视_设值 (Paths, G (“datacode/pdf417/pdf417_misc_”))
tuple_gen_sequence (1, 10, 1, Sequence)
视_设值 (Numbers, 视_文本格式化 (Sequence, “.02”))
视_设值 (FileNames, 视_加 (视_取元素 (Paths, 0), Numbers))
视_设值 (FileNames, G (视_取元素 (FileNames, 7), 视_取元素 (FileNames, 4), FileNames))

read_image (Image, 视_取元素 (FileNames, 2))
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (489, 0, 640, 95, “black”, WindowHandleResult)
dev_set_part (0, 0, 94, 639)
get_system (“operating_system”, OpSystem)
.如果 (视_等于 (视_取文本范围 (OpSystem, 0, 2), “Win”))
    set_font (WindowHandleResult, “-Courier New-12-*-*-*-*-*-”)
.否则
    set_font (WindowHandleResult, “-adobe-courier-bold-r-normal--12-*-*-*-*-*-*-*”)
.如果结束
gen_image_const (ImageEmpty, “byte”, 640, 95)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

' Create a 2d data code model.
' --------------------------------------------------
' This model describes the symbol class that is searched and serves as a
' container for collecting the results during the symbol search in order to
' access them later by the get_data_code_2d_* operators.

create_data_code_2d_model (“PDF417”, G (), G (), DataCodeHandle)
set_data_code_2d_param (DataCodeHandle, G (“symbol_rows_min”, “symbol_rows_max”), G (6, 16))
set_data_code_2d_param (DataCodeHandle, G (“symbol_cols_min”, “symbol_cols_max”), G (5, 9))
set_data_code_2d_param (DataCodeHandle, G (“module_width_min”, “module_width_max”), G (到小数 (2), 到小数 (4)))
set_data_code_2d_param (DataCodeHandle, G (“module_aspect_min”, “module_aspect_max”), G (2.5, 到小数 (4)))
set_data_code_2d_param (DataCodeHandle, “polarity”, “dark_on_light”)
set_data_code_2d_param (DataCodeHandle, “contrast_min”, 10)

' Query a list of all supported model parameters, alphanumeric results,
' and iconic result objects; The operator query_data_code_2d_params
' returns a list of the generic parameter names that can be used
' in the get_ or set_data_code_2d_* operators.

query_data_code_2d_params (DataCodeHandle, “get_model_params”, GenParamNames)
query_data_code_2d_params (DataCodeHandle, “get_result_params”, ResultParamNames)
query_data_code_2d_params (DataCodeHandle, “get_result_objects”, ResultObjectNames)


' Wiithin a loop:
' + read the next image from the image sequence file
' + try to recognise the data code symbol(s)
' + for every image display the recognized symbol, the decoded string,
' and some data about the symbol and the search process

.变量循环首 (0, DD (视_减 (视_取元素总数 (FileNames), 1), ), 1, I)

    ' Read the next image
    read_image (Image, 视_取元素 (FileNames, I))

    ' Re-read the current settings of the model
    get_data_code_2d_param (DataCodeHandle, GenParamNames, GenParamValues)

    ' Look for the 2d data code symbols
    ' - stop after finding the expected number of symbols (or after the last search pass)
    ' - measure the run time of find_data_code_2d

    count_seconds (T1)
    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, G (), G (), ResultHandles, DecodedDataStrings)
    count_seconds (T2)
    视_设值 (Time, 视_乘 (1000, 视_减 (T2, T1)))

    ' Get some interesting information about the search in general

    get_data_code_2d_results (DataCodeHandle, “general”, “result_num”, ResultNum)
    get_data_code_2d_results (DataCodeHandle, “general”, “candidate_num”, CandNum)
    get_data_code_2d_results (DataCodeHandle, “general”, “pass_num”, Passes)
    get_data_code_2d_results (DataCodeHandle, “general”, “undecoded_num”, UndecNum)
    get_data_code_2d_results (DataCodeHandle, “general”, G (“search_level”, “min_search_level”, “max_search_level”), SL)

    ' Get some interesting information about all successfully detected symbols

    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_height”, ModuleHeight)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_width”, ModuleWidth)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “module_aspect”, ModuleAspect)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “symbol_rows”, SymbolRows)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “symbol_cols”, SymbolColumns)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “mirrored”, Mirrored)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “contrast”, Contrast)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “decoding_error”, DecodingError)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “error_correction_level”, ErrorCorrectionLevel)
    get_data_code_2d_results (DataCodeHandle, “all_results”, “macro_exist”, MacroExist)

    ' Get some information about all investigated symbol candidates in order to get a first
    ' hint why a symbol could not be read

    get_data_code_2d_results (DataCodeHandle, “all_candidates”, “status”, AllStatus)
    get_data_code_2d_objects (AllCandidates, DataCodeHandle, “all_candidates”, “candidate_xld”)

    ' Display some of the general information (runtime, number of found symbols and passes)
    ' and display all candidates that were investigated (red) and the decoded symbols (green)

    dev_display (Image)
    p_write_message (WindowHandle, G (-1), G (-1), G (视_加 (视_加 (“PDF417 found and decoded in ”, 视_文本格式化 (Time, “.0f”)), “ ms”)), 真)
    dev_set_color (“green”)
    dev_set_line_width (3)
    dev_display (SymbolXLDs)
    dev_set_line_width (1)

    ' For all symbols display the encoded data string and some
    ' info about the symbol and the reading process

    .变量循环首 (0, DD (视_减 (视_取元素总数 (ResultHandles), 1), ), 1, i)
        select_obj (SymbolXLDs, SymbolXLD, 视_加 (i, 1))
        get_contour_xld (SymbolXLD, Row, Col)
        dev_set_color (“coral”)

        p_datacode_result_pos (SymbolXLD, G (视_乘 (1.3, TWidth)), G (视_乘 (THeight, 0.9)), G (7), Width, Height, TPosRow, TPosCol)
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (0), TWidth, G (视_乘 (THeight, 0.9)), G (“symbol rows:”), G (视_取元素 (SymbolRows, i)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (1), TWidth, G (视_乘 (THeight, 0.9)), G (“symbol columns:”), G (视_取元素 (SymbolColumns, i)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (2), TWidth, G (视_乘 (THeight, 0.9)), G (“modules:”), G (视_加 (视_加 (视_文本格式化 (视_取元素 (ModuleHeight, i), “.1f”), “x”), 视_文本格式化 (视_取元素 (ModuleWidth, i), “.1f”))))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (3), TWidth, G (视_乘 (THeight, 0.9)), G (“mirrored:”), G (视_取元素 (Mirrored, i)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (4), TWidth, G (视_乘 (THeight, 0.9)), G (“contrast:”), G (视_取元素 (Contrast, i)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (5), TWidth, G (视_乘 (THeight, 0.9)), G (“decod.err:”), G (视_取元素 (DecodingError, i)))
        p_datacode_write_result (WindowHandle, TPosRow, TPosCol, G (6), TWidth, G (视_乘 (THeight, 0.9)), G (“err-corr-level:”), G (视_取元素 (ErrorCorrectionLevel, i)))
        ' Because some of the symbols encode escape sequences we should not output the
        ' decoded string directly. Therefore, we base the output on the ASCII values of the
        ' decoded data and interpret these values manually.
        dev_set_window (WindowHandleResult)
        dev_set_color (“green”)
        dev_display (ImageEmpty)
        get_data_code_2d_results (DataCodeHandle, 视_取元素 (ResultHandles, i), “decoded_data”, DecodedData)
        set_tposition (WindowHandleResult, 5, 10)
        write_string (WindowHandleResult, “Result:”)
        write_encoded_data (WindowHandleResult, DecodedData, G (5), G (80), TWidthResult, G (视_乘 (THeightResult, 0.9)), G (95), Width, G (“green”))
        dev_set_window (WindowHandle)
    .变量循环尾 ()

    .如果 (视_小于等于 (I, 1))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (4)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (2)

' Cleanup: close the 2d data code model

clear_data_code_2d_model (DataCodeHandle)
dev_set_window (WindowHandleResult)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()
dev_set_line_width (1)
返回 ()

.子程序 write_encoded_data
.参数 WindowHandle, tuple
.参数 DecodedData, tuple
.参数 Row, tuple
.参数 Col, tuple
.参数 Width, tuple
.参数 Height, tuple
.参数 ImageHeight, tuple
.参数 ImageWidth, tuple
.参数 Color, tuple
.局部变量 Ascent, tuple
.局部变量 Char, tuple
.局部变量 CharASCII, tuple
.局部变量 ColumnCurrent, tuple
.局部变量 Descent, tuple
.局部变量 Height1, tuple
.局部变量 I, tuple
.局部变量 LastSpace, tuple
.局部变量 LetterWidth, tuple
.局部变量 RectangleDelete, obj
.局部变量 RowCurrent, tuple
.局部变量 TextLine, tuple

' Count the number of lines to write
' * I := 0
' * TextLine := 0
' * while (I < |DecodedData|)
' *     Char := DecodedData[I]
' *     tuple_chr (Char, CharASCII)
' *     if (Char = 10)
' simulate LF (line feed) only if no CR follows
' *         if (I + 1 = |DecodedData|)
' *             TextLine := TextLine + 1
' *         else
' *             if (DecodedData[I+1] # 13)
' *                 TextLine := TextLine + 1
' *             endif
' *         endif
' *     endif
' *     if (Char = 13)
' simulate CR (carriage return) only if no LF follows
' *         if (I + 1 = |DecodedData|)
' *             TextLine := TextLine + 1
' *         else
' *             if (DecodedData[I+1] # 10)
' *                 TextLine := TextLine + 1
' *             endif
' *         endif
' *     endif
' *     if (Char = 94)
' *         TextLine := TextLine + 1
' *     endif
' *     I := I + 1
' * endwhile
' * if (Row + (TextLine + 1) * Height > ImageHeight)
' *     Row := ImageHeight - (TextLine + 1) * Height
' * endif
dev_set_color (“green”)
set_tposition (WindowHandle, Row, Col)
视_设值 (I, 0)
视_设值 (TextLine, 0)
视_设值 (LastSpace, -1)
get_string_extents (WindowHandle, “a”, Ascent, Descent, LetterWidth, Height1)
' Interpret the decoded data
.判断循环首 (视_小于 (I, 视_取元素总数 (DecodedData)))
    视_设值 (Char, 视_取元素 (DecodedData, I))
    tuple_chr (Char, CharASCII)
    .如果 (视_等于 (Char, 32))
        视_设值 (LastSpace, I)
    .否则

    .如果结束
    .如果 (视_且 (视_且 (视_且 (视_且 (视_且 (视_且 (视_且 (视_不等于 (Char, 2), 视_不等于 (Char, 3)), 视_不等于 (Char, 9)), 视_不等于 (Char, 10)), 视_不等于 (Char, 13)), 视_不等于 (Char, 26)), 视_不等于 (Char, 31)), 视_不等于 (Char, 94)))
        write_string (WindowHandle, CharASCII)
    .否则
        .如果 (视_等于 (Char, 2))
            ' ignore STX (start of text)
        .否则

        .如果结束
        .如果 (视_等于 (Char, 3))
            ' ignore ETX (end of text)
        .否则

        .如果结束
        .如果 (视_等于 (Char, 9))
            ' simulate TAB (horizontal tab)
            write_string (WindowHandle, “  ”)
        .否则

        .如果结束
        .如果 (视_等于 (Char, 10))
            ' simulate LF (line feed) only if no CR follows
            .如果 (视_等于 (视_加 (I, 1), 视_取元素总数 (DecodedData)))
                视_设值 (TextLine, 视_加 (TextLine, 1))
                set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Height, TextLine)), Col)
            .否则
                .如果 (视_不等于 (视_取元素 (DecodedData, 视_加 (I, 1)), 13))
                    视_设值 (TextLine, 视_加 (TextLine, 1))
                    set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Height, TextLine)), Col)
                .否则

                .如果结束

            .如果结束

        .否则
        .如果结束
        .如果 (视_等于 (Char, 13))
            ' simulate CR (carriage return) only if no LF follows
            .如果 (视_等于 (视_加 (I, 1), 视_取元素总数 (DecodedData)))
                视_设值 (TextLine, 视_加 (TextLine, 1))
                set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Height, TextLine)), Col)
            .否则
                .如果 (视_不等于 (视_取元素 (DecodedData, 视_加 (I, 1)), 10))
                    视_设值 (TextLine, 视_加 (TextLine, 1))
                    set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Height, TextLine)), Col)
                .否则

                .如果结束

            .如果结束

        .否则
        .如果结束
        .如果 (视_等于 (Char, 26))
            ' ignore SUB (substitution)
        .否则

        .如果结束
        .如果 (视_等于 (Char, 31))
            ' ignore VT (vertical tab)
        .否则

        .如果结束
        .如果 (视_等于 (Char, 94))
            ' replace ^ by LF
            ' *             TextLine := TextLine + 1
            ' *             set_tposition (WindowHandle, Row + Height * TextLine, Col)
            ' replace ^ by ' '
            视_设值 (LastSpace, I)
            write_string (WindowHandle, “ ”)
        .否则

        .如果结束

    .如果结束
    get_tposition (WindowHandle, RowCurrent, ColumnCurrent)
    .如果 (视_且 (视_大于 (ColumnCurrent, ImageWidth), 视_不等于 (LastSpace, -1)))
        gen_rectangle1 (RectangleDelete, 视_加 (Row, 视_乘 (Height, TextLine)), 视_减 (ColumnCurrent, 视_乘 (视_减 (I, LastSpace), LetterWidth)), 视_加 (视_加 (Row, 视_乘 (Height, TextLine)), Height), ColumnCurrent)
        dev_set_color (“black”)
        dev_display (RectangleDelete)
        dev_set_color (“green”)
        视_设值 (TextLine, 视_加 (TextLine, 1))
        set_tposition (WindowHandle, 视_加 (Row, 视_乘 (Height, TextLine)), Col)
        视_设值 (I, LastSpace)
    .否则

    .如果结束
    视_设值 (I, 视_加 (I, 1))
.判断循环尾 ()
返回 ()

.子程序 p_do_3d_position_of_circles
.局部变量 CamParam, tuple
.局部变量 CenterNormal1, tuple
.局部变量 CenterNormal2, tuple
.局部变量 ClusterCN1, tuple
.局部变量 ClusterCN2, tuple
.局部变量 ClusterP1, tuple
.局部变量 ClusterP2, tuple
.局部变量 Column, tuple
.局部变量 Cross, obj
.局部变量 EllipseContours, obj
.局部变量 EllipseContoursLarge, obj
.局部变量 EllipseContoursSmall, obj
.局部变量 Height, tuple
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 NumberLarge, tuple
.局部变量 NumberSmall, tuple
.局部变量 Pose1, tuple
.局部变量 Pose2, tuple
.局部变量 Qx, tuple
.局部变量 Qy, tuple
.局部变量 Qz, tuple
.局部变量 RadiusLarge, tuple
.局部变量 RadiusSmall, tuple
.局部变量 Row, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 false, tuple
.局部变量 i, 整数型

' This example program shows how to use the operator get_circle_pose.
' First, the contours of the drill-holes of a rim are extracted.
' Then, the 3D position of the center of these contours is determined with the operator get_circle_pose.

' Read the image and initialize the program.
read_image (Image, “rim”)
get_image_size (Image, Width, Height)
dev_open_window_fit_image (Image, 0, 0, 640, -1, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)
dev_display (Image)
dev_set_line_width (2)

' Determine the elliptical contours of the drill-holes.
p_determine_ellipse_contours (Image, EllipseContoursLarge, EllipseContoursSmall, G (假), NumberLarge, NumberSmall)
concat_obj (EllipseContoursLarge, EllipseContoursSmall, EllipseContours)

' Set the radius of the drill-holes and the camera parameters (result from a camera calibration)
视_设值 (RadiusLarge, 视_除 (10.25, 到小数 (1000)))
视_设值 (RadiusSmall, 视_除 (5.91, 到小数 (1000)))
视_设值 (CamParam, G (0.0122, -261.04, 7.39e-006, 7.4e-006, 303.12, 234.17, 652, 494))

' Apply the operator get_circle_pos to determine the position and orientation of the circles.
' Note that in this case the operator get_circle_pose is called two times: First to determine  the poses of the circles,
' then, to determine the normal vectors of the 3D circles.
' For each circle, two possible 3D positions and orientations are determined by the operator get_circle_pose.
' The normal vectors of the 3D circles are used to cluster the results such that all the
' circles that lie within one plane are grouped together. This clustering is carried out by
' the procedure p_cluster_normals.
get_circle_pose (EllipseContours, CamParam, G (gen_tuple_const (NumberLarge, RadiusLarge), gen_tuple_const (NumberSmall, RadiusSmall)), “pose”, Pose1, Pose2)
get_circle_pose (EllipseContours, CamParam, G (gen_tuple_const (NumberLarge, RadiusLarge), gen_tuple_const (NumberSmall, RadiusSmall)), “center_normal”, CenterNormal1, CenterNormal2)
p_cluster_normals (Pose1, Pose2, CenterNormal1, CenterNormal2, ClusterP1, ClusterP2, ClusterCN1, ClusterCN2)

' Visualize the results.
dev_display (Image)
dev_set_color (“blue”)
dev_set_line_width (2)
dev_display (EllipseContours)
disp_message (WindowHandle, “Fitted ellipses”, “image”, -1, -1, “black”, “true”)
wait_seconds (3)

disp_message (WindowHandle, G (“3D position of the circles”, “determined solely from the ellipses”), “image”, 10, -1, “black”, “true”)
dev_set_color (“green”)
.变量循环首 (0, DD (视_减 (视_加 (NumberLarge, NumberSmall), 1), ), 1, i)
    pose_to_hom_mat3d (视_取元素范围 (ClusterP1, 视_乘 (i, 7), 视_加 (视_乘 (i, 7), 6)), HomMat3D)
    affine_trans_point_3d (HomMat3D, 0, 0, 0, Qx, Qy, Qz)
    project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)
    gen_cross_contour_xld (Cross, Row, Column, 10, 0.785398)
    dev_display (Cross)
    .如果 (视_小于 (i, 视_减 (视_加 (NumberLarge, NumberSmall), 1)))
        disp_message (WindowHandle, G (视_加 (视_加 (“X= ”, 视_文本格式化 (视_乘 (视_取元素 (ClusterCN1, 视_乘 (i, 6)), 1000), “3.1f”)), “ mm”), 视_加 (视_加 (“Y= ”, 视_文本格式化 (视_乘 (视_取元素 (ClusterCN1, 视_加 (视_乘 (i, 6), 1)), 1000), “3.1f”)), “ mm”), 视_加 (视_加 (“Z= ”, 视_文本格式化 (视_乘 (视_取元素 (ClusterCN1, 视_加 (视_乘 (i, 6), 2)), 1000), “3.1f”)), “ mm”)), “image”, 视_减 (Row, 40), 视_减 (Column, 270), “black”, “true”)
    .否则
        disp_message (WindowHandle, G (视_加 (视_加 (“X= ”, 视_文本格式化 (视_乘 (视_取元素 (ClusterCN1, 视_乘 (i, 6)), 1000), “3.1f”)), “ mm”), 视_加 (视_加 (“Y= ”, 视_文本格式化 (视_乘 (视_取元素 (ClusterCN1, 视_加 (视_乘 (i, 6), 1)), 1000), “3.1f”)), “ mm”), 视_加 (视_加 (“Z= ”, 视_文本格式化 (视_乘 (视_取元素 (ClusterCN1, 视_加 (视_乘 (i, 6), 2)), 1000), “3.1f”)), “ mm”)), “image”, 视_减 (Row, 200), 视_减 (Column, 170), “black”, “true”)
        dev_set_color (“blue”)
        disp_line (WindowHandle, 404, 660, 487, 709)
    .如果结束

.变量循环尾 ()
dev_set_line_width (1)
wait_seconds (5)
dev_close_window ()
返回 ()

.子程序 p_determine_ellipse_contours
.参数 Image, obj
.参数 EllipseContoursLarge, obj, 参考
.参数 EllipseContoursSmall, obj, 参考
.参数 visualization, tuple
.参数 NumberLarge, tuple, 参考
.参数 NumberSmall, tuple, 参考
.局部变量 Circles, obj
.局部变量 Column, tuple
.局部变量 Dark, obj
.局部变量 DarkRegions, obj
.局部变量 Edges, obj
.局部变量 EdgesLarge, obj
.局部变量 EdgesSmall, obj
.局部变量 EndPhi, tuple
.局部变量 Phi, tuple
.局部变量 PointOrder, tuple
.局部变量 ROI, obj
.局部变量 ROIEdges, obj
.局部变量 ROIInner, obj
.局部变量 ROIOuter, obj
.局部变量 Ra, tuple
.局部变量 Rb, tuple
.局部变量 RimReduced, obj
.局部变量 Row, tuple
.局部变量 StartPhi, tuple

threshold (Image, Dark, 0, 128)
.如果 (视_是否为真 (visualization))
    dev_display (Image)
    dev_set_color (“green”)
    dev_set_draw (“fill”)
    dev_display (Dark)
    stop ()
.否则

.如果结束

connection (Dark, DarkRegions)
select_shape (DarkRegions, Circles, G (“circularity”, “area”), “and”, G (0.85, 50), G (到小数 (1), 99999))
.如果 (视_是否为真 (visualization))
    dev_display (Image)
    dev_set_colored (12)
    dev_display (Circles)
    stop ()
.否则

.如果结束

dilation_circle (Circles, ROIOuter, 8.5)
erosion_circle (Circles, ROIInner, 8.5)
difference (ROIOuter, ROIInner, ROI)
union1 (ROI, ROIEdges)
.如果 (视_是否为真 (visualization))
    dev_display (Image)
    dev_set_draw (“margin”)
    dev_set_color (“green”)
    dev_display (ROIEdges)
    stop ()
.否则

.如果结束

reduce_domain (Image, ROIEdges, RimReduced)
edges_sub_pix (RimReduced, Edges, “lanser2”, 0.3, 10, 20)

select_contours_xld (Edges, EdgesLarge, “contour_length”, 200, 300, 0, 0)
count_obj (EdgesLarge, NumberLarge)
fit_ellipse_contour_xld (EdgesLarge, “ftukey”, -1, 2, 0, 200, 3, 2, Row, Column, Phi, Ra, Rb, StartPhi, EndPhi, PointOrder)
gen_ellipse_contour_xld (EllipseContoursLarge, Row, Column, gen_tuple_const (NumberLarge, 0), Ra, Rb, gen_tuple_const (NumberLarge, 0), gen_tuple_const (NumberLarge, rad (360)), gen_tuple_const (NumberLarge, “positive”), 1.5)

select_contours_xld (Edges, EdgesSmall, “contour_length”, 100, 200, 0, 0)
count_obj (EdgesSmall, NumberSmall)
fit_ellipse_contour_xld (EdgesSmall, “ftukey”, -1, 2, 0, 200, 3, 2, Row, Column, Phi, Ra, Rb, StartPhi, EndPhi, PointOrder)
gen_ellipse_contour_xld (EllipseContoursSmall, Row, Column, gen_tuple_const (NumberSmall, 0), Ra, Rb, gen_tuple_const (NumberSmall, 0), gen_tuple_const (NumberSmall, rad (360)), gen_tuple_const (NumberSmall, “positive”), 1.5)

.如果 (视_是否为真 (visualization))
    dev_display (Image)
    dev_set_color (“green”)
    dev_display (EllipseContoursLarge)
    dev_set_color (“blue”)
    dev_display (EllipseContoursSmall)
    stop ()
.否则

.如果结束
返回 ()

.子程序 p_cluster_normals
.参数 Pose1, tuple
.参数 Pose2, tuple
.参数 CenterNormal1, tuple
.参数 CenterNormal2, tuple
.参数 ClusterP1, tuple, 参考
.参数 ClusterP2, tuple, 参考
.参数 ClusterCN1, tuple, 参考
.参数 ClusterCN2, tuple, 参考
.局部变量 DeviationC1, tuple
.局部变量 DeviationC2, tuple
.局部变量 Help, tuple
.局部变量 Indices, tuple
.局部变量 N1, tuple
.局部变量 N1NA, tuple
.局部变量 N1NB, tuple
.局部变量 N2, tuple
.局部变量 N2NA, tuple
.局部变量 N2NB, tuple
.局部变量 NA, tuple
.局部变量 NB, tuple
.局部变量 Number, tuple
.局部变量 i, 整数型
.局部变量 idx, tuple

视_设值 (Number, 视_除 (视_取元素总数 (CenterNormal1), 6))
视_设值 (ClusterP1, 视_取元素范围 (Pose1, 0, 6))
视_设值 (ClusterP2, 视_取元素范围 (Pose2, 0, 6))
视_设值 (ClusterCN1, 视_取元素范围 (CenterNormal1, 0, 5))
视_设值 (ClusterCN2, 视_取元素范围 (CenterNormal2, 0, 5))
视_设值 (NA, 视_取元素范围 (ClusterCN1, 3, 5))
视_设值 (NB, 视_取元素范围 (ClusterCN2, 3, 5))
.变量循环首 (1, DD (视_减 (Number, 1), ), 1, i)
    视_设值 (N1, 视_取元素范围 (CenterNormal1, 视_加 (视_乘 (i, 6), 3), 视_加 (视_乘 (i, 6), 5)))
    视_设值 (N2, 视_取元素范围 (CenterNormal2, 视_加 (视_乘 (i, 6), 3), 视_加 (视_乘 (i, 6), 5)))
    视_设值 (N1NA, sum (视_乘 (N1, NA)))
    视_设值 (N1NB, sum (视_乘 (N1, NB)))
    视_设值 (N2NA, sum (视_乘 (N2, NA)))
    视_设值 (N2NB, sum (视_乘 (N2, NB)))
    tuple_sort_index (视_乘 (G (N1NA, N1NB, N2NA, N2NB), -1), Indices)
    .如果 (视_或 (视_等于 (视_取元素 (Indices, 0), 0), 视_等于 (视_取元素 (Indices, 0), 3)))
        视_设值 (ClusterP1, G (ClusterP1, 视_取元素范围 (Pose1, 视_乘 (i, 7), 视_加 (视_乘 (i, 7), 6))))
        视_设值 (ClusterP2, G (ClusterP2, 视_取元素范围 (Pose2, 视_乘 (i, 7), 视_加 (视_乘 (i, 7), 6))))
        视_设值 (ClusterCN1, G (ClusterCN1, 视_取元素范围 (CenterNormal1, 视_乘 (i, 6), 视_加 (视_乘 (i, 6), 5))))
        视_设值 (ClusterCN2, G (ClusterCN2, 视_取元素范围 (CenterNormal2, 视_乘 (i, 6), 视_加 (视_乘 (i, 6), 5))))
    .否则
        视_设值 (ClusterP1, G (ClusterP1, 视_取元素范围 (Pose2, 视_乘 (i, 7), 视_加 (视_乘 (i, 7), 6))))
        视_设值 (ClusterP2, G (ClusterP2, 视_取元素范围 (Pose1, 视_乘 (i, 7), 视_加 (视_乘 (i, 7), 6))))
        视_设值 (ClusterCN1, G (ClusterCN1, 视_取元素范围 (CenterNormal2, 视_乘 (i, 6), 视_加 (视_乘 (i, 6), 5))))
        视_设值 (ClusterCN2, G (ClusterCN2, 视_取元素范围 (CenterNormal1, 视_乘 (i, 6), 视_加 (视_乘 (i, 6), 5))))
    .如果结束

.变量循环尾 ()

视_设值 (idx, G ())
.变量循环首 (0, DD (视_减 (Number, 1), ), 1, i)
    视_设值 (idx, G (idx, 视_加 (视_乘 (i, 6), 3)))
.变量循环尾 ()
视_设值 (DeviationC1, 视_加 (视_加 (deviation (subset (ClusterCN1, idx)), deviation (subset (ClusterCN1, 视_加 (idx, 1)))), deviation (subset (ClusterCN1, 视_加 (idx, 2)))))
视_设值 (DeviationC2, 视_加 (视_加 (deviation (subset (ClusterCN2, idx)), deviation (subset (ClusterCN2, 视_加 (idx, 1)))), deviation (subset (ClusterCN2, 视_加 (idx, 2)))))
.如果 (视_小于 (DeviationC2, DeviationC1))
    视_设值 (Help, ClusterP1)
    视_设值 (ClusterP1, ClusterP2)
    视_设值 (ClusterP2, Help)
    视_设值 (Help, ClusterCN1)
    视_设值 (ClusterCN1, ClusterCN2)
    视_设值 (ClusterCN2, Help)
.否则

.如果结束
返回 ()

.子程序 p_do_inpainting
.局部变量 CamParamL, tuple
.局部变量 CamParamR, tuple
.局部变量 CamPoseRectL, tuple
.局部变量 CamPoseRectR, tuple
.局部变量 DistanceImage, obj
.局部变量 DistanceImageFull, obj
.局部变量 Domain, obj
.局部变量 HarmonicDistanceImage, obj
.局部变量 Height, tuple
.局部变量 HeightL, tuple
.局部变量 HeightR, tuple
.局部变量 ImageL, obj
.局部变量 ImageR, obj
.局部变量 ImageRectifiedL, obj
.局部变量 ImageRectifiedR, obj
.局部变量 ImgPath, tuple
.局部变量 InpaintedDistanceImage, obj
.局部变量 MapL, obj
.局部变量 MapR, obj
.局部变量 RectCamParL, tuple
.局部变量 RectCamParR, tuple
.局部变量 RectLPosRectR, tuple
.局部变量 RegionInpainting, obj
.局部变量 RegionInpaintingFull, obj
.局部变量 RelPose, tuple
.局部变量 ScoreImageDistance, obj
.局部变量 Width, tuple
.局部变量 WidthL, tuple
.局部变量 WidthR, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 WindowHandle2, tuple
.局部变量 true, tuple

' This example program shows how inpainting_aniso can be used to
' fill up the areas that cannot be reconstructed with stereo reconstruction,
' e.g., because of occlusions or missing texture.  You will see that
' inpainting_aniso creates a reconstruction with relatively sharp edges.
dev_open_window (0, 0, 640, 112, “black”, WindowHandle)
p_set_font (WindowHandle)
p_write_message (WindowHandle, G (-1), G (-1), G (“Binocular stereo reconstruction”), 真)
p_write_message (WindowHandle, G (72), G (12), G (“Image of left camera”), 真)
p_write_message (WindowHandle, G (72), G (330), G (“Image of right camera”), 真)
视_设值 (ImgPath, “stereo/board/”)
read_image (ImageL, 视_加 (ImgPath, “board_l_01”))
read_image (ImageR, 视_加 (ImgPath, “board_r_01”))
' Reopen the windows with an appropriate size
dev_set_draw (“margin”)
get_image_size (ImageL, WidthL, HeightL)
get_image_size (ImageR, WidthR, HeightR)
' * dev_open_window (175, 0, 317, HeightL*317./WidthL+0.5, 'black', WindowHandle1)
dev_open_window (175, 0, 313, 视_加 (视_除 (视_乘 (HeightL, 到小数 (313)), WidthL), 0.5), “black”, WindowHandle1)
dev_set_part (0, 0, 视_减 (HeightL, 1), 视_减 (WidthL, 1))
dev_display (ImageL)
' * dev_open_window (175, 323, 317, HeightR*317./WidthR+0.5, 'black', WindowHandle2)
dev_open_window (175, 327, 313, 视_加 (视_除 (视_乘 (HeightR, 到小数 (313)), WidthR), 0.5), “black”, WindowHandle2)
dev_set_part (0, 0, 视_减 (HeightR, 1), 视_减 (WidthR, 1))
dev_display (ImageR)
wait_seconds (3)
dev_set_window (WindowHandle1)
dev_clear_window ()
dev_set_window (WindowHandle2)
dev_clear_window ()
dev_set_window (WindowHandle)
dev_clear_window ()
p_write_message (WindowHandle, G (-1), G (-1), G (“Dense distance image using inpainting”), 真)
p_write_message (WindowHandle, G (72), G (12), G (“Reconstructed Distance”), 真)
p_write_message (WindowHandle, G (72), G (330), G (“Dense Distance Image”), 真)
视_设值 (CamParamL, G (0.0130507774353, -665.817817207, 1.4803417027e-005, 1.48e-005, 155.89225769, 126.70664978, 320, 240))
视_设值 (CamParamR, G (0.0131776504517, -731.860636733, 1.47997569293e-005, 1.48e-005, 162.98210144, 119.301040649, 320, 240))
视_设值 (RelPose, G (0.153573364258, -0.00373362231255, 0.0447351264954, 0.174289124775, 319.843388114, 359.894955219, 0))
gen_binocular_rectification_map (MapL, MapR, CamParamL, CamParamR, RelPose, 1, “geometric”, “bilinear”, RectCamParL, RectCamParR, CamPoseRectL, CamPoseRectR, RectLPosRectR)
' Read the stereo image pair.
emphasize (ImageL, ImageL, 7, 7, 1)
emphasize (ImageR, ImageR, 7, 7, 1)
map_image (ImageL, MapL, ImageRectifiedL)
map_image (ImageR, MapR, ImageRectifiedR)
' Determine the distance image.
binocular_distance (ImageRectifiedL, ImageRectifiedR, DistanceImage, ScoreImageDistance, RectCamParL, RectCamParR, RectLPosRectR, “ncc”, 17, 17, 5, 10, 40, 1, 0.1, “left_right_check”, “interpolation”)
dev_set_window (WindowHandle1)
dev_clear_window ()
dev_display (DistanceImage)
' Before we can perform the inpainting with inpainting_aniso, we have
' to create suitable staring values.  This is performed with
' harmonic_interpolation.
' Determine the inpainting region.  It is given by the complement of the
' domain returned by binocular_distance.
get_domain (DistanceImage, Domain)
complement (Domain, RegionInpaintingFull)
' harmonic_interpolation intersects the region with the domain of the image.
' Since the inpainting region is the complament of the domain of the distance
' image the intersection would be empty.  Therefore, we have to use the full
' domain on the image to be inpainted.
full_domain (DistanceImage, DistanceImageFull)
harmonic_interpolation (DistanceImageFull, RegionInpaintingFull, HarmonicDistanceImage, 1e-005)
' We can now perform the inpainting with inpainting_aniso.  In contrast to
' harmonic_interpolation, the inpainting region must keep a slight distance
' to the border of the image.  Therefore, we clip the inpainting region.
get_image_size (DistanceImage, Width, Height)
clip_region (RegionInpaintingFull, RegionInpainting, 3, 3, 视_减 (Height, 4), 视_减 (Width, 4))
inpainting_aniso (HarmonicDistanceImage, RegionInpainting, InpaintedDistanceImage, “shock”, 0.5, 0.5, 60, 3)
' Display the dense distance image
dev_set_window (WindowHandle2)
dev_clear_window ()
dev_display (InpaintedDistanceImage)
wait_seconds (5)
dev_set_window (WindowHandle2)
dev_close_window ()
dev_set_window (WindowHandle1)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()
返回 ()

.子程序 p_do_enhancement
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 ImageCED, obj
.局部变量 ImageCode, obj
.局部变量 ImagePrint, obj
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 SharpenedImage, obj
.局部变量 Time, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandleDC, tuple
.局部变量 WindowHandleFP, tuple

' This example program shows how a defocused image can be sharpened
' with shock_filter and how coherence_enhancing_diff can be used
' to enhance a fingerprint image by joining disconnected parts of the
' fingerprint lines.
dev_open_window (0, 0, 640, 112, “black”, WindowHandle)
p_set_font (WindowHandle)
disp_message (WindowHandle, “Image Enhancement”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Blurred data code”, “window”, 72, 12, “black”, “true”)
disp_message (WindowHandle, “Fragmented fingerprint”, “window”, 72, 330, “black”, “true”)
dev_open_window (175, 0, 313, 313, “black”, WindowHandleDC)
dev_set_part (160, 365, 369, 584)
read_image (Image, “datacode/ecc200/ecc200_cpu_015”)
' Since the image contains interlace effects, remove them first.
fill_interlace (Image, ImageCode, “odd”)
dev_display (ImageCode)
dev_open_window (175, 327, 313, 313, “black”, WindowHandleFP)
read_image (ImagePrint, “fingerprint”)
get_image_size (ImagePrint, Width, Height)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (ImagePrint)
' * wait_seconds (1)
' Data Code:
' Apply the shock filter.  In most cases, Mode = 'canny' is preferable since it
' tends to straighten edges.  However, in this case we want to preserve the
' corners of the data code modules as much as possible.  This is achieved
' by using Mode = 'laplace'.
count_seconds (Seconds1)
shock_filter (ImageCode, SharpenedImage, 0.5, 10, “laplace”, 1.5)
' Fingerprint:
coherence_enhancing_diff (ImagePrint, ImageCED, 0.5, 4, 0.5, 50)
count_seconds (Seconds2)
视_设值 (Time, 视_减 (Seconds2, Seconds1))

wait_seconds (max (G (0, 视_减 (4, Time))))
dev_set_window (WindowHandle)
dev_clear_window ()
disp_message (WindowHandle, “Image Enhancement”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Sharpened data code”, “window”, 72, 12, “black”, “true”)
disp_message (WindowHandle, “Joined print lines”, “window”, 72, 330, “black”, “true”)
dev_set_window (WindowHandleDC)
dev_display (SharpenedImage)
dev_set_window (WindowHandleFP)
dev_display (ImageCED)
wait_seconds (5)
dev_set_window (WindowHandleFP)
dev_close_window ()
dev_set_window (WindowHandleDC)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()
返回 ()

.子程序 p_do_stereo_uncal
.局部变量 Col1, tuple
.局部变量 Col2, tuple
.局部变量 CovFMat, tuple
.局部变量 CovFMatRect, tuple
.局部变量 Disparity, obj
.局部变量 Error, tuple
.局部变量 FMatrix, tuple
.局部变量 H1, tuple
.局部变量 H2, tuple
.局部变量 Height, tuple
.局部变量 HomMat, tuple
.局部变量 Image1, obj
.局部变量 Image2, obj
.局部变量 Map1, obj
.局部变量 Map2, obj
.局部变量 MaxNum, tuple
.局部变量 Ones, tuple
.局部变量 Points1, tuple
.局部变量 Points2, tuple
.局部变量 Region, obj
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 Scale, tuple
.局部变量 Score, obj
.局部变量 StructElem, obj
.局部变量 Time1, tuple
.局部变量 Time2, tuple
.局部变量 W, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 WindowHandle2, tuple
.局部变量 true, tuple

' **************************************************************************************************
' Projective rectification of a circuit board
' **************************************************************************************************

dev_open_window (0, 0, 640, 112, “black”, WindowHandle)
p_set_font (WindowHandle)
p_write_message (WindowHandle, G (-1), G (-1), G (“Uncalibrated stereo images”), 真)
p_write_message (WindowHandle, G (72), G (12), G (“Image of left camera”), 真)
p_write_message (WindowHandle, G (72), G (330), G (“Image of right camera”), 真)

read_image (Image1, “/stereo/uncalib/board_l”)
read_image (Image2, “/stereo/uncalib/board_r”)
get_image_size (Image1, Width, Height)
dev_open_window (175, 0, 313, 视_加 (视_除 (视_乘 (Height, 到小数 (313)), Width), 0.5), “black”, WindowHandle1)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_open_window (175, 327, 313, 视_加 (视_除 (视_乘 (Height, 到小数 (313)), Width), 0.5), “black”, WindowHandle2)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
视_设值 (Scale, 0.9)
' * zoom_image_factor (Image1, Image1, Scale, Scale, 'constant')
' * zoom_image_factor (Image2, Image2, Scale, Scale, 'constant')
' * get_image_size (Image1, Width, Height)
scale_image_max (Image1, Image1)
scale_image_max (Image2, Image2)
dev_set_window (WindowHandle1)
dev_display (Image1)
dev_set_window (WindowHandle2)
dev_display (Image2)


' Compute Fundamental Matrix

视_设值 (MaxNum, 2000)
points_harris (Image1, 5, 2, 0.2, 100000, Row1, Col1)
points_harris (Image2, 5, 2, 0.2, 100000, Row2, Col2)
' * points_harris (Image1, 3, 1, 0.2, 1e5, Row1, Col1)
' * points_harris (Image2, 3, 1, 0.2, 1e5, Row2, Col2)
match_fundamental_matrix_ransac (Image1, Image2, Row1, Col1, Row2, Col2, “ncc”, 21, 0, 200, 50, 50, 0, 0.6, “gold_standard”, 1, 1, FMatrix, CovFMat, Error, Points1, Points2)
视_设值 (Row1, subset (Row1, Points1))
视_设值 (Col1, subset (Col1, Points1))
视_设值 (Row2, subset (Row2, Points2))
视_设值 (Col2, subset (Col2, Points2))


' Projective Rectification

gen_binocular_proj_rectification (Map1, Map2, FMatrix, G (), Width, Height, Width, Height, 1, “bilinear_map”, CovFMatRect, H1, H2)
map_image (Image1, Map1, Image1)
map_image (Image2, Map2, Image2)
tuple_gen_const (视_取元素总数 (Row1), 1, Ones)
projective_trans_point_2d (H1, Col1, Row1, Ones, Col1, Row1, W)
视_设值 (Col1, 视_除 (Col1, W))
视_设值 (Row1, 视_除 (Row1, W))
projective_trans_point_2d (H2, Col2, Row2, Ones, Col2, Row2, W)
视_设值 (Col2, 视_除 (Col2, W))
视_设值 (Row2, 视_除 (Row2, W))


' Find the dominant plane in the images by computing the 2D homography.
' Then, the left image is transformed such that points lying in this dominant plane do coincide in both images.

proj_match_points_ransac (Image1, Image2, Row1, Col1, Row2, Col2, “ncc”, 11, 0, 200, 100, 100, 0, 0.6, “normalized_dlt”, 0.5, 1, HomMat, Points1, Points2)
projective_trans_image (Image1, Image1, HomMat, “bilinear”, “false”, “true”)

dev_set_window (WindowHandle1)
dev_clear_window ()
dev_display (Image1)
dev_set_window (WindowHandle2)
dev_clear_window ()
dev_display (Image2)
dev_set_window (WindowHandle)
dev_clear_window ()
p_write_message (WindowHandle, G (-1), G (-1), G (“Uncalibrated rectification”), 真)
p_write_message (WindowHandle, G (72), G (12), G (“Left image”), 真)
p_write_message (WindowHandle, G (72), G (330), G (“Right image”), 真)

wait_seconds (4)

' The difference between corresponding points, also called parallax, is reciprocal to the 3D distance
' from the space point the reference plane.

count_seconds (Time1)
binocular_disparity (Image1, Image2, Disparity, Score, “ncc”, 15, 15, 5, -5, 5, 1, 0.8, “left_right_check”, “interpolation”)
threshold (Disparity, Region, 0.5, 3)
gen_circle (StructElem, 10, 10, 3)
opening (Region, StructElem, Region)

dev_set_window (WindowHandle1)
dev_clear_window ()
dev_display (Disparity)
dev_set_window (WindowHandle2)
dev_clear_window ()
dev_set_color (“slate blue”)
dev_set_draw (“fill”)
dev_display (Image1)
dev_display (Region)
dev_set_window (WindowHandle)
dev_clear_window ()
p_write_message (WindowHandle, G (-1), G (-1), G (“Use disparity for height segmentation”), 真)
p_write_message (WindowHandle, G (72), G (12), G (“Disparity map”), 真)
p_write_message (WindowHandle, G (72), G (330), G (“Segmented components”), 真)

count_seconds (Time2)
wait_seconds (视_减 (9, 视_减 (Time2, Time1)))
dev_set_window (WindowHandle)
dev_close_window ()
dev_set_window (WindowHandle1)
dev_close_window ()
dev_set_window (WindowHandle2)
dev_close_window ()

返回 ()

.子程序 p_do_color_fuses
.局部变量 Blue, obj
.局部变量 Column1, tuple
.局部变量 CurrentFuse, obj
.局部变量 CurrentFuseConn, obj
.局部变量 CurrentFuseFill, obj
.局部变量 CurrentFuseSel, obj
.局部变量 Fuse, 整数型
.局部变量 FuseArea, tuple
.局部变量 FuseColors, tuple
.局部变量 FuseTypes, tuple
.局部变量 Green, obj
.局部变量 Height, tuple
.局部变量 Hue, obj
.局部变量 HueRanges, tuple
.局部变量 HueSaturated, obj
.局部变量 Image, obj
.局部变量 Index, 整数型
.局部变量 Intensity, obj
.局部变量 Red, obj
.局部变量 Row1, tuple
.局部变量 Saturated, obj
.局部变量 Saturation, obj
.局部变量 WH, tuple
.局部变量 Width, tuple
.局部变量 i, 整数型

' ****
' step: set up fuse properties and hue ranges
' ****
视_设值 (FuseColors, G (“Orange”, “Red”, “Blue”, “Yellow”, “Green”))
视_设值 (FuseTypes, G (5, 10, 15, 20, 30))
' HueRanges: Orange 10-30, Red 0-10...
视_设值 (HueRanges, G (10, 30, 0, 10, 125, 162, 30, 64, 96, 128))
dev_open_window (0, 0, 640, 视_除 (视_乘 (600, 到小数 (640)), 800), “black”, WH)
p_set_font (WH)
.变量循环首 (1, 4, 1, Index)
    ' ****
    ' step: acquire image
    ' ****
    read_image (Image, 视_加 (“color/color_fuses_”, 视_文本格式化 (Index, “.02”)))
    get_image_size (Image, Width, Height)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    dev_display (Image)
    ' ****
    ' step: extract saturated hues
    ' ****
    decompose3 (Image, Red, Green, Blue)
    trans_from_rgb (Red, Green, Blue, Hue, Saturation, Intensity, “hsv”)
    threshold (Saturation, Saturated, 60, 255)
    reduce_domain (Hue, Saturated, HueSaturated)
    disp_message (WH, “Result of the color segmentation:”, “window”, 10, 10, “black”, “true”)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (FuseTypes), 1), ), 1, Fuse)
        ' ****
        ' step: classify specific fuse
        ' ****
        threshold (HueSaturated, CurrentFuse, 视_取元素 (HueRanges, 视_乘 (Fuse, 2)), 视_取元素 (HueRanges, 视_加 (视_乘 (Fuse, 2), 1)))
        connection (CurrentFuse, CurrentFuseConn)
        fill_up (CurrentFuseConn, CurrentFuseFill)
        select_shape (CurrentFuseFill, CurrentFuseSel, “area”, “and”, 6000, 20000)
        area_center (CurrentFuseSel, FuseArea, Row1, Column1)
        dev_set_color (“magenta”)
        .变量循环首 (0, DD (视_减 (视_取元素总数 (FuseArea), 1), ), 1, i)
            disp_message (WH, G (视_取元素 (FuseColors, Fuse), 视_加 (视_加 (“(”, 视_取元素 (FuseTypes, Fuse)), “ A)”)), “image”, 视_加 (视_取元素 (Row1, i), 60), 视_减 (视_取元素 (Column1, i), 70), “black”, “true”)
        .变量循环尾 ()
    .变量循环尾 ()
    p_disp_pause_sign (WH, G (2))
    wait_seconds (3)
.变量循环尾 ()
dev_close_window ()
返回 ()

.子程序 p_do_measure_leads
.局部变量 AmplitudeFirst, tuple
.局部变量 AmplitudeSecond, tuple
.局部变量 Column, tuple
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 ColumnEdgeFirst, tuple
.局部变量 ColumnEdgeSecond, tuple
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 LeadDistance, tuple
.局部变量 LeadWidth, tuple
.局部变量 Length1, tuple
.局部变量 Length2, tuple
.局部变量 MeasureHandle, tuple
.局部变量 Message, tuple
.局部变量 Phi, tuple
.局部变量 Pointer, tuple
.局部变量 Rectangle, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 RowEdgeFirst, tuple
.局部变量 RowEdgeSecond, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 Time, tuple
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 avgLeadDistance, tuple
.局部变量 avgLeadWidth, tuple
.局部变量 i, 整数型
.局部变量 n, tuple
.局部变量 numLeads, tuple


' Lead Measurement: Example for the application of the measure package
' including a lot of visualization operators

read_image (Image, “ic_pin”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (0, 0, 视_除 (视_乘 (Width, 到小数 (560)), Height), 560, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_display (Image)
p_set_font (WindowHandle)

disp_message (WindowHandle, “Measure the leads of an IC”, “window”, -1, -1, “black”, “true”)
wait_seconds (2)
视_设值 (Row, 47)
视_设值 (Column, 485)
视_设值 (Phi, 0)
视_设值 (Length1, 420)
视_设值 (Length2, 10)
dev_display (Image)
dev_set_color (“green”)
dev_set_draw (“margin”)
dev_set_line_width (3)
gen_rectangle2 (Rectangle, Row, Column, Phi, Length1, Length2)
gen_measure_rectangle2 (Row, Column, Phi, Length1, Length2, Width, Height, “nearest_neighbor”, MeasureHandle)
dev_display (Rectangle)
wait_seconds (1)
视_设值 (n, 100)
count_seconds (Seconds1)
.变量循环首 (1, DD (n, ), 1, i)
    measure_pairs (Image, MeasureHandle, 1.5, 30, “negative”, “all”, RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, LeadWidth, LeadDistance)
.变量循环尾 ()
count_seconds (Seconds2)
视_设值 (Time, 视_减 (Seconds2, Seconds1))
wait_seconds (1)
dev_set_color (“red”)
disp_line (WindowHandle, RowEdgeFirst, ColumnEdgeFirst, RowEdgeSecond, ColumnEdgeSecond)
视_设值 (avgLeadWidth, 视_除 (sum (LeadWidth), 视_取元素总数 (LeadWidth)))
视_设值 (avgLeadDistance, 视_除 (sum (LeadDistance), 视_取元素总数 (LeadDistance)))
视_设值 (numLeads, 视_取元素总数 (LeadWidth))
视_设值 (Message, G (视_加 (“Number of leads:      ”, 视_文本格式化 (numLeads, “.2”)), 视_加 (视_加 (“Average lead width:    ”, 视_文本格式化 (avgLeadWidth, “4.2f”)), “px”), 视_加 (视_加 (“Average lead distance: ”, 视_文本格式化 (avgLeadDistance, “4.2f”)), “px”)))
disp_message (WindowHandle, Message, “window”, 70, 70, “black”, “true”)
wait_seconds (5)
' * draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2)
视_设值 (Row1, 0)
视_设值 (Column1, 600)
视_设值 (Row2, 100)
视_设值 (Column2, 700)
dev_set_color (“blue”)
disp_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2)
wait_seconds (1)
dev_set_part (Row1, Column1, Row2, Column2)
dev_display (Image)
dev_set_color (“green”)
dev_display (Rectangle)
dev_set_color (“red”)
disp_line (WindowHandle, RowEdgeFirst, ColumnEdgeFirst, RowEdgeSecond, ColumnEdgeSecond)
wait_seconds (3)
close_measure (MeasureHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
dev_set_draw (“fill”)
dev_set_line_width (1)
dev_close_window ()


返回 ()

.子程序 p_do_textline_orientation
.局部变量 Column1, tuple
.局部变量 Column11, tuple
.局部变量 Column2, tuple
.局部变量 Column21, tuple
.局部变量 ConnectedDots, obj
.局部变量 ConnectedLines, obj
.局部变量 ConnectedRegions, obj
.局部变量 ConnectedRegions2, obj
.局部变量 Deviation, tuple
.局部变量 ElementOfLines, obj
.局部变量 Image, obj
.局部变量 ImageDots, obj
.局部变量 ImageRotate, obj
.局部变量 ImageScaleMax, obj
.局部变量 J, tuple
.局部变量 Mean, tuple
.局部变量 OrientationAngle, tuple
.局部变量 Rectangle1, obj
.局部变量 RectangularShape, obj
.局部变量 RegionClosing, obj
.局部变量 RegionDilation, obj
.局部变量 RegionDots, obj
.局部变量 RegionThresh, obj
.局部变量 RegionUnion, obj
.局部变量 RegionUnion3, obj
.局部变量 Row1, tuple
.局部变量 Row11, tuple
.局部变量 Row2, tuple
.局部变量 Row21, tuple
.局部变量 SelectedDots, obj
.局部变量 SelectedLines, obj
.局部变量 SelectedRegions, obj
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型


dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (1)
视_设值 (J, 1)
.变量循环首 (1, 25, 1, i)
    read_image (Image, 视_加 (“dot_print_rotated/dot_print_rotated_”, 视_文本格式化 (J, “02d”)))

    .如果 (视_小于 (i, 5))
        dev_display (Image)
        disp_message (WindowHandle, “Text Line Orientation”, “window”, -1, -1, “black”, “true”)
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束
    ' *     wait_seconds (1)
    text_line_orientation (Image, Image, 50, rad (-30), rad (30), OrientationAngle)
    rotate_image (Image, ImageRotate, 视_乘 (视_除 (－DD (OrientationAngle, ), rad (180)), 180), “constant”)

    dots_image (ImageRotate, ImageDots, 3, “dark”, 2)
    scale_image_max (ImageDots, ImageScaleMax)
    intensity (ImageRotate, ImageRotate, Mean, Deviation)
    threshold (ImageScaleMax, RegionThresh, 视_减 (Mean, 25), 255)
    connection (RegionThresh, ConnectedDots)
    select_shape (ConnectedDots, SelectedDots, “area”, “and”, 5, 300)
    closing_circle (RegionThresh, RegionClosing, 9.5)
    connection (RegionClosing, ConnectedRegions)
    ' Connect splitted parts
    smallest_rectangle1 (ConnectedRegions, Row11, Column11, Row21, Column21)
    gen_rectangle1 (Rectangle1, Row11, Column11, Row21, Column21)
    union1 (Rectangle1, RegionUnion3)
    connection (RegionUnion3, ConnectedRegions2)
    select_shape (ConnectedRegions2, SelectedRegions, G (“area”, “height”, “width”), “and”, G (1000, 30, 20), G (3200, 70, 70))
    ' Get rectangular shape
    smallest_rectangle1 (SelectedRegions, Row1, Column1, Row2, Column2)
    gen_rectangle1 (RectangularShape, Row1, Column1, Row2, Column2)
    ' Build lines
    union1 (SelectedRegions, RegionUnion)
    dilation_rectangle1 (RegionUnion, RegionDilation, 50, 1)
    connection (RegionDilation, ConnectedLines)
    select_shape (ConnectedLines, SelectedLines, “area”, “and”, 10000, 99999)
    ' Element of lines
    intersection (SelectedLines, RectangularShape, ElementOfLines)
    intersection (ElementOfLines, SelectedDots, RegionDots)
    dev_clear_window ()
    dev_display (ImageRotate)
    disp_message (WindowHandle, “Text Line Orientation”, “window”, -1, -1, “black”, “true”)
    ' *     dev_set_colored (12)
    dev_set_draw (“margin”)
    dev_set_color (“blue”)
    dev_display (ElementOfLines)
    dev_set_color (“green”)
    dev_set_draw (“fill”)
    dev_display (RegionDots)
    .如果 (视_小于 (i, 5))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束
    视_设值 (J, 视_加 (J, 1))
    .如果 (视_大于 (J, 5))
        视_设值 (J, 1)
    .否则

    .如果结束
    ' *     wait_seconds (1)
.变量循环尾 ()
wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_novelty_detection_gmm
.局部变量 Centers, tuple
.局部变量 ClassifierFileExists, tuple
.局部变量 Correct, obj
.局部变量 Errors, obj
.局部变量 ErrorsClosing, obj
.局部变量 ErrorsConnected, obj
.局部变量 ErrorsOpening, obj
.局部变量 FinalErrors, obj
.局部变量 GMMClassifierFile, tuple
.局部变量 GMMHandle, tuple
.局部变量 HEXAMPLES, tuple
.局部变量 Height, tuple
.局部变量 Image, obj
.局部变量 ImageTexture, obj
.局部变量 ImageTextureReduced, obj
.局部变量 ImageZoomed, obj
.局部变量 Indices, tuple
.局部变量 Iter, tuple
.局部变量 J, 整数型
.局部变量 NumErrors, tuple
.局部变量 Pointer, tuple
.局部变量 Rectangle, obj
.局部变量 Type, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 true, tuple


' This example program shows you how to use the GMM classifier for novelty
' detection to perform a web inspection task.  To perform the novelty detection,
' all pixels belonging to the single trained class are computed, and are then
' subtracted from the classification ROI to ectract the erroneous pixels.  For
' the web inspection task, the GMM can consequently be used to detect
' textures that do not correspond to the texture of the trained good objects.
dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
read_image (Image, “plastic_mesh/plastic_mesh_01”)
get_image_pointer1 (Image, Pointer, Type, Width, Height)
dev_open_window (0, 0, Width, Height, “black”, WindowHandle)
p_set_font (WindowHandle)
dev_display (Image)
p_write_message (WindowHandle, G (-1), G (-1), G (“Novelty detection with GMM classifier”), 真)
' The texture filters used for the classification will return artifacts at the image
' borders because the images of the plastic mesh to be inspected do not
' contain an integer number of mesh cells.  Because this would lead to wrongly
' detected errors at the image borders, we must exclude the area close to the
' image boder from the training and classification.  This is done with the following
' rectangle.  Note that the image is later scaled down by a factor of two.
gen_rectangle1 (Rectangle, 10, 10, 视_减 (视_除 (Height, 2), 11), 视_减 (视_除 (Width, 2), 11))
' Create the GMM classifier.
' Load pretrained classifier if present
视_设值 (HEXAMPLES, environment (“HALCONEXAMPLES”))
.如果 (视_等于 (HEXAMPLES, “”))
    视_设值 (HEXAMPLES, 视_加 (environment (“HALCONROOT”), “/examples”))
.否则

.如果结束
视_设值 (GMMClassifierFile, 视_加 (HEXAMPLES, “/hdevelop/Segmentation/Classification/novelty_detection.gmm”))
file_exists (GMMClassifierFile, ClassifierFileExists)
.如果 (视_是否为真 (ClassifierFileExists))
    ' Read training data of GMM
    p_write_message (WindowHandle, G (45), G (50), G (“Load GMM Classifier...”), 真)
    read_class_gmm (GMMClassifierFile, GMMHandle)
.否则
    ' Train GMM classifier
    p_write_message (WindowHandle, G (45), G (50), G (“Train GMM Classifier...”), 真)
    create_class_gmm (5, 1, G (1, 5), “spherical”, “normalization”, 5, 42, GMMHandle)
    ' The training is based on five images that contain no errors.
    dev_set_color (“red”)
    .变量循环首 (1, 5, 1, J)
        read_image (Image, 视_加 (“plastic_mesh/plastic_mesh_”, 视_文本格式化 (J, “02”)))
        ' The images are zoomed down because the resolution of the mesh is very
        ' high.  This saves a large amount of processing time.
        zoom_image_factor (Image, ImageZoomed, 0.5, 0.5, “constant”)
        ' Generate the texture image.
        gen_texture_image (ImageZoomed, ImageTexture)
        ' Add the samples to the classifier.
        add_samples_image_class_gmm (ImageTexture, Rectangle, GMMHandle, 到小数 (2))
    .变量循环尾 ()
    ' Train classifier
    train_class_gmm (GMMHandle, 1000, 0.001, “training”, 0.0001, Centers, Iter)
.如果结束
dev_set_draw (“margin”)
dev_set_line_width (3)
wait_seconds (1.5)
视_设值 (Indices, G (4, 5, 6, 7, 2, 8, 9, 10, 11, 12, 1, 13, 14, 4, 5, 6, 7, 2, 8, 9, 10, 11, 12, 1, 13, 14))
' Now detect errors in the plastic meshes.
.变量循环首 (0, DD (视_减 (视_取元素总数 (Indices), 1), ), 1, J)
    read_image (Image, 视_加 (“plastic_mesh/plastic_mesh_”, 视_文本格式化 (视_取元素 (Indices, J), “02”)))
    zoom_image_factor (Image, ImageZoomed, 0.5, 0.5, “constant”)
    get_image_pointer1 (ImageZoomed, Pointer, Type, Width, Height)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    gen_texture_image (ImageZoomed, ImageTexture)
    reduce_domain (ImageTexture, Rectangle, ImageTextureReduced)
    ' Classify samples belonging to the trained class with the GMM.
    classify_image_class_gmm (ImageTextureReduced, Correct, GMMHandle, 0.001)
    ' Subtract them from the ROI to obtain the texture errors.
    difference (Rectangle, Correct, Errors)
    ' Postprocess the returned raw errors to remove insignificant parts of the
    ' detected errors.
    opening_circle (Errors, ErrorsOpening, 3.5)
    closing_circle (ErrorsOpening, ErrorsClosing, 10.5)
    connection (ErrorsClosing, ErrorsConnected)
    select_shape (ErrorsConnected, FinalErrors, “area”, “and”, 300, 1000000)
    count_obj (FinalErrors, NumErrors)
    dev_display (ImageZoomed)
    .如果 (视_大于 (NumErrors, 0))
        dev_set_color (“yellow”)
        dev_display (Rectangle)
        dev_set_color (“red”)
        dev_display (FinalErrors)
    .否则
        dev_set_color (“green”)
        dev_display (Rectangle)
    .如果结束
    p_write_message (WindowHandle, G (-1), G (-1), G (“Detect Errors in a Mesh”), 真)
    .如果 (视_大于 (NumErrors, 0))
        disp_message (WindowHandle, “Mesh not OK”, “window”, 45, -1, “red”, “true”)
    .否则
        disp_message (WindowHandle, “Mesh OK”, “window”, 45, -1, “black”, “true”)
    .如果结束
    .如果 (视_小于 (J, 6))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束
    ' *     wait_seconds (1)
.变量循环尾 ()
wait_seconds (2)
dev_close_window ()
clear_class_gmm (GMMHandle)
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 gen_texture_image
.参数 Image, obj
.参数 ImageTexture, obj, 参考
.局部变量 ImageEE, obj
.局部变量 ImageEL, obj
.局部变量 ImageES, obj
.局部变量 ImageLE, obj
.局部变量 ImageLaws, obj
.局部变量 ImageSE, obj

' The texture image is a five-channel image that contains the result of applying
' five different Laws filters, which basically correspond to first and second
' derivatives, and smoothing them sufficiently.
texture_laws (Image, ImageEL, “el”, 5, 5)
texture_laws (Image, ImageLE, “le”, 5, 5)
texture_laws (Image, ImageES, “es”, 1, 5)
texture_laws (Image, ImageSE, “se”, 1, 5)
texture_laws (Image, ImageEE, “ee”, 2, 5)
compose5 (ImageEL, ImageLE, ImageES, ImageSE, ImageEE, ImageLaws)
smooth_image (ImageLaws, ImageTexture, “gauss”, 5)
返回 ()

.子程序 p_do_find_ncc_model_defocused
.局部变量 Angle, tuple
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 ColumnRef, tuple
.局部变量 Height, tuple
.局部变量 HomMat2D, tuple
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 J, tuple
.局部变量 ModelID, tuple
.局部变量 Rectangle, obj
.局部变量 RegionAffineTrans, obj
.局部变量 Row, tuple
.局部变量 RowRef, tuple
.局部变量 Score, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型


' This example program shows how to use HALCON's correlation-based
' matching.  In particular it demonstrates the robustness of this method against
' varying texture and defocus.  The training is applied in a focused image.  The
' matching is performed in images where the distance of the object to the
' camera varies so that the object is out of focus.
dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
read_image (Image, “smd/smd_on_chip_05”)
get_image_size (Image, Width, Height)
dev_open_window (0, 0, Width, Height, “black”, WindowHandle)
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (5)
dev_set_color (“yellow”)
gen_rectangle1 (Rectangle, 175, 156, 440, 460)
dev_display (Image)
dev_display (Rectangle)
disp_message (WindowHandle, “NCC Model for Correlation-Based Matching”, “window”, 50, -1, “black”, “true”)
area_center (Rectangle, Area, RowRef, ColumnRef)
reduce_domain (Image, Rectangle, ImageReduced)
create_ncc_model (ImageReduced, “auto”, 0, 0, “auto”, “use_polarity”, ModelID)
wait_seconds (1)
dev_set_line_width (3)
视_设值 (J, 1)
.变量循环首 (1, 40, 1, i)
    read_image (Image, 视_加 (“smd/smd_on_chip_”, 视_文本格式化 (J, “02”)))
    find_ncc_model (Image, ModelID, 0, 0, 0.5, 1, 0.5, “true”, 0, Row, Column, Angle, Score)
    vector_angle_to_rigid (RowRef, ColumnRef, 0, Row, Column, 0, HomMat2D)
    affine_trans_region (Rectangle, RegionAffineTrans, HomMat2D, “false”)
    dev_display (Image)
    dev_set_color (“green”)
    dev_display (RegionAffineTrans)
    disp_message (WindowHandle, “Matching on image with decreasing focus”, “window”, 50, -1, “black”, “true”)
    .如果 (视_小于 (i, 5))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束
    ' *     wait_seconds (1)
    视_设值 (J, 视_加 (J, 1))
    .如果 (视_大于 (J, 11))
        视_设值 (J, 1)
    .否则

    .如果结束

.变量循环尾 ()
wait_seconds (2)
clear_ncc_model (ModelID)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_3d_position_of_rectangle
.局部变量 Area, tuple
.局部变量 CaltabName, tuple
.局部变量 CamParam, tuple
.局部变量 ClipRegion, tuple
.局部变量 Column, tuple
.局部变量 ConnectedRegions, obj
.局部变量 Dir, tuple
.局部变量 Height, tuple
.局部变量 I, tuple
.局部变量 Image, obj
.局部变量 ImageBorder, obj
.局部变量 ImageMean, obj
.局部变量 Index, 整数型
.局部变量 Objects, obj
.局部变量 PoseSmallField, tuple
.局部变量 RectHeight, tuple
.局部变量 RectWidth, tuple
.局部变量 RectangularRegions, obj
.局部变量 Region, obj
.局部变量 RegionDilation, obj
.局部变量 RegionErosion, obj
.局部变量 RegionFillUp, obj
.局部变量 RegionIntersection, obj
.局部变量 Row, tuple
.局部变量 StoreEmpty, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 ZerosIndices, tuple


' This program demonstrates how to use get_rectangle_pose to
' estimate the pose of rectangular objects in space. After the pose
' of a work sheet is estimated, it is used to draw a frame on top
' of the object. Note that get_rectangle_pose can process only
' contours that can be segmented unambiguously into 4 line segments.
' To preprocess the work sheet in such a way that get_rectangle_pose
' can handle its octangular shape, the intersection points of the
' main sides of the work sheet are added to the contour to be
' processed.

视_设值 (Width, 800)
视_设值 (Height, 800)
视_设值 (RectWidth, 0.09485)
视_设值 (RectHeight, 0.0348)


' initialization

dev_update_window (“off”)
dev_set_draw (“margin”)
get_system (“clip_region”, ClipRegion)
get_system (“store_empty_region”, StoreEmpty)
set_system (“clip_region”, “false”)
set_system (“store_empty_region”, “true”)
dev_open_window (0, 0, 视_乘 (2, 视_除 (Width, 3)), 视_乘 (2, 视_除 (Height, 3)), “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)


' Read the camera calibration.

视_设值 (CaltabName, “caltab_30mm.descr”)
视_设值 (Dir, “metal-parts”)
视_设值 (CamParam, G (0.0136446, 830.197, 4.58317e-006, 4.65e-006, 509.153, 487.791, 800, 800))

dev_set_colored (12)
dev_set_line_width (1)
gen_rectangle1 (ImageBorder, 2, 2, 视_减 (Height, 2), 视_减 (Width, 2))
complement (ImageBorder, ImageBorder)
视_设值 (I, 1)
.变量循环首 (1, 20, 1, Index)
    ' read new image
    read_image (Image, 视_加 (视_加 (Dir, “/work_sheet_”), 视_文本格式化 (I, “.2”)))
    ' extract light objects
    mean_image (Image, ImageMean, 201, 201)
    dyn_threshold (Image, ImageMean, Region, 0, “light”)
    fill_up (Region, RegionFillUp)
    connection (RegionFillUp, ConnectedRegions)
    erosion_circle (ConnectedRegions, RegionErosion, 3.5)
    dilation_circle (RegionErosion, RegionDilation, 3.5)
    select_shape (RegionDilation, Objects, G (“area”, “convexity”, “rectangularity”), “and”, G (2000, 0.9, 0.8), G (4000000, 1, 1))
    ' filter out objects intersecting with the border
    intersection (Objects, ImageBorder, RegionIntersection)
    area_center (RegionIntersection, Area, Row, Column)
    tuple_find (Area, 0, ZerosIndices)
    ' draw the 3D object
    dev_display (Image)
    disp_message (WindowHandle, “Estimate 3D pose”, “window”, 400, -1, “black”, “true”)
    .如果 (视_不等于 (ZerosIndices, -1))
        select_obj (Objects, RectangularRegions, 视_加 (ZerosIndices, 1))
        find_pose_from_region (RectangularRegions, Image, CamParam, WindowHandle, RectWidth, RectHeight, G (“small_detail/cut_edges”), PoseSmallField)
        .如果 (视_大于 (视_取元素总数 (PoseSmallField), 0))
            draw_3D_detail (PoseSmallField, RectWidth, RectHeight, CamParam)
        .否则

        .如果结束

    .否则
    .如果结束
    .如果 (视_小于 (Index, 5))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束
    视_设值 (I, 视_加 (I, 1))
    .如果 (视_大于 (I, 5))
        视_设值 (I, 1)
    .否则

    .如果结束
    ' *     wait_seconds (1)
.变量循环尾 ()
wait_seconds (2)
dev_close_window ()
set_system (“clip_region”, ClipRegion)
set_system (“store_empty_region”, StoreEmpty)
返回 ()

.子程序 draw_3D_detail
.参数 Pose, tuple
.参数 RectWidth, tuple
.参数 RectHeight, tuple
.参数 CamParam, tuple
.局部变量 Bottom, obj
.局部变量 Column, tuple
.局部变量 Cover, obj
.局部变量 Edge, obj
.局部变量 HomMat3D, tuple
.局部变量 J, 整数型
.局部变量 Ofst, tuple
.局部变量 Qx, tuple
.局部变量 Qy, tuple
.局部变量 Qz, tuple
.局部变量 Row, tuple
.局部变量 XCoord, tuple
.局部变量 YCoord, tuple
.局部变量 ZCoord, tuple
.局部变量 hH, tuple
.局部变量 hW, tuple

' draw a box
dev_set_line_width (3)
pose_to_hom_mat3d (Pose, HomMat3D)
视_设值 (hW, 视_除 (RectWidth, 2))
视_设值 (hH, 视_除 (RectHeight, 2))
视_设值 (Ofst, 0.005)
视_设值 (XCoord, G (hW, 视_减 (hW, Ofst), 视_加 (－DD (hW, ), Ofst), －DD (hW, ), －DD (hW, ), 视_加 (－DD (hW, ), Ofst), 视_减 (hW, Ofst), hW, hW))
视_设值 (XCoord, G (XCoord, XCoord))
视_设值 (YCoord, G (视_减 (hH, Ofst), hH, hH, 视_减 (hH, Ofst), 视_加 (－DD (hH, ), Ofst), －DD (hH, ), －DD (hH, ), 视_加 (－DD (hH, ), Ofst), 视_减 (hH, Ofst)))
视_设值 (YCoord, G (YCoord, YCoord))
tuple_gen_const (9, 0.01, ZCoord)
视_设值 (ZCoord, G (ZCoord, 0, 0, 0, 0, 0, 0, 0, 0, 0))
affine_trans_point_3d (HomMat3D, XCoord, YCoord, ZCoord, Qx, Qy, Qz)
project_3d_point (Qx, Qy, Qz, CamParam, Row, Column)
gen_contour_polygon_xld (Cover, 视_取元素范围 (Row, 9, 17), 视_取元素范围 (Column, 9, 17))
dev_set_color (“blue”)
dev_display (Cover)
dev_set_color (“red”)
.变量循环首 (0, 8, 1, J)
    gen_contour_polygon_xld (Edge, G (视_取元素 (Row, J), 视_取元素 (Row, 视_加 (J, 9))), G (视_取元素 (Column, J), 视_取元素 (Column, 视_加 (J, 9))))
    dev_display (Edge)
.变量循环尾 ()
gen_contour_polygon_xld (Bottom, 视_取元素范围 (Row, 0, 8), 视_取元素范围 (Column, 0, 8))
dev_set_color (“green”)
dev_display (Bottom)
返回 ()

.子程序 find_pose_from_region
.参数 RectangularRegions, obj
.参数 Image, obj
.参数 CamParam, tuple
.参数 WindowHandle, tuple
.参数 RectWidth, tuple
.参数 RectHeight, tuple
.参数 FileName, tuple
.参数 PoseOut, tuple, 参考
.局部变量 ClosedContours, obj
.局部变量 Col, tuple
.局部变量 ColBegin, tuple
.局部变量 ColEdge, tuple
.局部变量 ColEnd, tuple
.局部变量 Cols, tuple
.局部变量 ContoursSplit, obj
.局部变量 Cross, obj
.局部变量 Dist, tuple
.局部变量 Edge, obj
.局部变量 Edges, obj
.局部变量 Error, tuple
.局部变量 ErrorAgain, tuple
.局部变量 ErrorVar, tuple
.局部变量 FinalCol, tuple
.局部变量 FinalRow, tuple
.局部变量 HomMat3D, tuple
.局部变量 I, 整数型
.局部变量 ImageReduced, obj
.局部变量 IsParallel, tuple
.局部变量 J, 整数型
.局部变量 Nc, tuple
.局部变量 Nr, tuple
.局部变量 Number, tuple
.局部变量 NumberEdges, tuple
.局部变量 NumberFilteredEdges, tuple
.局部变量 Pose, tuple
.局部变量 PoseCov, tuple
.局部变量 Poses, tuple
.局部变量 Quadrangle, obj
.局部变量 Qx, tuple
.局部变量 Qy, tuple
.局部变量 Qz, tuple
.局部变量 RectBorders, obj
.局部变量 RectDilated, obj
.局部变量 RectEroded, obj
.局部变量 RectSelected, obj
.局部变量 Row, tuple
.局部变量 RowBegin, tuple
.局部变量 RowEdge, tuple
.局部变量 RowEnd, tuple
.局部变量 Rows, tuple
.局部变量 SelectedEdges, obj
.局部变量 UnionContours, obj

dev_set_check (“~give_error”)
dev_error_var (ErrorVar, 1)
视_设值 (PoseOut, G ())
' -------- reduce the image to the border of the region and extract edges --------
dilation_rectangle1 (RectangularRegions, RectDilated, 9, 9)
erosion_rectangle1 (RectangularRegions, RectEroded, 9, 9)
difference (RectDilated, RectEroded, RectBorders)
select_shape (RectBorders, RectBorders, “area”, “and”, 600, 99999)
count_obj (RectBorders, Number)
.变量循环首 (1, DD (Number, ), 1, I)
    select_obj (RectBorders, RectSelected, I)
    reduce_domain (Image, RectSelected, ImageReduced)
    ' -------- extract contours and make them quadrangular -----------
    edges_sub_pix (ImageReduced, Edges, “canny”, 0.7, 20, 30)
    count_obj (Edges, NumberEdges)
    .如果 (视_等于 (NumberEdges, 0))
        返回 ()
    .否则

    .如果结束
    segment_contours_xld (Edges, ContoursSplit, “lines”, 7, 4, 2)
    select_contours_xld (ContoursSplit, SelectedEdges, “contour_length”, 70, 1000, -0.5, 0.5)
    union_adjacent_contours_xld (SelectedEdges, UnionContours, 10, 1, “attr_keep”)
    count_obj (UnionContours, NumberFilteredEdges)
    .如果 (视_不等于 (NumberFilteredEdges, 4))
        返回 ()
    .否则

    .如果结束
    fit_line_contour_xld (UnionContours, “tukey”, -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)
    ' -------- find intersection points [Rows; Cols] --------
    视_设值 (Rows, G ())
    视_设值 (Cols, G ())
    .变量循环首 (0, 3, 1, J)
        intersection_ll (视_取元素 (RowBegin, J), 视_取元素 (ColBegin, J), 视_取元素 (RowEnd, J), 视_取元素 (ColEnd, J), 视_取元素 (RowBegin, 视_求模 (视_加 (J, 1), 4)), 视_取元素 (ColBegin, 视_求模 (视_加 (J, 1), 4)), 视_取元素 (RowEnd, 视_求模 (视_加 (J, 1), 4)), 视_取元素 (ColEnd, 视_求模 (视_加 (J, 1), 4)), Row, Col, IsParallel)
        gen_cross_contour_xld (Cross, Row, Col, 6, 0.785398)
        视_设值 (Rows, G (Rows, Row))
        视_设值 (Cols, G (Cols, Col))
    .变量循环尾 ()
    ' -------- merge points --------
    视_设值 (FinalRow, G ())
    视_设值 (FinalCol, G ())
    .变量循环首 (1, 4, 1, J)
        select_obj (SelectedEdges, Edge, J)
        get_contour_xld (Edge, RowEdge, ColEdge)
        视_设值 (FinalRow, G (FinalRow, 视_取元素范围 (RowEdge, 5, 视_减 (视_取元素总数 (RowEdge), 5)), 视_取元素 (Rows, 视_减 (J, 1))))
        视_设值 (FinalCol, G (FinalCol, 视_取元素范围 (ColEdge, 5, 视_减 (视_取元素总数 (ColEdge), 5)), 视_取元素 (Cols, 视_减 (J, 1))))
    .变量循环尾 ()
    gen_contour_polygon_xld (Quadrangle, FinalRow, FinalCol)
    ' -------- process contour ---------------
    ' *     dev_set_color ('medium slate blue')
    ' *     dev_display (Quadrangle)
    count_obj (Quadrangle, NumberEdges)
    .如果 (视_大于 (NumberEdges, 0))
        close_contours_xld (Quadrangle, ClosedContours)
        get_rectangle_pose (ClosedContours, CamParam, RectWidth, RectHeight, “tukey”, 2, Poses, PoseCov, Error)
        视_设值 (ErrorAgain, ErrorVar)
        .如果 (视_等于 (ErrorAgain, #视_错误代码_无错误))
            ' -------- store pose ----------------
            视_设值 (Pose, 视_取元素范围 (Poses, 0, 6))
            pose_to_hom_mat3d (Pose, HomMat3D)
            affine_trans_point_3d (HomMat3D, G (0, 0), G (0, 0), G (0, 1), Qx, Qy, Qz)
            ' invert (if necessary) direction of z axis to point towards the camera
            .如果 (视_大于 (视_减 (视_取元素 (Qz, 1), 视_取元素 (Qz, 0)), 0))
                视_tuple元素赋值 (Pose, 4, 视_加 (视_取元素 (Pose, 4), 180))
                视_tuple元素赋值 (Pose, 5, －DD (视_取元素 (Pose, 5), ))
            .否则

            .如果结束
            视_设值 (PoseOut, G (PoseOut, Pose))
        .否则

        .如果结束

    .否则
    .如果结束

.变量循环尾 ()
dev_error_var (ErrorVar, 0)
dev_set_check (“give_error”)
返回 ()

.子程序 p_do_optical_flow_bicycle
.局部变量 Alpha, tuple
.局部变量 Area, tuple
.局部变量 CCenterNew, tuple
.局部变量 Col, obj
.局部变量 ConnectedRegions, obj
.局部变量 ConvexHullregion, obj
.局部变量 Deviation, tuple
.局部变量 Deviation1, tuple
.局部变量 EmptyRegion, tuple
.局部变量 Error, tuple
.局部变量 ErrorVar, tuple
.局部变量 GrayImage1ROI, obj
.局部变量 ImHeight, tuple
.局部变量 ImWidth, tuple
.局部变量 Image1, obj
.局部变量 Image1ROI, obj
.局部变量 Image2, obj
.局部变量 Image2ROI, obj
.局部变量 LengthImage, obj
.局部变量 Max, tuple
.局部变量 MeanCol, tuple
.局部变量 MeanL, tuple
.局部变量 MeanLength, tuple
.局部变量 MeanRow, tuple
.局部变量 Min, tuple
.局部变量 NoObjectResult, tuple
.局部变量 RCenterNew, tuple
.局部变量 ROI, obj
.局部变量 Range, tuple
.局部变量 RegionMovement, obj
.局部变量 RegionMovementInROI, obj
.局部变量 RegionROI, obj
.局部变量 Row, obj
.局部变量 StoreEmpty, tuple
.局部变量 VectorField, obj
.局部变量 VectorReduced, obj
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型


' This example demonstrates the use of the optical flow for
' the detection of moving objects in an image sequence.
' The region of interest is analyzed to detect moving objects.
' If a moving object is detected, the exit gate is opened automatically.

dev_update_pc (“off”)
dev_update_var (“off”)
dev_update_window (“off”)
dev_error_var (ErrorVar, 1)
get_system (“no_object_result”, NoObjectResult)
get_system (“empty_region_result”, EmptyRegion)
get_system (“store_empty_region”, StoreEmpty)
set_system (“no_object_result”, “true”)
set_system (“empty_region_result”, “true”)
set_system (“store_empty_region”, “true”)

' Generate ROI
gen_contour_polygon_xld (ROI, G (0, 0, 283, 348, 479, 479), G (0, 379, 379, 434, 639, 0))
gen_region_contour_xld (ROI, RegionROI, “filled”)

' Initialize output window
read_image (Image1, “bicycle/bicycle_01”)
get_image_size (Image1, ImWidth, ImHeight)
dev_open_window (0, 0, ImWidth, ImHeight, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (视_除 (ImHeight, 2), 1), 视_减 (视_除 (ImWidth, 2), 1))
p_set_font (WindowHandle)

dev_set_draw (“margin”)
' Prepare first image for calculation of optical flow
reduce_domain (Image1, RegionROI, GrayImage1ROI)
zoom_region (RegionROI, RegionROI, 0.5, 0.5)
zoom_image_factor (Image1, Image1, 0.5, 0.5, “constant”)
.变量循环首 (1, 27, 1, i)
    read_image (Image2, 视_加 (“bicycle/bicycle_”, 视_文本格式化 (i, “.2”)))

    ' Zoom images for calculation of optical flow
    zoom_image_factor (Image2, Image2, 0.5, 0.5, “constant”)
    reduce_domain (Image2, RegionROI, Image2ROI)
    reduce_domain (Image1, RegionROI, Image1ROI)

    optical_flow_mg (Image1ROI, Image2ROI, VectorField, “fdrig”, 0.8, 1, 10, 5, G (“default_parameters”, “warp_zoom_factor”), G (“fast”, 0.8))
    vector_field_length (VectorField, LengthImage, “squared_length”)

    ' Segment regions with moving objects in the defined ROI
    min_max_gray (RegionROI, LengthImage, 0.1, Min, Max, Range)
    dev_set_check (“~give_error”)
    threshold (LengthImage, RegionMovement, 2, Max)
    视_设值 (Error, ErrorVar)
    dev_set_check (“give_error”)
    .如果 (视_不等于 (#视_错误代码_无错误, Error))
        到循环尾 ()
    .否则

    .如果结束
    connection (RegionMovement, ConnectedRegions)
    ' Select largest moving region
    select_shape_std (ConnectedRegions, RegionMovement, “max_area”, 70)
    area_center (RegionMovement, Area, RCenterNew, CCenterNew)
    .如果 (视_大于 (Area, 0))
        shape_trans (RegionMovement, ConvexHullregion, “convex”)
        intersection (RegionROI, ConvexHullregion, RegionMovementInROI)
        reduce_domain (VectorField, ConvexHullregion, VectorReduced)
        vector_field_to_real (VectorReduced, Row, Col)

        ' Estimate the movement direction and the speed
        intensity (RegionMovementInROI, Row, MeanRow, Deviation)
        intensity (RegionMovementInROI, Col, MeanCol, Deviation1)
        视_设值 (MeanLength, sqrt (视_加 (视_乘 (MeanRow, MeanRow), 视_乘 (MeanCol, MeanCol))))
        视_设值 (Alpha, atan (视_除 (MeanRow, MeanCol)))

        ' Display results
        dev_display (Image2)
        ' Display region of interest
        dev_set_line_width (3)
        dev_set_color (“green”)
        dev_display (RegionROI)
        disp_message (WindowHandle, “Estimate moving direction and speed”, “window”, -1, -1, “black”, “true”)
        dev_set_line_width (1)
        dev_set_color (“yellow”)
        dev_display (VectorReduced)
        ' Display region of moving object in the region of interest
        dev_set_line_width (3)
        dev_set_color (“magenta”)
        dev_display (RegionMovementInROI)
        disp_arrow (WindowHandle, RCenterNew, CCenterNew, 视_加 (RCenterNew, 视_乘 (MeanLength, sin (Alpha))), 视_加 (CCenterNew, 视_乘 (MeanLength, cos (Alpha))), 1)
    .否则
        dev_display (Image2)
        视_设值 (MeanL, 0)
        disp_message (WindowHandle, “Estimate moving direction and speed”, “window”, -1, -1, “black”, “true”)
    .如果结束

    copy_obj (Image2, Image1, 1, 1)
.变量循环尾 ()
wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
set_system (“no_object_result”, NoObjectResult)
set_system (“empty_region_result”, EmptyRegion)
set_system (“store_empty_region”, StoreEmpty)
返回 ()

.子程序 p_do_variation_model_illumination
.局部变量 Area, tuple
.局部变量 BackgroundGVModel, tuple
.局部变量 ColumnModel, tuple
.局部变量 ForegroundGVModel, tuple
.局部变量 Height, tuple
.局部变量 HomMat2DIdentity, tuple
.局部变量 HomMat2DTranslate, tuple
.局部变量 ImageReduced, obj
.局部变量 J, tuple
.局部变量 ModelContours, obj
.局部变量 ModelContoursAffinTrans, obj
.局部变量 ModelID, tuple
.局部变量 ModelImage, obj
.局部变量 RegionBackground, obj
.局部变量 RegionForeground, obj
.局部变量 RegionROI, obj
.局部变量 RowModel, tuple
.局部变量 VarImage, obj
.局部变量 VariationID, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 i, 整数型
.局部变量 rImage, obj


' This example demonstrates the print inspection using
' a variation model. The variation model is trained
' using a single model image. Before applying the print inspection,
' the images are scaled to the same gray value range like the model.

dev_update_window (“off”)
dev_update_pc (“off”)
dev_update_var (“off”)

' Read model image and init visualization
read_image (ModelImage, “cap_illumination/cap_illumination_01”)
get_image_size (ModelImage, Width, Height)
dev_open_window (0, 0, 视_除 (Width, 2), 视_除 (Height, 2), “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
p_set_font (WindowHandle)

' Segment model region
dev_set_window (WindowHandle)
dev_display (ModelImage)
disp_message (WindowHandle, “Model generation...”, “window”, 25, 25, “black”, “true”)
get_model_region (ModelImage, RegionROI, ImageReduced)
area_center (RegionROI, Area, RowModel, ColumnModel)

' Create model for shape-based-matching
create_scaled_shape_model (ImageReduced, “auto”, 0, rad (360), “auto”, 0.8, 1.2, “auto”, “auto”, “use_polarity”, “auto”, “auto”, ModelID)
get_shape_model_contours (ModelContours, ModelID, 1)
' Transform model contours from the original position for visualization
hom_mat2d_identity (HomMat2DIdentity)
hom_mat2d_translate (HomMat2DIdentity, RowModel, ColumnModel, HomMat2DTranslate)
affine_trans_contour_xld (ModelContours, ModelContoursAffinTrans, HomMat2DTranslate)

' Create variation model for print inspection
create_variation_model (Width, Height, “byte”, “direct”, VariationID)
' Generate variation image
sobel_amp (ModelImage, VarImage, “sum_abs”, 5)
prepare_direct_variation_model (ModelImage, VarImage, VariationID, G (20, 25), G (1.6, 1.6))

' Get gray value range of the variation model
get_grayval_range (ModelImage, RegionROI, RegionForeground, RegionBackground, BackgroundGVModel, ForegroundGVModel)

wait_seconds (1)

' Perform print inspection
视_设值 (J, 1)
.变量循环首 (1, 30, 1, i)
    read_image (rImage, 视_加 (“cap_illumination/cap_illumination_”, 视_文本格式化 (J, “.2”)))
    inspect_cap (rImage, RegionROI, WindowHandle, ModelID, VariationID, RowModel, ColumnModel, BackgroundGVModel, ForegroundGVModel)
    .如果 (视_小于 (i, 6))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束
    ' *     wait_seconds (1.5)
    视_设值 (J, 视_加 (J, 1))
    .如果 (视_大于 (J, 9))
        视_设值 (J, 1)
    .否则

    .如果结束

.变量循环尾 ()

wait_seconds (2)
clear_shape_model (ModelID)
clear_variation_model (VariationID)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 get_grayval_range
.参数 Image, obj
.参数 RegionROI, obj
.参数 RegionForeground, obj, 参考
.参数 RegionBackground, obj, 参考
.参数 BackgroundGVal, tuple, 参考
.参数 ForegroundGVal, tuple, 参考
.局部变量 DeviationBG, tuple
.局部变量 DeviationFG, tuple
.局部变量 ImageReduced, obj

reduce_domain (Image, RegionROI, ImageReduced)
bin_threshold (ImageReduced, RegionBackground)
difference (RegionROI, RegionBackground, RegionForeground)
intensity (RegionForeground, Image, ForegroundGVal, DeviationFG)
intensity (RegionBackground, Image, BackgroundGVal, DeviationBG)
返回 ()

.子程序 get_model_region
.参数 rImage, obj
.参数 RegionROI, obj, 参考
.参数 ImageReduced, obj, 参考
.局部变量 BrightRegion, obj
.局部变量 Column, tuple
.局部变量 Column1, tuple
.局部变量 Column2, tuple
.局部变量 ConnectedRegions, obj
.局部变量 LabelRectangle, obj
.局部变量 LabelRegion, obj
.局部变量 Radius, tuple
.局部变量 Region, obj
.局部变量 RegionDifference, obj
.局部变量 RegionDilation, obj
.局部变量 RegionIntersection, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 Row2, tuple
.局部变量 SelectedRegions, obj


' Segment label on the cap
bin_threshold (rImage, BrightRegion)
difference (rImage, BrightRegion, RegionDifference)
dilation_circle (RegionDifference, RegionDilation, 1.5)
connection (RegionDilation, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 100, 99999)
union1 (SelectedRegions, LabelRegion)
smallest_circle (LabelRegion, Row, Column, Radius)
smallest_rectangle1 (LabelRegion, Row1, Column1, Row2, Column2)

' Define model region
gen_circle (Region, Row, Column, Radius)
gen_rectangle1 (LabelRectangle, Row1, Column1, Row2, Column2)
intersection (Region, LabelRectangle, RegionIntersection)
dilation_circle (RegionIntersection, RegionROI, 5.5)
reduce_domain (rImage, RegionROI, ImageReduced)
返回 ()

.子程序 inspect_cap
.参数 rImage, obj
.参数 RegionROI, obj
.参数 WindowHandle, tuple
.参数 ModelID, tuple
.参数 VariationID, tuple
.参数 RowModel, tuple
.参数 ColumnModel, tuple
.参数 BackgroundGVModel, tuple
.参数 ForegroundGVModel, tuple
.局部变量 Add, tuple
.局部变量 Angle, tuple
.局部变量 Area, tuple
.局部变量 BackgroundImage, tuple
.局部变量 Column, tuple
.局部变量 ColumnEllipse, tuple
.局部变量 ConnectedRegions, obj
.局部变量 DefectRegionEnlarged, obj
.局部变量 DefectRegions, obj
.局部变量 DefectRegionsClosing, obj
.局部变量 DefectRegionsTrans, obj
.局部变量 Ellipse, obj
.局部变量 EndSeconds, tuple
.局部变量 ForegroundImage, tuple
.局部变量 HomMat2DContour, tuple
.局部变量 HomMat2DImage, tuple
.局部变量 HomMat2DInvert, tuple
.局部变量 ImageAffinTrans, obj
.局部变量 ImageReduced, obj
.局部变量 ImageScaled, obj
.局部变量 ModelContours, obj
.局部变量 ModelContoursTrans, obj
.局部变量 Mult, tuple
.局部变量 NumberRegionDiff, tuple
.局部变量 Phi, tuple
.局部变量 Ra, tuple
.局部变量 Rb, tuple
.局部变量 RegionBackgroundImage, obj
.局部变量 RegionClosing, obj
.局部变量 RegionDiff, obj
.局部变量 RegionDiffSelected, obj
.局部变量 RegionForegroundImage, obj
.局部变量 RegionOpening, obj
.局部变量 RegionUnion, obj
.局部变量 Row, tuple
.局部变量 RowEllipse, tuple
.局部变量 Scale, tuple
.局部变量 Score, tuple
.局部变量 StartSeconds, tuple
.局部变量 TimeObjSearch, tuple
.局部变量 TimePrintInspect, tuple
.局部变量 i, 整数型


' Find shape model in the input image
count_seconds (StartSeconds)
find_scaled_shape_model (rImage, ModelID, 0, rad (360), 0.98, 1.02, 0.4, 1, 1, “least_squares_high”, G (5, 3), 0.9, Row, Column, Angle, Scale, Score)
count_seconds (EndSeconds)
视_设值 (TimeObjSearch, 视_减 (EndSeconds, StartSeconds))

get_shape_model_contours (ModelContours, ModelID, 1)

.如果 (视_大于 (视_取元素总数 (Row), 0))

    ' Align the model region and the found label region
    vector_angle_to_rigid (视_取元素 (Row, 0), 视_取元素 (Column, 0), Angle, 视_取元素 (RowModel, 0), 视_取元素 (ColumnModel, 0), 0, HomMat2DImage)
    affine_trans_image (rImage, ImageAffinTrans, HomMat2DImage, “constant”, “false”)
    get_grayval_range (ImageAffinTrans, RegionROI, RegionForegroundImage, RegionBackgroundImage, BackgroundImage, ForegroundImage)

    ' Scale image to the model's gray value range
    视_设值 (Mult, 视_除 (视_减 (ForegroundGVModel, BackgroundGVModel), 视_减 (ForegroundImage, BackgroundImage)))
    视_设值 (Add, 视_减 (ForegroundGVModel, 视_乘 (Mult, ForegroundImage)))
    ' Transform the contours of the models for the visualization
    vector_angle_to_rigid (0, 0, 0, 视_取元素 (Row, 0), 视_取元素 (Column, 0), Angle, HomMat2DContour)
    affine_trans_contour_xld (ModelContours, ModelContoursTrans, HomMat2DContour)
    reduce_domain (ImageAffinTrans, RegionROI, ImageReduced)
    scale_image (ImageReduced, ImageScaled, Mult, Add)

    ' Print Inspection
    count_seconds (StartSeconds)
    compare_ext_variation_model (ImageScaled, RegionDiff, VariationID, “light_dark”)
    count_seconds (EndSeconds)
    ' Analyze bright and dark defect regions
    dev_display (rImage)
    count_obj (RegionDiff, NumberRegionDiff)
    .变量循环首 (1, DD (NumberRegionDiff, ), 1, i)
        select_obj (RegionDiff, RegionDiffSelected, i)
        opening_circle (RegionDiffSelected, RegionOpening, 2.5)
        connection (RegionOpening, ConnectedRegions)
        select_shape (ConnectedRegions, DefectRegions, “height”, “and”, 20, 99999)

        ' Transform regions to the original position in the input image
        hom_mat2d_invert (HomMat2DImage, HomMat2DInvert)
        affine_trans_region (DefectRegions, DefectRegionsTrans, HomMat2DInvert, “false”)
        closing_circle (DefectRegionsTrans, DefectRegionsClosing, 1.5)

        ' Display bright and dark defects using different colors
        dev_set_line_width (2)
        dev_set_draw (“margin”)
        .如果 (视_等于 (i, 1))
            dev_set_color (“red”)
        .否则
            dev_set_color (“orange”)
        .如果结束
        dev_display (DefectRegionsClosing)

        ' Emphasize defect regions
        dev_set_color (“magenta”)
        dev_set_draw (“margin”)
        union1 (DefectRegionsClosing, RegionUnion)
        closing_circle (RegionUnion, RegionClosing, 10)
        connection (RegionClosing, DefectRegionEnlarged)
        elliptic_axis (DefectRegionEnlarged, Ra, Rb, Phi)
        .如果 (视_是否为真 (视_取元素总数 (Phi)))
            area_center (DefectRegionEnlarged, Area, RowEllipse, ColumnEllipse)
            gen_ellipse (Ellipse, RowEllipse, ColumnEllipse, Phi, 视_乘 (Ra, 2), 视_乘 (Rb, 2))
            dev_display (Ellipse)
        .否则

        .如果结束

    .变量循环尾 ()
    dev_set_line_width (1)
    dev_set_color (“green”)
    dev_display (ModelContoursTrans)

    视_设值 (TimePrintInspect, 视_减 (EndSeconds, StartSeconds))
    disp_message (WindowHandle, 视_加 (视_加 (“Inspection Time: ”, 视_文本格式化 (视_乘 (视_加 (TimeObjSearch, TimePrintInspect), 到小数 (1000)), “.04”)), “ ms”), “window”, 460, 250, “black”, “true”)
.否则
    disp_message (WindowHandle, “No shape model found!”, “window”, 460, 250, “blcak”, “true”)
.如果结束

返回 ()

.子程序 p_do_3d_matching_clamps
.局部变量 CamParam, tuple
.局部变量 CovPose, tuple
.局部变量 CovPoseI, tuple
.局部变量 Error, tuple
.局部变量 ErrorVar, tuple
.局部变量 HEXAMPLES, tuple
.局部变量 Height, tuple
.局部变量 I, 整数型
.局部变量 ImHeight, tuple
.局部变量 ImWidth, tuple
.局部变量 Image, obj
.局部变量 ImageNo, 整数型
.局部变量 ModelContours, obj
.局部变量 Pose, tuple
.局部变量 PoseI, tuple
.局部变量 Score, tuple
.局部变量 ScoreI, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 ShapeModel3DFile, tuple
.局部变量 ShapeModel3DID, tuple
.局部变量 Time, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 true, tuple


' This example program shows how to use HALCON's 3D-Matching
' to find the 3D pose of clamps that exhibit a 6 degree of freedom
' motion.


' Set the camera parameters (can be obtained by using camera calibration)
视_设值 (CamParam, G (0.01221, -2791, 7.3958e-006, 7.4e-006, 308.21, 245.92, 640, 480))

视_设值 (Width, 视_取元素 (CamParam, 6))
视_设值 (Height, 视_取元素 (CamParam, 7))
dev_open_window (0, 0, Width, Height, “black”, WindowHandle)
dev_update_window (“off”)
dev_update_var (“off”)
p_set_font (WindowHandle)


read_image (Image, 视_加 (“clamp_sloped/clamp_sloped_”, 视_文本格式化 (1, “02”)))
get_image_size (Image, ImWidth, ImHeight)
dev_set_part (0, 0, 视_减 (ImHeight, 1), 视_减 (ImWidth, 1))
dev_display (Image)

' Load the precomputed 3D shape model if present
视_设值 (HEXAMPLES, environment (“HALCONEXAMPLES”))
.如果 (视_等于 (HEXAMPLES, “”))
    视_设值 (HEXAMPLES, 视_加 (environment (“HALCONROOT”), “/examples”))
.否则

.如果结束
视_设值 (ShapeModel3DFile, 视_加 (HEXAMPLES, “/hdevelop/Applications/Position-Recognition-3D/clamp_sloped_35.sm3”))
disp_message (WindowHandle, “Loading 3D shape model...”, “window”, 10, 10, “black”, “true”)


dev_set_check (“~give_error”)
dev_error_var (ErrorVar, 1)
read_shape_model_3d (ShapeModel3DFile, ShapeModel3DID)
视_设值 (Error, ErrorVar)
dev_set_check (“give_error”)
.如果 (视_不等于 (Error, #视_错误代码_无错误))
    dev_display (Image)
    set_display_font (WindowHandle, 12, “mono”, “true”, “false”)
    disp_message (WindowHandle, G (“Please run the HDevelop program”, ShapeModel3DFile, “to create the 3D shape model!”), “window”, 5, 5, “black”, “true”)
    wait_seconds (2)
    dev_close_window ()
    返回 ()
.否则

.如果结束

dev_set_line_width (2)

' Find instances of a 3D shape model in some run-time images
.变量循环首 (1, 35, 1, ImageNo)
    read_image (Image, 视_加 (“clamp_sloped/clamp_sloped_”, 视_文本格式化 (ImageNo, “02”)))
    count_seconds (Seconds1)
    ' Find up to two instances of the 3D shape model
    find_shape_model_3d (Image, ShapeModel3DID, 0.7, 0.9, 5, G (“num_matches”, “pose_refinement”), G (2, “least_squares_very_high”), Pose, CovPose, Score)
    count_seconds (Seconds2)
    视_设值 (Time, 视_减 (Seconds2, Seconds1))
    视_设值 (Time, 视_减 (Seconds2, Seconds1))
    dev_display (Image)
    write_message (WindowHandle, G (10), G (10), G (视_加 (视_加 (视_加 (视_取元素总数 (Score), “ Match(es) found in ”), 视_文本格式化 (Time, “4.3f”)), “ s”)), 真)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Score), 1), ), 1, I)
        视_设值 (PoseI, 视_取元素范围 (Pose, 视_乘 (I, 7), 视_加 (视_乘 (I, 7), 6)))
        视_设值 (CovPoseI, 视_取元素范围 (CovPose, 视_乘 (I, 6), 视_加 (视_乘 (I, 6), 5)))
        视_设值 (ScoreI, 视_取元素 (Score, I))
        ' Visualize the found matches in the image by projecting the
        ' 3D shape model with the pose of the match
        project_shape_model_3d (ModelContours, ShapeModel3DID, CamParam, PoseI, “true”, 0.523599)
        dev_set_color (“blue”)
        dev_display (ModelContours)
        ' - projecting the coordinate system of the 3D object model
        dev_set_color (“coral”)
        disp_3d_coord_system (WindowHandle, CamParam, PoseI, 0.015)
        ' Display the paramters of the found pose
        dev_set_color (“magenta”)
        display_match_pose (ShapeModel3DID, PoseI, WindowHandle)
    .变量循环尾 ()

    .如果 (视_小于 (ImageNo, 9))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (2)
    .否则

    .如果结束

.变量循环尾 ()

' Free the 3D shape model if it is not longer needed
clear_shape_model_3d (ShapeModel3DID)

wait_seconds (4)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 write_message
.参数 WindowHandle, tuple
.参数 Row, tuple
.参数 Column, tuple
.参数 String, tuple
.参数 WindowCoordinates, 逻辑型
.局部变量 Ascent, tuple
.局部变量 C1, tuple
.局部变量 C1_S, tuple
.局部变量 C2, tuple
.局部变量 C2_S, tuple
.局部变量 Column1Part, tuple
.局部变量 Column2Part, tuple
.局部变量 ColumnWin, tuple
.局部变量 Descent, tuple
.局部变量 DrawMode, tuple
.局部变量 FactorColumn, tuple
.局部变量 FactorRow, tuple
.局部变量 Height, tuple
.局部变量 HeightWin, tuple
.局部变量 R1, tuple
.局部变量 R1_S, tuple
.局部变量 R2, tuple
.局部变量 R2_S, tuple
.局部变量 Row1Part, tuple
.局部变量 Row2Part, tuple
.局部变量 RowWin, tuple
.局部变量 Width, tuple
.局部变量 WidthWin, tuple

get_part (WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part)
get_window_extents (WindowHandle, RowWin, ColumnWin, WidthWin, HeightWin)
.如果 (视_等于 (Row, -1))
    视_设值 (Row, 12)
.否则

.如果结束
.如果 (视_等于 (Column, -1))
    视_设值 (Column, 12)
.否则

.如果结束
视_设值 (String, 视_加 (视_加 (“ ”, String), “ ”))
get_string_extents (WindowHandle, String, Ascent, Descent, Width, Height)
' Adapt Height for different font sizes!
视_设值 (Height, 20)
' Adapt text position and extents because of image zooming
视_设值 (FactorRow, 视_除 (视_乘 (到小数 (1), 视_加 (视_减 (Row2Part, Row1Part), 1)), HeightWin))
视_设值 (FactorColumn, 视_除 (视_乘 (到小数 (1), 视_加 (视_减 (Column2Part, Column1Part), 1)), WidthWin))
get_draw (WindowHandle, DrawMode)
dev_set_draw (“fill”)
.如果 (视_是否为真 (WindowCoordinates))
    dev_set_color (“light gray”)
    视_设值 (R1_S, 视_加 (视_加 (视_乘 (视_加 (Row, 3), FactorRow), 0.5), Row1Part))
    视_设值 (C1_S, 视_加 (视_加 (视_乘 (视_加 (Column, 3), FactorColumn), 0.5), Column1Part))
    视_设值 (R2_S, 视_加 (视_加 (视_乘 (视_减 (视_加 (视_加 (Row, 3), Height), 1), FactorRow), 0.5), Row1Part))
    视_设值 (C2_S, 视_加 (视_加 (视_乘 (视_减 (视_加 (视_加 (Column, 3), Width), 1), FactorColumn), 0.5), Column1Part))
    disp_rectangle1 (WindowHandle, R1_S, C1_S, R2_S, C2_S)
    dev_set_color (“white”)
    视_设值 (R1, 视_加 (视_加 (视_乘 (Row, FactorRow), 0.5), Row1Part))
    视_设值 (C1, 视_加 (视_加 (视_乘 (Column, FactorColumn), 0.5), Column1Part))
    视_设值 (R2, 视_加 (视_加 (视_乘 (视_减 (视_加 (Row, Height), 1), FactorRow), 0.5), Row1Part))
    视_设值 (C2, 视_加 (视_加 (视_乘 (视_减 (视_加 (Column, Width), 1), FactorColumn), 0.5), Column1Part))
    disp_rectangle1 (WindowHandle, R1, C1, R2, C2)
    dev_set_color (“black”)
    set_tposition (WindowHandle, R1, C1)
.否则
    dev_set_color (“light gray”)
    视_设值 (R1_S, 视_加 (Row, 3))
    视_设值 (C1_S, 视_加 (Column, 3))
    视_设值 (R2_S, 视_加 (视_加 (视_加 (Row, 3), 视_乘 (视_减 (Height, 1), FactorRow)), 0.5))
    视_设值 (C2_S, 视_加 (视_加 (视_加 (Column, 3), 视_乘 (视_减 (Width, 1), FactorColumn)), 0.5))
    disp_rectangle1 (WindowHandle, R1_S, C1_S, R2_S, C2_S)
    dev_set_color (“white”)
    视_设值 (R1, Row)
    视_设值 (C1, Column)
    视_设值 (R2, 视_加 (视_加 (Row, 视_乘 (视_减 (Height, 1), FactorRow)), 0.5))
    视_设值 (C2, 视_加 (视_加 (Column, 视_乘 (视_减 (Width, 1), FactorColumn)), 0.5))
    disp_rectangle1 (WindowHandle, R1, C1, R2, C2)
    dev_set_color (“black”)
    set_tposition (WindowHandle, Row, Column)
.如果结束
write_string (WindowHandle, String)
dev_set_draw (DrawMode)
返回 ()

.子程序 display_match_pose
.参数 ShapeModel3DID, tuple
.参数 Pose, tuple
.参数 WindowHandle, tuple
.局部变量 CamParam, tuple
.局部变量 Column, tuple
.局部变量 HomMat3D, tuple
.局部变量 ReferencePoint, tuple
.局部变量 Row, tuple
.局部变量 X, tuple
.局部变量 Y, tuple
.局部变量 Z, tuple



get_shape_model_3d_params (ShapeModel3DID, “reference_point”, ReferencePoint)
get_shape_model_3d_params (ShapeModel3DID, “cam_param”, CamParam)

' Project the reference point
pose_to_hom_mat3d (Pose, HomMat3D)
affine_trans_point_3d (HomMat3D, 视_取元素 (ReferencePoint, 0), 视_取元素 (ReferencePoint, 1), 视_取元素 (ReferencePoint, 2), X, Y, Z)
project_3d_point (X, Y, Z, CamParam, Row, Column)

' Display the pose at the projected reference point
set_tposition (WindowHandle, Row, 视_减 (Column, 10))
write_string (WindowHandle, “Pose:”)
set_tposition (WindowHandle, 视_加 (Row, 15), Column)
write_string (WindowHandle, 视_加 (视_加 (“X: ”, 视_文本格式化 (视_乘 (1000, 视_取元素 (Pose, 0)), “4.1f”)), “ mm”))
set_tposition (WindowHandle, 视_加 (Row, 30), Column)
write_string (WindowHandle, 视_加 (视_加 (“Y: ”, 视_文本格式化 (视_乘 (1000, 视_取元素 (Pose, 1)), “4.1f”)), “ mm”))
set_tposition (WindowHandle, 视_加 (Row, 45), Column)
write_string (WindowHandle, 视_加 (视_加 (“Z: ”, 视_文本格式化 (视_乘 (1000, 视_取元素 (Pose, 2)), “4.1f”)), “ mm”))
set_tposition (WindowHandle, 视_加 (Row, 60), Column)
write_string (WindowHandle, 视_加 (视_加 (“Alpha: ”, 视_文本格式化 (视_取元素 (Pose, 3), “4.1f”)), “°”))
set_tposition (WindowHandle, 视_加 (Row, 75), Column)
write_string (WindowHandle, 视_加 (视_加 (“Beta: ”, 视_文本格式化 (视_取元素 (Pose, 4), “4.1f”)), “°”))
set_tposition (WindowHandle, 视_加 (Row, 90), Column)
write_string (WindowHandle, 视_加 (视_加 (“Gamma: ”, 视_文本格式化 (视_取元素 (Pose, 5), “4.1f”)), “°”))
返回 ()

.子程序 p_do_locate_engine_parts
.局部变量 C, tuple
.局部变量 CamParNoRad, tuple
.局部变量 CamParam, tuple
.局部变量 ConnectedRegions, obj
.局部变量 ContoursAffinTrans, obj
.局部变量 ContoursTrans, obj
.局部变量 CovPose, tuple
.局部变量 Cross, obj
.局部变量 FoundContour, obj
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 Index, 整数型
.局部变量 Index1, 整数型
.局部变量 Index2, 整数型
.局部变量 IndexList, tuple
.局部变量 ModelCol, tuple
.局部变量 ModelContours, obj
.局部变量 ModelID, tuple
.局部变量 ModelPose, tuple
.局部变量 ModelRow, tuple
.局部变量 ModelWorld, obj
.局部变量 NumberContour, tuple
.局部变量 ObjectCol, tuple
.局部变量 ObjectRow, tuple
.局部变量 ObjectSelected, obj
.局部变量 Pose, tuple
.局部变量 PoseModelPlane, tuple
.局部变量 PoseSelected, tuple
.局部变量 Quality, tuple
.局部变量 R, tuple
.局部变量 Rectangle1, obj
.局部变量 Rectangle2, obj
.局部变量 Region, obj
.局部变量 RegionDilation, obj
.局部变量 RegionUnion, obj
.局部变量 Score, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 SelectedRegions, obj
.局部变量 Time, tuple
.局部变量 TotalTime, tuple
.局部变量 WindowHandle, tuple
.局部变量 WorldX, tuple
.局部变量 WorldY, tuple
.局部变量 WorldZ, tuple
.局部变量 X, tuple
.局部变量 Xc, tuple
.局部变量 Y, tuple
.局部变量 Yc, tuple
.局部变量 Z, tuple
.局部变量 Zc, tuple


dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 512, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (512, 1), 视_减 (640, 1))
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (1)

' Create the ROI
dev_clear_window ()
read_image (Image, “automotive/engine_parts_01”)
dev_display (Image)
gen_rectangle2 (Rectangle1, 285.69, 284.554, -1.66101, 58.923, 17.3983)
gen_rectangle2 (Rectangle2, 282.154, 373.738, -1.50165, 56.3435, 14.8286)
union2 (Rectangle1, Rectangle2, RegionUnion)
reduce_domain (Image, RegionUnion, ImageReduced)
threshold (ImageReduced, Region, 110, 255)
connection (Region, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 500, 3000)
union1 (SelectedRegions, RegionUnion)
dilation_circle (RegionUnion, RegionDilation, 3.5)
reduce_domain (ImageReduced, RegionDilation, ImageReduced)

' Create the deformable model from the reduced image.
dev_display (Image)
视_设值 (CamParam, G (0.0124068, -268.149, 9.30326e-006, 9.3e-006, 290.95, 268.404, 640, 512))
视_设值 (ObjectRow, G (254.344, 253.433, 311.613, 316.545))
视_设值 (ObjectCol, G (284.269, 368.903, 373.356, 286.666))
gen_cross_contour_xld (Cross, ObjectRow, ObjectCol, 6, 0.785398)
视_设值 (WorldX, 视_除 (G (－到小数 (29), 26, 27, －到小数 (30)), 到小数 (1000)))
视_设值 (WorldY, 视_除 (G (-21.5, -19, 19, 19), 到小数 (1000)))
视_设值 (WorldZ, G (到小数 (0), 到小数 (0), 到小数 (0), 到小数 (0)))
vector_to_pose (WorldX, WorldY, WorldZ, ObjectRow, ObjectCol, CamParam, “planar_analytic_svd”, “error”, PoseModelPlane, Quality)
create_planar_calib_deformable_model (ImageReduced, CamParam, PoseModelPlane, 3, 0, rad (360), “auto”, 1, 1, “auto”, 1, 1, “auto”, “none”, “use_polarity”, “auto”, “auto”, G (), G (), ModelID)
get_deformable_model_contours (ModelContours, ModelID, 1)
get_deformable_model_params (ModelID, “model_row”, ModelRow)
get_deformable_model_params (ModelID, “model_col”, ModelCol)
get_deformable_model_params (ModelID, “model_pose”, ModelPose)
change_radial_distortion_cam_par (“preserve_resolution”, CamParam, 0, CamParNoRad)
affine_trans_contour_xld (ModelContours, ContoursAffinTrans, G (1, 0, ModelRow, 0, 1, ModelCol))
contour_to_world_plane_xld (ContoursAffinTrans, ContoursTrans, CamParNoRad, ModelPose, “m”)
count_obj (ContoursTrans, NumberContour)
pose_to_hom_mat3d (ModelPose, HomMat3D)
gen_empty_obj (FoundContour)
.变量循环首 (1, DD (NumberContour, ), 1, Index2)
    select_obj (ContoursTrans, ObjectSelected, Index2)
    get_contour_xld (ObjectSelected, Y, X)
    视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
    affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
    project_3d_point (Xc, Yc, Zc, CamParam, R, C)
    gen_contour_polygon_xld (ModelWorld, R, C)
    concat_obj (FoundContour, ModelWorld, FoundContour)
.变量循环尾 ()

' Set the origin of the model.

set_system (“border_shape_models”, “true”)
' Perform matching
视_设值 (IndexList, G (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 4, 8, 12, 16, 20, 24, 2, 6, 10, 14, 18, 22, 25, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexList), 1), ), 1, Index)
    视_设值 (TotalTime, 0)
    read_image (Image, 视_加 (“automotive/engine_parts_”, 视_文本格式化 (视_取元素 (IndexList, Index), “.02”)))

    ' NumMatches = 0 returns not a specified number of found instances but all found instances. Use NumMatches = 0 if you don't know how many instances are to be found.
    count_seconds (Seconds1)
    find_planar_calib_deformable_model (Image, ModelID, rad (0), rad (360), 1, 1, 1, 1, 0.65, 0, 0, 3, 0.9, G (), G (), Pose, CovPose, Score)
    count_seconds (Seconds2)
    set_system (“flush_graphic”, “false”)
    dev_display (Image)
    dev_set_color (“green”)
    视_设值 (Time, 视_减 (Seconds2, Seconds1))
    视_设值 (TotalTime, 视_加 (TotalTime, Time))
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Score), 1), ), 1, Index1)
        tuple_select_range (Pose, 视_乘 (Index1, 7), 视_减 (视_乘 (视_加 (Index1, 1), 7), 1), PoseSelected)
        pose_to_hom_mat3d (PoseSelected, HomMat3D)
        gen_empty_obj (FoundContour)
        .变量循环首 (1, DD (NumberContour, ), 1, Index2)
            select_obj (ContoursTrans, ObjectSelected, Index2)
            get_contour_xld (ObjectSelected, Y, X)
            视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
            affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
            project_3d_point (Xc, Yc, Zc, CamParam, R, C)
            gen_contour_polygon_xld (ModelWorld, R, C)
            concat_obj (FoundContour, ModelWorld, FoundContour)
        .变量循环尾 ()
        dev_set_line_width (1)
        dev_set_color (“green”)
        dev_display (FoundContour)

        dev_set_line_width (3)
        dev_set_colored (3)
        disp_3d_coord_system (WindowHandle, CamParam, PoseSelected, 0.06)
        disp_message (WindowHandle, 视_加 (视_加 (“Engine parts detected in ”, 视_文本格式化 (视_乘 (TotalTime, 1000), “.4”)), “ ms”), “window”, 10, 10, “black”, “true”)
    .变量循环尾 ()
    .如果 (视_小于 (Index, 6))
        p_disp_pause_sign (WindowHandle, G (2))
        set_system (“flush_graphic”, “true”)
        disp_line (WindowHandle, -101, -101, -99, -99)
        wait_seconds (1)
    .否则
        set_system (“flush_graphic”, “true”)
        disp_line (WindowHandle, -101, -101, -99, -99)
    .如果结束

.变量循环尾 ()
set_system (“border_shape_models”, “false”)
clear_deformable_model (ModelID)


wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_detect_road_signs
.局部变量 AngleStep, tuple
.局部变量 Area, tuple
.局部变量 AreaOfInterest, obj
.局部变量 C, tuple
.局部变量 Channel, tuple
.局部变量 Circle, obj
.局部变量 ColumnBegin, tuple
.局部变量 ColumnEnd, tuple
.局部变量 ContoursProjTrans, obj
.局部变量 Fac, tuple
.局部变量 H, tuple
.局部变量 HFac, tuple
.局部变量 HomMat2D, tuple
.局部变量 Image, obj
.局部变量 ImageAttentionSign, obj
.局部变量 ImageChannel, obj
.局部变量 ImageClosing, obj
.局部变量 ImageDeadEnd, obj
.局部变量 ImageInit, obj
.局部变量 ImageReduced, obj
.局部变量 ImageZoomed, obj
.局部变量 Index, 整数型
.局部变量 Index1, 整数型
.局部变量 Index2, 整数型
.局部变量 ModelContours, obj
.局部变量 ModelContours1, obj
.局部变量 ModelID, tuple
.局部变量 ModelImages, obj
.局部变量 ModelRegions, obj
.局部变量 Models, tuple
.局部变量 OutputString, tuple
.局部变量 R, tuple
.局部变量 Rectangle, obj
.局部变量 Rectangle1, obj
.局部变量 Region, obj
.局部变量 RegionU, obj
.局部变量 RoadSign, tuple
.局部变量 Row, tuple
.局部变量 ScaleCMax, tuple
.局部变量 ScaleCMin, tuple
.局部变量 ScaleRMax, tuple
.局部变量 ScaleRMin, tuple
.局部变量 ScaleRStep, tuple
.局部变量 Score, tuple
.局部变量 Time, tuple
.局部变量 Time1, tuple
.局部变量 Time2, tuple
.局部变量 TotalTime, tuple
.局部变量 WindowHandle, tuple

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (480, 1), 视_减 (640, 1))
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (2)
dev_set_color (“green”)


read_image (ImageAttentionSign, “road_signs/attention_road_sign”)
read_image (ImageInit, “road_signs/street_01”)

视_设值 (Channel, G (3, 1))
' In this example, we significant scalings of the road signs.
视_设值 (ScaleRMin, G (0.5, 0.4))
视_设值 (ScaleRMax, G (0.8, 到小数 (2)))
' One could add anisothropic scaling for the exhaustive search.
' However, this makes detection slower and is not required here.
视_设值 (ScaleCMin, G (到小数 (1), 到小数 (1)))
视_设值 (ScaleCMax, G (到小数 (1), 到小数 (1)))
' Add names to the signs.
视_设值 (RoadSign, G (“Attention”, “Dead end”))
视_设值 (HFac, G (到小数 (47), 到小数 (50)))

' Prepare the attention sign picture for the model
' creation process.
access_channel (ImageAttentionSign, Image, 视_取元素 (Channel, 0))
zoom_image_factor (Image, ImageZoomed, 0.1, 0.1, “weighted”)
inspect_shape_model (ImageZoomed, ModelImages, ModelRegions, 3, 20)
create_planar_uncalib_deformable_model (ImageZoomed, 3, 到小数 (0), 到小数 (0), 0.1, 视_取元素 (ScaleRMin, 0), 视_取元素 (ScaleRMax, 0), 0.05, 到小数 (1), 到小数 (1), 0.5, “none”, “use_polarity”, “auto”, “auto”, G (), G (), ModelID)
视_设值 (Models, ModelID)



read_image (ImageDeadEnd, “road_signs/dead_end_road_sign”)
access_channel (ImageDeadEnd, Image, 视_取元素 (Channel, 1))
gray_closing_shape (Image, ImageClosing, 5, 5, “octagon”)
zoom_image_factor (ImageClosing, ImageZoomed, 0.4, 0.4, “weighted”)
gen_rectangle1 (Rectangle1, 28, 71, 67, 95)


reduce_domain (ImageZoomed, Rectangle1, ImageReduced)
create_planar_uncalib_deformable_model (ImageReduced, 3, 到小数 (0), 到小数 (0), 0.1, 视_取元素 (ScaleRMin, 1), 视_取元素 (ScaleRMax, 1), 0.05, 视_取元素 (ScaleRMin, 1), 视_取元素 (ScaleRMax, 1), 0.1, “none”, “use_polarity”, “auto”, “auto”, G (), G (), ModelID)
get_deformable_model_contours (ModelContours1, ModelID, 1)
get_deformable_model_params (ModelID, “angle_step”, AngleStep)
get_deformable_model_params (ModelID, “scale_r_step”, ScaleRStep)
视_设值 (Models, G (Models, ModelID))

' generate ROI in which the road signs are expected.
' We can discard not significant parts of the image, in which
' no road sign can be located.
gen_rectangle1 (Rectangle, 115, 0, 360, 640)

read_image (Image, “road_signs/street_01”)
dev_display (Image)
' Search in image sequence
.变量循环首 (1, 15, 1, Index)
    视_设值 (OutputString, G ())
    视_设值 (TotalTime, 0)
    read_image (Image, 视_加 (“road_signs/street_”, 视_文本格式化 (Index, “.02”)))
    ' We are using colour images, hence the ROI of the search image
    ' can significantly be reduced based on the colour.
    determine_area_of_interest (Image, Rectangle, AreaOfInterest)
    reduce_domain (Image, AreaOfInterest, ImageReduced)
    set_system (“flush_graphic”, “false”)
    dev_display (Image)

    .变量循环首 (0, DD (视_减 (视_取元素总数 (Models), 1), ), 1, Index2)

        ' Depending on the street sign to be found, we use different color
        ' channles of the image and the operator find_planar_uncalib_deformable_model
        ' with different parameters because of the varying dimensions of the models.
        access_channel (ImageReduced, ImageChannel, 视_取元素 (Channel, Index2))
        count_seconds (Time1)
        find_planar_uncalib_deformable_model (ImageChannel, 视_取元素 (Models, Index2), 0, 0, 视_取元素 (ScaleRMin, Index2), 视_取元素 (ScaleRMax, Index2), 视_取元素 (ScaleCMin, Index2), 视_取元素 (ScaleCMax, Index2), 0.8, 1, 0, 2, 0.4, G (), G (), HomMat2D, Score)
        count_seconds (Time2)
        视_设值 (Time, 视_减 (Time2, Time1))
        视_设值 (TotalTime, 视_加 (TotalTime, Time))

        ' Display found models.
        .如果 (视_是否为真 (视_取元素总数 (HomMat2D)))
            dev_set_color (“green”)
            get_deformable_model_contours (ModelContours, 视_取元素 (Models, Index2), 1)
            projective_trans_contour_xld (ModelContours, ContoursProjTrans, HomMat2D)
            gen_region_contour_xld (ContoursProjTrans, Region, “filled”)
            union1 (Region, RegionU)
            area_center (RegionU, Area, R, C)
            get_region_runs (RegionU, Row, ColumnBegin, ColumnEnd)
            视_设值 (H, 视_减 (max (Row), min (Row)))
            视_设值 (Fac, 视_除 (H, 视_取元素 (HFac, Index2)))
            gen_circle (Circle, R, C, 视_乘 (45, Fac))
            dev_display (Circle)
            gen_circle (Circle, R, C, 视_乘 (50, Fac))
            dev_display (Circle)
            dev_display (ContoursProjTrans)
            .如果 (视_等于 (Index2, 0))
                视_设值 (OutputString, 视_加 (视_加 (“Attention Sign found in ”, 视_文本格式化 (视_乘 (Time, 1000), “.01f”)), “ ms”))
            .否则
                视_设值 (OutputString, 视_加 (视_加 (“Dead End Sign found in ”, 视_文本格式化 (视_乘 (Time, 1000), “.01f”)), “ ms”))
            .如果结束

        .否则
        .如果结束

    .变量循环尾 ()
    disp_message (WindowHandle, OutputString, “window”, 1, 1, “black”, “true”)
    p_disp_pause_sign (WindowHandle, G (2))
    set_system (“flush_graphic”, “true”)
    disp_line (WindowHandle, -101, -101, -99, -99)
    wait_seconds (0.7)
.变量循环尾 ()
set_system (“flush_graphic”, “false”)
dev_display (Image)
dev_set_color (“green”)
dev_display (ContoursProjTrans)
disp_message (WindowHandle, OutputString, “window”, 1, 1, “black”, “true”)
set_system (“flush_graphic”, “true”)
disp_line (WindowHandle, -101, -101, -99, -99)
wait_seconds (2)
' Clean the memory of the models.
.变量循环首 (0, 1, 1, Index1)
    clear_deformable_model (视_取元素 (Models, Index1))
.变量循环尾 ()


wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 determine_area_of_interest
.参数 Image, obj
.参数 Rectangle, obj
.参数 AreaOfInterest, obj, 参考
.局部变量 ColoredAreaOfInterest, obj
.局部变量 HighHue, obj
.局部变量 HighSat, obj
.局部变量 HighSatD, obj
.局部变量 ImageB, obj
.局部变量 ImageDilated, obj
.局部变量 ImageFilled, obj
.局部变量 ImageG, obj
.局部变量 ImageH, obj
.局部变量 ImageR, obj
.局部变量 ImageReduced, obj
.局部变量 ImageS, obj
.局部变量 ImageV, obj

reduce_domain (Image, Rectangle, ImageReduced)
decompose3 (ImageReduced, ImageR, ImageG, ImageB)
trans_from_rgb (ImageR, ImageG, ImageB, ImageH, ImageS, ImageV, “hsv”)
threshold (ImageS, HighSat, 130, 255)
dilation_circle (HighSat, HighSatD, 到小数 (2))
fill_up (HighSatD, HighSatD)
reduce_domain (ImageH, HighSatD, HighHue)
threshold (HighHue, ColoredAreaOfInterest, G (230, 145), G (255, 162))
fill_up (ColoredAreaOfInterest, ImageFilled)
dilation_circle (ImageFilled, ImageDilated, 到小数 (3))
union1 (ImageDilated, AreaOfInterest)
返回 ()

.子程序 p_do_blister_mixed
.局部变量 Area, tuple
.局部变量 Area1, tuple
.局部变量 Centers, tuple
.局部变量 Chambers, obj
.局部变量 ChambersRemaining, obj
.局部变量 ChambersUnion, obj
.局部变量 ClassRegions, obj
.局部变量 Classes, obj
.局部变量 Column, tuple
.局部变量 Column1, tuple
.局部变量 ColumnRef, tuple
.局部变量 ConnectedRegions, obj
.局部变量 CountFinalClass, tuple
.局部变量 Deviation, tuple
.局部变量 FileIndex, 整数型
.局部变量 FinalClasses, obj
.局部变量 GMMHandle, tuple
.局部变量 HomMat2D, tuple
.局部变量 Image, obj
.局部变量 ImageAffinTrans, obj
.局部变量 ImageB, obj
.局部变量 ImageG, obj
.局部变量 ImageR, obj
.局部变量 ImageReduced, obj
.局部变量 Index, 整数型
.局部变量 IndexList, tuple
.局部变量 Iter, tuple
.局部变量 LeftOvers, obj
.局部变量 Mean, tuple
.局部变量 MissingPills, obj
.局部变量 NumClasses, tuple
.局部变量 Number, tuple
.局部变量 ObjectSelected, obj
.局部变量 Phi, tuple
.局部变量 PhiRef, tuple
.局部变量 PillTypeCount, tuple
.局部变量 PillsOfOneType, obj
.局部变量 Region, obj
.局部变量 RegionDifference, obj
.局部变量 RegionTrans, obj
.局部变量 Row, tuple
.局部变量 Row1, tuple
.局部变量 RowRef, tuple
.局部变量 SelectedRegions, obj
.局部变量 Size, tuple
.局部变量 WindowHandle, tuple
.局部变量 WrongNumberOfPills, obj
.局部变量 WrongPills, obj

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 视_乘 (750, 0.854), 视_乘 (478, 0.854), “black”, WindowHandle)
dev_set_part (-10, -15, 视_减 (478, 11), 视_减 (750, 16))
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (2)


read_image (Image, “blister/blister_mixed_reference”)
dev_display (Image)
disp_message (WindowHandle, “Test mixed blister for correct composition”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “... train gmm classifier on pill types   ”, “window”, 38, 12, “black”, “true”)

' First, we extract the content of the blister and pass
' this information on to the gmm classifier
extract_pill_types (Image, Chambers, ChambersUnion, Classes, PhiRef, RowRef, ColumnRef, PillTypeCount)
视_设值 (NumClasses, 视_取元素总数 (PillTypeCount))
create_class_gmm (3, 3, G (1, 5), “spherical”, “normalization”, 10, 42, GMMHandle)
add_samples_image_class_gmm (Image, Classes, GMMHandle, 0)
train_class_gmm (GMMHandle, 100, 0.001, “training”, 0.0001, Centers, Iter)
wait_seconds (2)


' Then, the subsequent blisters are checked for the
' correct pill combination
视_设值 (IndexList, G (1, 2, 3, 4, 5, 1, 6, 7, 8, 9, 10, 11, 12, 3, 6, 9, 12, 2, 4, 8, 10, 1, 5, 7, 11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexList), 1), ), 1, FileIndex)

    ' Align image
    read_image (Image, 视_加 (“blister/blister_mixed_”, 视_文本格式化 (视_取元素 (IndexList, FileIndex), “02”)))
    threshold (Image, Region, 90, 255)
    connection (Region, ConnectedRegions)
    select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 5000, 9999999)
    shape_trans (SelectedRegions, RegionTrans, “convex”)
    orientation_region (RegionTrans, Phi)
    .如果 (视_大于 (abs (Phi), rad (90)))
        视_设值 (Phi, 视_加 (rad (180), Phi))
    .否则

    .如果结束
    area_center (RegionTrans, Area1, Row, Column)
    vector_angle_to_rigid (Row, Column, Phi, RowRef, ColumnRef, PhiRef, HomMat2D)
    affine_trans_image (Image, ImageAffinTrans, HomMat2D, “constant”, “false”)
    reduce_domain (ImageAffinTrans, ChambersUnion, ImageReduced)
    decompose3 (ImageAffinTrans, ImageR, ImageG, ImageB)

    ' Classify pill type for each chamber
    classify_image_class_gmm (ImageReduced, ClassRegions, GMMHandle, 0.005)

    count_obj (ClassRegions, Number)
    gen_empty_obj (FinalClasses)
    connection (Chambers, ChambersRemaining)
    .变量循环首 (DD (Number, ), 1, -1, Index)
        select_obj (ClassRegions, Region, Index)
        intersection (ChambersRemaining, Region, Region)
        select_shape (Region, PillsOfOneType, G (“area”, “width”), “and”, G (200, 40), G (3000, 68))
        difference (ChambersUnion, PillsOfOneType, RegionDifference)
        connection (RegionDifference, ConnectedRegions)
        select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 0, 7868)
        shape_trans (SelectedRegions, SelectedRegions, “convex”)
        union1 (SelectedRegions, SelectedRegions)
        difference (ChambersRemaining, SelectedRegions, ChambersRemaining)
        concat_obj (SelectedRegions, FinalClasses, FinalClasses)
    .变量循环尾 ()


    ' Check for correct pill combination
    gen_empty_obj (MissingPills)
    gen_empty_obj (WrongPills)
    gen_empty_obj (WrongNumberOfPills)
    difference (ChambersUnion, FinalClasses, LeftOvers)
    area_center (LeftOvers, Area, Row1, Column1)
    .如果 (视_大于 (Area, 0))
        connection (LeftOvers, LeftOvers)
        count_obj (LeftOvers, Number)
        .变量循环首 (1, DD (Number, ), 1, Index)
            select_obj (LeftOvers, ObjectSelected, Index)
            intensity (ObjectSelected, ImageB, Mean, Deviation)
            .如果 (视_大于 (Deviation, 40))
                concat_obj (WrongPills, ObjectSelected, WrongPills)
            .否则
                concat_obj (MissingPills, ObjectSelected, MissingPills)
            .如果结束

        .变量循环尾 ()
    .否则

    .如果结束

    ' Compute histogram
    视_设值 (CountFinalClass, G ())
    .变量循环首 (1, DD (NumClasses, ), 1, Index)
        select_obj (FinalClasses, ObjectSelected, Index)
        connection (ObjectSelected, ObjectSelected)
        count_obj (ObjectSelected, Size)
        视_设值 (CountFinalClass, G (CountFinalClass, Size))
    .变量循环尾 ()

    set_system (“flush_graphic”, “false”)
    display_results (ImageAffinTrans, LeftOvers, FinalClasses, WrongPills, CountFinalClass, PillTypeCount, WindowHandle)
    set_system (“flush_graphic”, “true”)
    disp_line (WindowHandle, -101, -101, -99, -99)
    ' Display classification results and output allover statistic
    .如果 (视_小于 (FileIndex, 6))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束

.变量循环尾 ()
clear_class_gmm (GMMHandle)

wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 extract_pill_types
.参数 Image, obj
.参数 Chambers, obj, 参考
.参数 ChambersUnion, obj, 参考
.参数 Classes, obj, 参考
.参数 PhiRef, tuple, 参考
.参数 RowRef, tuple, 参考
.参数 ColumnRef, tuple, 参考
.参数 PillTypeCount, tuple, 参考
.局部变量 Area, tuple
.局部变量 Blister, obj
.局部变量 Column, tuple
.局部变量 ConnectedRegions, obj
.局部变量 I, 整数型
.局部变量 ImageB, obj
.局部变量 ImageG, obj
.局部变量 ImageInvert, obj
.局部变量 ImageR, obj
.局部变量 ImageReduced, obj
.局部变量 J, 整数型
.局部变量 Pattern, obj
.局部变量 PillType1, obj
.局部变量 PillType2, obj
.局部变量 PillType3, obj
.局部变量 Rectangle, obj
.局部变量 Region, obj
.局部变量 RegionHysteresis2, obj
.局部变量 RegionHysteresis3, obj
.局部变量 Row, tuple
.局部变量 SelectedRegions, obj

threshold (Image, Region, 90, 255)
connection (Region, ConnectedRegions)
select_shape (ConnectedRegions, SelectedRegions, “area”, “and”, 5000, 999999)
shape_trans (SelectedRegions, Blister, “convex”)
gen_empty_region (Chambers)
.变量循环首 (0, 4, 1, I)
    视_设值 (Row, 视_加 (107, 视_乘 (I, 70)))
    .变量循环首 (0, 2, 1, J)
        视_设值 (Column, 视_加 (177, 视_乘 (J, 150)))
        gen_rectangle2 (Rectangle, Row, Column, 0, 64, 30)
        concat_obj (Chambers, Rectangle, Chambers)
    .变量循环尾 ()
.变量循环尾 ()
difference (Blister, Chambers, Pattern)
union1 (Chambers, ChambersUnion)
orientation_region (Blister, PhiRef)
视_设值 (PhiRef, 视_加 (rad (180), PhiRef))
area_center (Blister, Area, RowRef, ColumnRef)


' +++ extract pattern for classification +++
select_shape (Chambers, PillType1, “row”, “and”, 1, 145)
union1 (PillType1, PillType1)
select_shape (Chambers, PillType2, “row”, “and”, 145, 270)
union1 (PillType2, PillType2)
select_shape (Chambers, PillType3, “row”, “and”, 270, 390)
union1 (PillType3, PillType3)


' extract colorspace of yellow pills
reduce_domain (Image, PillType1, ImageReduced)
decompose3 (ImageReduced, ImageR, ImageG, ImageB)
threshold (ImageB, Region, 60, 95)

' extract colorspace of red pills
reduce_domain (Image, PillType2, ImageReduced)
decompose3 (ImageReduced, ImageR, ImageG, ImageB)
invert_image (ImageB, ImageInvert)
hysteresis_threshold (ImageInvert, RegionHysteresis2, 190, 200, 5)

' extract colorspace of green pills
reduce_domain (Image, PillType3, ImageReduced)
decompose3 (ImageReduced, ImageR, ImageG, ImageB)
invert_image (ImageB, ImageInvert)
hysteresis_threshold (ImageInvert, RegionHysteresis3, 180, 200, 10)

intersection (Region, PillType1, PillType1)
intersection (RegionHysteresis2, PillType2, PillType2)
视_设值 (PillTypeCount, G (3, 6, 6))
intersection (RegionHysteresis3, PillType3, PillType3)
concat_obj (PillType1, PillType2, Classes)
concat_obj (Classes, PillType3, Classes)
返回 ()

.子程序 display_results
.参数 ImageAffinTrans, obj
.参数 LeftOvers, obj
.参数 FinalClasses, obj
.参数 WrongPills, obj
.参数 CountFinalClass, tuple
.参数 PillTypeCount, tuple
.参数 WindowHandle, tuple
.局部变量 Number, tuple
.局部变量 ObjectSelected, obj
.局部变量 RedLeftOvers, obj
.局部变量 ThereWereErrors, tuple
.局部变量 false, tuple
.局部变量 true, tuple

视_设值 (ThereWereErrors, 假)
dev_clear_window ()
dev_display (ImageAffinTrans)
dev_set_draw (“margin”)
dev_set_line_width (4)
dev_set_color (“red”)
dilation_circle (LeftOvers, RedLeftOvers, 2.5)
dev_display (RedLeftOvers)

dev_set_line_width (3)
select_obj (FinalClasses, ObjectSelected, 1)
dev_set_color (“goldenrod”)
dev_display (ObjectSelected)
select_obj (FinalClasses, ObjectSelected, 3)
dev_set_color (“medium forest green”)
dev_display (ObjectSelected)
select_obj (FinalClasses, ObjectSelected, 2)
dev_set_color (“firebrick”)
dev_display (ObjectSelected)

.如果 (视_不等于 (视_取元素 (CountFinalClass, 0), 视_取元素 (PillTypeCount, 0)))
    disp_message (WindowHandle, “# Pill type ” ＋ #引号 ＋ “yellow” ＋ #引号 ＋ “: ”, “window”, 0, 0, “black”, “true”)
    disp_message (WindowHandle, 视_取元素 (CountFinalClass, 0), “window”, 0, 视_加 (0, 286), “red”, “true”)
    视_设值 (ThereWereErrors, 真)
.否则
    disp_message (WindowHandle, 视_加 (“# Pill type ” ＋ #引号 ＋ “yellow” ＋ #引号 ＋ “: ”, 视_取元素 (CountFinalClass, 0)), “window”, 0, 0, “black”, “true”)
.如果结束

.如果 (视_不等于 (视_取元素 (CountFinalClass, 2), 视_取元素 (PillTypeCount, 2)))
    disp_message (WindowHandle, “# Pill type ” ＋ #引号 ＋ “green” ＋ #引号 ＋ “ : ”, “window”, 视_加 (0, 25), 0, “black”, “true”)
    disp_message (WindowHandle, 视_取元素 (CountFinalClass, 2), “window”, 视_加 (0, 25), 视_加 (0, 286), “red”, “true”)
    视_设值 (ThereWereErrors, 真)
.否则
    disp_message (WindowHandle, 视_加 (“# Pill type ” ＋ #引号 ＋ “green” ＋ #引号 ＋ “ : ”, 视_取元素 (CountFinalClass, 2)), “window”, 视_加 (0, 25), 0, “black”, “true”)
.如果结束


.如果 (视_不等于 (视_取元素 (CountFinalClass, 1), 视_取元素 (PillTypeCount, 1)))
    disp_message (WindowHandle, “# Pill type ” ＋ #引号 ＋ “red” ＋ #引号 ＋ “   : ”, “window”, 视_加 (0, 50), 0, “black”, “true”)
    disp_message (WindowHandle, 视_取元素 (CountFinalClass, 1), “window”, 视_加 (0, 50), 视_加 (0, 286), “red”, “true”)
    视_设值 (ThereWereErrors, 真)
.否则
    disp_message (WindowHandle, 视_加 (“# Pill type ” ＋ #引号 ＋ “red” ＋ #引号 ＋ “   : ”, 视_取元素 (CountFinalClass, 1)), “window”, 视_加 (0, 50), 0, “black”, “true”)
.如果结束

count_obj (WrongPills, Number)
.如果 (视_大于 (Number, 0))
    disp_message (WindowHandle, 视_加 (“# Wrong pill type   : ”, Number), “window”, 视_加 (0, 75), 0, “red”, “true”)
    视_设值 (ThereWereErrors, 真)
.否则

.如果结束
.如果 (视_是否为真 (ThereWereErrors))
    disp_message (WindowHandle, “Not OK”, “window”, 40, 530, “red”, “true”)
.否则
    disp_message (WindowHandle, “OK”, “window”, 40, 530, “forest green”, “true”)
.如果结束
返回 ()

.子程序 p_do_ecc200_finder_pattern_tolerance
.局部变量 DataCodeHandle, tuple
.局部变量 DecodedDataStrings, tuple
.局部变量 Image, obj
.局部变量 ImageFiles, tuple
.局部变量 ImageFilesTrain, tuple
.局部变量 Index, 整数型
.局部变量 IndexList, tuple
.局部变量 Path, tuple
.局部变量 ResultHandles, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 SymbolXLDs, obj
.局部变量 Time, tuple
.局部变量 WindowHandle, tuple

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (576, 1), 视_减 (768, 1))
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (4)



视_设值 (Path, “datacode/ecc200/”)
视_设值 (ImageFilesTrain, 视_加 (Path, “ecc200_damaged_finder_pattern_training_”))
视_设值 (ImageFiles, 视_加 (Path, “ecc200_damaged_finder_pattern_”))
read_image (Image, 视_加 (ImageFilesTrain, “01”))
set_system (“clock_mode”, “performance_counter”)

' Create a new ECC 200 data code model
dev_display (Image)
disp_message (WindowHandle, “Decode datacode symbols with” ＋ #换行符 ＋ “heavily disturbed finder pattern”, “window”, -1, -1, “black”, “true”)
create_data_code_2d_model (“Data Matrix ECC 200”, G (), G (), DataCodeHandle)
wait_seconds (4)

' Perform the training
.变量循环首 (1, 5, 1, Index)
    read_image (Image, 视_加 (ImageFilesTrain, 视_文本格式化 (Index, “.02”)))
    dev_display (Image)
    disp_message (WindowHandle, 视_加 (“Training datacode sample ”, Index), “window”, -1, -1, “black”, “true”)
    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, “train”, “all”, ResultHandles, DecodedDataStrings)
    dev_set_color (“lime green”)
    dev_display (SymbolXLDs)
    wait_seconds (0.6)
.变量循环尾 ()

dev_display (Image)
disp_message (WindowHandle, “Decode datacode symbols”, “window”, -1, -1, “black”, “true”)
wait_seconds (2.5)
' Perform the recognition
视_设值 (IndexList, G (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 4, 8, 12, 16, 20, 3, 6, 9, 15, 18, 1, 2, 5, 7, 10, 11, 13, 14, 17, 19, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 4, 8, 12, 16, 20, 3, 6, 9, 15, 18, 1, 2, 5, 7, 10, 11, 13, 14, 17, 19))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexList), 1), ), 1, Index)
    read_image (Image, 视_加 (ImageFiles, 视_文本格式化 (视_取元素 (IndexList, Index), “.02”)))
    dev_display (Image)
    count_seconds (Seconds1)
    find_data_code_2d (Image, SymbolXLDs, DataCodeHandle, G (), G (), ResultHandles, DecodedDataStrings)
    count_seconds (Seconds2)
    视_设值 (Time, 视_乘 (视_减 (Seconds2, Seconds1), 到小数 (1000)))
    dev_set_color (“lime green”)
    dev_display (SymbolXLDs)
    .如果 (视_大于 (视_取元素总数 (DecodedDataStrings), 0))
        disp_message (WindowHandle, G (视_加 (视_加 (“Decoded Symbol in ”, 视_文本格式化 (Time, “.1f”)), “ ms”), 视_加 (“Symbol: ”, DecodedDataStrings)), “window”, -1, -1, “black”, “true”)
    .否则
        disp_message (WindowHandle, 视_加 (视_加 (“No Symbol found (in ”, 视_文本格式化 (Time, “.1f”)), “ ms )”), “window”, -1, -1, “black”, “true”)
    .如果结束
    .如果 (视_小于 (Index, 5))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
    .否则

    .如果结束

.变量循环尾 ()

' Clear the data code model
clear_data_code_2d_model (DataCodeHandle)


wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_bottle_mouth
.局部变量 Circle, obj
.局部变量 Column, tuple
.局部变量 Connection, obj
.局部变量 ContoursSplit, obj
.局部变量 DarkRegion, obj
.局部变量 Edges, obj
.局部变量 EndPhi, tuple
.局部变量 Image, obj
.局部变量 ImageMean, obj
.局部变量 ImagePart, obj
.局部变量 ImagePolar, obj
.局部变量 ImageReduced, obj
.局部变量 ImageRotate, obj
.局部变量 ImageScaleMax, obj
.局部变量 Index, 整数型
.局部变量 IndexList, tuple
.局部变量 Length, tuple
.局部变量 LongestContour, obj
.局部变量 MinDefectSize, tuple
.局部变量 Number, tuple
.局部变量 PointOrder, tuple
.局部变量 PolarResolution, tuple
.局部变量 Radius, tuple
.局部变量 RegionBorder, obj
.局部变量 RegionClosing, obj
.局部变量 RegionClosing1, obj
.局部变量 RegionDifference, obj
.局部变量 RegionDilation, obj
.局部变量 RegionErosion, obj
.局部变量 RegionFillUp, obj
.局部变量 RegionMirror, obj
.局部变量 RegionOpening, obj
.局部变量 RegionUnion, obj
.局部变量 Regions, obj
.局部变量 Regions1, obj
.局部变量 RingSize, tuple
.局部变量 Row, tuple
.局部变量 SelectedRegions, obj
.局部变量 SmoothX, tuple
.局部变量 StartPhi, tuple
.局部变量 StoreEmptyRegion, tuple
.局部变量 ThresholdOffset, tuple
.局部变量 UnionContours, obj
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle1, tuple
.局部变量 XYTransRegion, obj

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 512, “black”, WindowHandle1)
dev_set_part (0, 0, 视_减 (512, 1), 视_减 (640, 1))
p_set_font (WindowHandle1)
dev_set_draw (“margin”)
dev_set_line_width (3)
dev_set_color (“red”)

视_设值 (SmoothX, 501)
视_设值 (ThresholdOffset, 25)
视_设值 (MinDefectSize, 50)

dev_set_window (WindowHandle1)
get_system (“store_empty_region”, StoreEmptyRegion)
set_system (“store_empty_region”, “false”)
read_image (Image, “bottles/bottle_mouth_01”)
dev_display (Image)
disp_message (WindowHandle1, “Check bottle mouth for damages”, “window”, -1, -1, “black”, “true”)
wait_seconds (3)

' initialization
视_设值 (PolarResolution, 640)
视_设值 (RingSize, 70)
dev_open_window (0, 视_减 (648, 128), RingSize, 512, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (PolarResolution, 1), 视_减 (RingSize, 1))

' Main loop

' Detect defects in bottle necks
视_设值 (IndexList, G (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 4, 8, 12, 16, 3, 6, 9, 15, 2, 10, 14, 1, 5, 7, 11, 13, 14, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexList), 1), ), 1, Index)
    read_image (Image, 视_加 (“bottles/bottle_mouth_”, 视_文本格式化 (视_取元素 (IndexList, Index), “.02”)))

    ' Part 1: Use basic morphology to detect bottle
    auto_threshold (Image, Regions, 2)
    select_obj (Regions, DarkRegion, 1)
    opening_circle (DarkRegion, RegionOpening, 3.5)
    closing_circle (RegionOpening, RegionClosing, 25.5)
    fill_up (RegionClosing, RegionFillUp)
    boundary (RegionFillUp, RegionBorder, “outer”)
    dilation_circle (RegionBorder, RegionDilation, 3.5)
    reduce_domain (Image, RegionDilation, ImageReduced)

    ' Find the bottle center by fitting a circle to extracted edges
    edges_sub_pix (ImageReduced, Edges, “canny”, 0.5, 20, 40)
    segment_contours_xld (Edges, ContoursSplit, “lines_circles”, 5, 4, 2)
    union_cocircular_contours_xld (ContoursSplit, UnionContours, 0.9, 0.5, 0.5, 200, 50, 50, “true”, 1)
    length_xld (UnionContours, Length)
    select_obj (UnionContours, LongestContour, 视_加 (视_取元素 (sort_index (Length), 视_减 (视_取元素总数 (Length), 1)), 1))
    fit_circle_contour_xld (LongestContour, “ahuber”, -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)

    ' Part 2: Transform the ring-shaped bottle neck region to a rectangle
    gen_circle (Circle, Row, Column, Radius)
    dilation_circle (Circle, RegionDilation, 5)
    erosion_circle (Circle, RegionErosion, 视_减 (RingSize, 5))
    difference (RegionDilation, RegionErosion, RegionDifference)
    reduce_domain (Image, RegionDifference, ImageReduced)
    polar_trans_image (ImageReduced, ImagePolar, Row, Column, PolarResolution, 视_加 (Radius, 5))

    ' Part 3: Find defects with a dynamic threshold
    ' Note the strong smoothing in x-direction in the transformed image.
    crop_part (ImagePolar, ImagePart, 视_减 (Radius, RingSize), 0, PolarResolution, RingSize)
    scale_image_max (ImagePart, ImageScaleMax)
    mean_image (ImageScaleMax, ImageMean, SmoothX, 3)
    dyn_threshold (ImageScaleMax, ImageMean, Regions1, 50, “not_equal”)
    connection (Regions1, Connection)
    select_shape (Connection, SelectedRegions, “height”, “and”, 9, 99999)
    ' ignore noise regions
    closing_rectangle1 (SelectedRegions, RegionClosing1, 10, 20)
    union1 (RegionClosing1, RegionUnion)
    ' re-transform defect regions for visualization
    polar_trans_region_inv (RegionUnion, XYTransRegion, Row, Column, 6.28319, 0, 视_减 (Radius, RingSize), Radius, 640, RingSize, 1280, 1024, “nearest_neighbor”)

    ' Part 4: Display results
    ' display original image with results
    dev_set_window (WindowHandle1)
    dev_display (Image)
    dev_set_color (“blue”)
    dev_display (RegionDifference)
    dev_set_color (“red”)
    dev_display (XYTransRegion)
    ' display polar transformed inspected region with results
    ' The image and resulting region are rotated by 90 degrees
    ' only for visualization purposes! (I.e. to fit better on the screen)
    ' The rotation is NOT necessary for the detection algorithm.
    dev_set_window (WindowHandle)
    rotate_image (ImagePart, ImageRotate, 90, “constant”)
    dev_display (ImageRotate)
    count_obj (RegionUnion, Number)
    .如果 (视_大于 (Number, 0))
        mirror_region (RegionUnion, RegionMirror, “diagonal”, PolarResolution)
        mirror_region (RegionMirror, RegionMirror, “row”, PolarResolution)
        dev_display (RegionMirror)
        disp_message (WindowHandle1, “Not OK”, “window”, -1, -1, “red”, “false”)
    .否则
        disp_message (WindowHandle1, “OK”, “window”, -1, -1, “forest green”, “false”)
    .如果结束
    .如果 (视_小于 (Index, 6))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (1)
        dev_set_color (“red”)
    .否则

    .如果结束
    wait_seconds (0.07)
.变量循环尾 ()
' Reset system parameters
set_system (“store_empty_region”, StoreEmptyRegion)


wait_seconds (2)
dev_set_window (WindowHandle1)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_cookie_box
.局部变量 CamParam, tuple
.局部变量 Col, tuple
.局部变量 ColTrans, tuple
.局部变量 ColumnsRoi, tuple
.局部变量 Contour, obj
.局部变量 Cross1, obj
.局部变量 DescrModelFile, tuple
.局部变量 DescriptorHandle, tuple
.局部变量 Error, tuple
.局部变量 ErrorVar, tuple
.局部变量 HEXAMPLES, tuple
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 Index, 整数型
.局部变量 IndexList, tuple
.局部变量 OutputString, tuple
.局部变量 Pose, tuple
.局部变量 Quality, tuple
.局部变量 Row, tuple
.局部变量 RowTrans, tuple
.局部变量 RowsRoi, tuple
.局部变量 Score, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 Time, tuple
.局部变量 WindowHandle, tuple
.局部变量 WorldX, tuple
.局部变量 WorldY, tuple
.局部变量 XOuterBox, tuple
.局部变量 XTrans, tuple
.局部变量 YOuterBox, tuple
.局部变量 YTrans, tuple
.局部变量 ZTrans, tuple

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 480, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (480, 1), 视_减 (640, 1))
p_set_font (WindowHandle)
dev_set_draw (“margin”)


read_image (Image, “packaging/cookie_box_01”)
dev_display (Image)

视_设值 (HEXAMPLES, environment (“HALCONEXAMPLES”))
.如果 (视_等于 (HEXAMPLES, “”))
    视_设值 (HEXAMPLES, 视_加 (environment (“HALCONROOT”), “/examples”))
.否则

.如果结束
视_设值 (DescrModelFile, 视_加 (HEXAMPLES, “/hdevelop/Applications/Object-Recognition-2D/cookie_box_model.dsm”))
视_设值 (CamParam, G (0.0155565, -109.42, 1.28008e-005, 1.28e-005, 322.78, 240.31, 640, 480))

disp_message (WindowHandle, “Determine position and orientation” ＋ #换行符 ＋ “of cookie box”, “window”, -1, -1, “black”, “true”)
disp_message (WindowHandle, “Loading descriptor-based model...”, “window”, 60, -1, “black”, “true”)
dev_set_check (“~give_error”)
dev_error_var (ErrorVar, 1)
read_descriptor_model (DescrModelFile, DescriptorHandle)
视_设值 (Error, ErrorVar)
dev_set_check (“give_error”)
.如果 (视_不等于 (Error, #视_错误代码_无错误))
    dev_display (Image)
    disp_message (WindowHandle, G (“Please first run the HDevelop program”, “/Applications//Object-Recognition-2D/locate_cookie_box.hdev ”, “to create the descriptor-based model!”), “window”, 5, 5, “black”, “true”)
    wait_seconds (2)
    dev_close_window ()
    返回 ()
.否则

.如果结束

' reference pose of the object to the camera is computed
视_设值 (RowsRoi, G (224, 224, 406, 406))
视_设值 (ColumnsRoi, G (115, 540, 540, 115))
视_设值 (WorldX, 视_除 (G (-189, 189, 189, -189), 到小数 (1000)))
视_设值 (WorldY, 视_除 (G (-80, -80, 80, 80), 到小数 (1000)))
vector_to_pose (WorldX, WorldY, G (), RowsRoi, ColumnsRoi, CamParam, “iterative”, “error”, Pose, Quality)
image_points_to_world_plane (CamParam, Pose, RowsRoi, ColumnsRoi, “m”, XOuterBox, YOuterBox)



' Main loop:
' search model in image sequence
视_设值 (IndexList, G (1, 2, 4, 5, 6, 7, 8, 9, 10, 2, 4, 6, 8, 10, 1, 5, 7, 9, 6, 8, 5, 10, 1, 2, 5, 7, 9, 3, 6, 8, 4, 5, 10, 2, 1, 4, 5, 6, 7, 8, 9, 10, 2, 4, 6, 8, 1, 5, 7, 9, 6, 2))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexList), 1), ), 1, Index)
    视_设值 (OutputString, G ())
    read_image (Image, 视_加 (“packaging/cookie_box_”, 视_文本格式化 (视_取元素 (IndexList, Index), “.02”)))
    set_system (“flush_graphic”, “false”)
    dev_display (Image)

    ' find model (using default parameters)
    count_seconds (Seconds1)
    find_calib_descriptor_model (Image, DescriptorHandle, G (), G (), G (), G (), 0.25, 1, CamParam, “num_points”, Pose, Score)
    count_seconds (Seconds2)
    视_设值 (Time, 视_减 (Seconds2, Seconds1))

    ' display results
    .如果 (视_大于 (视_取元素总数 (Score), 0))
        get_descriptor_model_points (DescriptorHandle, “search”, 0, Row, Col)
        dev_set_colored (12)
        dev_set_line_width (1)
        gen_cross_contour_xld (Cross1, Row, Col, 6, 0.785398)
        dev_display (Cross1)
        dev_set_line_width (3)
        disp_3d_coord_system (WindowHandle, CamParam, Pose, 0.07)

        pose_to_hom_mat3d (Pose, HomMat3D)
        affine_trans_point_3d (HomMat3D, XOuterBox, YOuterBox, G (0, 0, 0, 0), XTrans, YTrans, ZTrans)
        project_3d_point (XTrans, YTrans, ZTrans, CamParam, RowTrans, ColTrans)


        gen_contour_polygon_xld (Contour, RowTrans, ColTrans)
        close_contours_xld (Contour, Contour)
        dev_set_color (“lime green”)
        dev_display (Contour)

        视_设值 (OutputString, 视_加 (视_加 (“Box located in ”, 视_文本格式化 (视_乘 (Time, 1000), “.4”)), “ ms”))
        ' determine direction of box
    .否则

    .如果结束
    disp_message (WindowHandle, OutputString, “window”, 10, 10, “black”, “true”)
    .如果 (视_小于 (Index, 6))
        p_disp_pause_sign (WindowHandle, G (2))
        set_system (“flush_graphic”, “true”)
        disp_line (WindowHandle, -101, -101, -99, -99)
        wait_seconds (0.95)
    .否则
        set_system (“flush_graphic”, “true”)
        disp_line (WindowHandle, -101, -101, -99, -99)
    .如果结束
    wait_seconds (0.05)
.变量循环尾 ()

' created descriptor model has to be deleted
clear_descriptor_model (DescriptorHandle)


wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_cylinder_3d
.局部变量 CamParam, tuple
.局部变量 CamParam1, tuple
.局部变量 CamParam2, tuple
.局部变量 CamParamMatching, tuple
.局部变量 CamParamRect1, tuple
.局部变量 CamParamRect2, tuple
.局部变量 CamPoseRect1, tuple
.局部变量 CamPoseRect2, tuple
.局部变量 Column, tuple
.局部变量 CovPose, tuple
.局部变量 Disparity, obj
.局部变量 Error, tuple
.局部变量 ErrorVar, tuple
.局部变量 HEXAMPLES, tuple
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 Image1, obj
.局部变量 Image2, obj
.局部变量 ImageEmphasize1, obj
.局部变量 ImageEmphasize2, obj
.局部变量 ImageMapped1, obj
.局部变量 ImageMapped2, obj
.局部变量 Index, tuple
.局部变量 Index2, 整数型
.局部变量 IndexList, tuple
.局部变量 Map1, obj
.局部变量 Map2, obj
.局部变量 ModelContours, obj
.局部变量 Path, tuple
.局部变量 Pose, tuple
.局部变量 ReferencePoint, tuple
.局部变量 RelPose, tuple
.局部变量 RelPoseRect, tuple
.局部变量 Row, tuple
.局部变量 Score, obj
.局部变量 Score_CTRL, tuple
.局部变量 ShapeModel3DID, tuple
.局部变量 TopMost, obj
.局部变量 WindowHandle, tuple
.局部变量 WindowHandleL, tuple
.局部变量 X, tuple
.局部变量 Y, tuple
.局部变量 Z, tuple
.局部变量 tmp, tuple

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
视_设值 (Path, “metal_cylinders/”)


dev_open_window (0, 0, 640, 512, “black”, WindowHandle)
dev_set_window (WindowHandle)
dev_set_part (0, 0, 485, 607)
dev_set_draw (“fill”)
dev_set_color (“blue”)
p_set_font (WindowHandle)

视_设值 (CamParamMatching, G (0.00855613, -2579.17, 5.99979e-006, 6e-006, 399.681, 232.327, 752, 480))
视_设值 (CamParam1, G (0.0121469, -2514.3, 9.30281e-006, 9.3e-006, 272.773, 273.689, 640, 512))
视_设值 (CamParam2, G (0.0121592, -2687.76, 9.30085e-006, 9.3e-006, 302.665, 263.738, 640, 512))
视_设值 (RelPose, G (0.202198, 0.00177953, 0.0376427, 0.325733, 342.295, 359.167, 0))
read_image (Image, 视_加 (Path, “stereo_left_01”))

dev_display (Image)
视_设值 (HEXAMPLES, environment (“HALCONEXAMPLES”))
.如果 (视_等于 (HEXAMPLES, “”))
    视_设值 (HEXAMPLES, 视_加 (environment (“HALCONROOT”), “/examples”))
.否则

.如果结束
disp_message (WindowHandle, “Bin Picking Application” ＋ #换行符 ＋ “combining Stereo, Structured Light” ＋ #换行符 ＋ “and 3D Matching”, “window”, -1, -1, “black”, “true”)
gen_binocular_rectification_map (Map1, Map2, CamParam1, CamParam2, RelPose, 1, “geometric”, “bilinear”, CamParamRect1, CamParamRect2, CamPoseRect1, CamPoseRect2, RelPoseRect)


dev_set_check (“~give_error”)
dev_error_var (ErrorVar, 1)

视_设值 (tmp, 视_加 (HEXAMPLES, “/hdevelop/Applications/3D-Vision/cylinder.sm3”))
read_shape_model_3d (视_加 (HEXAMPLES, “/hdevelop/Applications/Object-Recognition-3D/cylinder.sm3”), ShapeModel3DID)
视_设值 (Error, ErrorVar)
out (Error, ErrorVar)
dev_set_check (“give_error”)
.如果 (视_不等于 (Error, #视_错误代码_无错误))
    dev_display (Image)
    disp_message (WindowHandle, G (“Loading ShapeModel Failed”), “window”, 5, 5, “black”, “true”)
    wait_seconds (2)
    dev_set_lut (“default”)
    dev_set_window (WindowHandle)
    dev_close_window ()
    返回 ()
.否则

.如果结束

' * wait_seconds (2)
dev_set_lut (“temperature”)
dev_set_paint (“default”)
dev_clear_window ()

dev_open_window (306, 视_乘 (640, 0.75), 视_乘 (752, 0.45), 视_乘 (480, 0.43), “black”, WindowHandleL)
dev_set_part (0, 0, 480, 752)
dev_set_window (WindowHandleL)
dev_set_lut (“default”)
dev_set_line_width (3)
p_set_font (WindowHandleL)
dev_set_window (WindowHandle)
dev_set_part (0, 0, 511, 639)

视_设值 (IndexList, G (1, 2, 8, 9, 12, 13, 14, 6))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexList), 1), ), 1, Index2)

    ' emphasize() enhances the texture on the cylinders surface
    视_设值 (Index, 视_取元素 (IndexList, Index2))
    read_image (Image1, 视_加 (视_加 (Path, “stereo_left_”), 视_文本格式化 (Index, “02”)))
    emphasize (Image1, ImageEmphasize1, 5, 5, 2)
    map_image (ImageEmphasize1, Map1, ImageMapped1)
    read_image (Image2, 视_加 (视_加 (Path, “stereo_right_”), 视_文本格式化 (Index, “02”)))
    emphasize (Image2, ImageEmphasize2, 5, 5, 2)
    map_image (ImageEmphasize2, Map2, ImageMapped2)

    ' the mask width and height must be (approximately) set according to the size
    ' of the pattern projected onto the setup
    binocular_disparity (ImageMapped2, ImageMapped1, Disparity, Score, “ncc”, 7, 7, 0, -20, 140, 1, 0.7, “left_right_check”, “none”)
    select_best_candidates (Disparity, TopMost)
    remove_shadowed_regions (Disparity, G (0.01))

    ' display height map and highest object extracted
    dev_set_window (WindowHandle)
    dev_clear_window ()
    dev_display (ImageMapped2)
    dev_display (Disparity)
    wait_seconds (0.2)
    dev_display (TopMost)
    dev_display (Disparity)
    wait_seconds (0.1)

    ' determine exact 3D pose of heighest object
    dev_set_window (WindowHandleL)
    read_image (Image, 视_加 (视_加 (Path, “closeup_”), 视_文本格式化 (Index, “02”)))
    dev_display (Image)
    find_shape_model_3d (Image, ShapeModel3DID, 0.8, 0.7, G (0, 2), G (), G (), Pose, CovPose, Score_CTRL)
    .如果 (视_不等于 (视_取元素总数 (Score_CTRL), 0))
        dev_set_color (“green”)
        get_shape_model_3d_params (ShapeModel3DID, “reference_point”, ReferencePoint)
        get_shape_model_3d_params (ShapeModel3DID, “cam_param”, CamParam)

        ' Project the reference point
        pose_to_hom_mat3d (Pose, HomMat3D)
        affine_trans_point_3d (HomMat3D, 视_取元素 (ReferencePoint, 0), 视_取元素 (ReferencePoint, 1), 视_取元素 (ReferencePoint, 2), X, Y, Z)
        project_3d_point (X, Y, Z, CamParam, Row, Column)

        ' display the projected 3D model
        project_shape_model_3d (ModelContours, ShapeModel3DID, CamParam, Pose, “true”, rad (30))
        wait_seconds (0.05)
        dev_display (ModelContours)
        disp_message (WindowHandleL, “Pose of topmost cylinder”, “window”, 0, 0, “black”, “true”)
    .否则
        disp_message (WindowHandleL, “ No match found ”, “window”, 0, 0, “black”, “true”)
    .如果结束

    wait_seconds (1)
.变量循环尾 ()
clear_shape_model_3d (ShapeModel3DID)
wait_seconds (3)
dev_set_lut (“default”)
dev_set_window (WindowHandleL)
dev_close_window ()
dev_set_window (WindowHandle)
dev_close_window ()

dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 select_best_candidates
.参数 Disparity, obj
.参数 TopMost, obj, 参考
.局部变量 Deviation, tuple
.局部变量 Deviation1, tuple
.局部变量 DisparityFull, obj
.局部变量 ImageMax, obj
.局部变量 ImageScaleMax2, obj
.局部变量 Indices, tuple
.局部变量 Max, tuple
.局部变量 MaxVal, tuple
.局部变量 Mean, tuple
.局部变量 Mean1, tuple
.局部变量 Min, tuple
.局部变量 Range, tuple
.局部变量 SelectedRegions, obj
.局部变量 cylinders, obj


full_domain (Disparity, DisparityFull)
scale_image_max (DisparityFull, ImageScaleMax2)
gray_dilation_shape (ImageScaleMax2, ImageMax, 3, 3, “octagon”)


regiongrowing_n (ImageMax, cylinders, “2-norm”, 0, 5, 200)
intensity (cylinders, ImageScaleMax2, Mean1, Deviation1)
tuple_max (Mean1, MaxVal)
select_gray (cylinders, ImageScaleMax2, SelectedRegions, G (“mean”), “and”, G (视_除 (MaxVal, 2)), G (视_加 (MaxVal, 1)))
select_shape (SelectedRegions, SelectedRegions, G (“area”, “rectangularity”), “and”, G (7000, 0.65), G (25000, 到小数 (1)))
intensity (SelectedRegions, ImageScaleMax2, Mean, Deviation)

min_max_gray (SelectedRegions, ImageScaleMax2, 0, Min, Max, Range)
tuple_sort_index (Max, Indices)
select_obj (SelectedRegions, TopMost, 视_加 (视_取元素 (Indices, 视_减 (视_取元素总数 (Max), 1)), 1))

返回 ()

.子程序 remove_shadowed_regions
.参数 Disparity, obj
.参数 Threshold, tuple
.局部变量 AbsoluteHisto, tuple
.局部变量 ImageScaleMax, obj
.局部变量 Percent, tuple
.局部变量 Region, obj
.局部变量 RelativeHisto, tuple
.局部变量 i, tuple

' for every stereo setup
' occlusions and shadows produce small regions with very high disparity
' which would be understood as being objects lying close to the camera

' in order to improve the quality of the results we remove such regions
scale_image_max (Disparity, ImageScaleMax)
gray_histo (ImageScaleMax, ImageScaleMax, AbsoluteHisto, RelativeHisto)
视_设值 (Percent, 视_取元素 (RelativeHisto, 255))
视_设值 (i, 254)
.判断循环首 (视_小于 (Percent, Threshold))
    视_设值 (Percent, 视_加 (视_取元素 (RelativeHisto, i), Percent))
    视_设值 (i, 视_减 (i, 1))
.判断循环尾 ()
threshold (ImageScaleMax, Region, i, 255)
overpaint_region (Disparity, Region, 到小数 (0), “fill”)
返回 ()

.子程序 p_do_car_door
.局部变量 C, tuple
.局部变量 CCoord, tuple
.局部变量 CalTabDescrName, tuple
.局部变量 Caltab, obj
.局部变量 CamParNoRad, tuple
.局部变量 CamParam, tuple
.局部变量 ContoursAffinTrans, obj
.局部变量 ContoursTrans, obj
.局部变量 CovPose, tuple
.局部变量 Cross, obj
.局部变量 FoundContour, obj
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 ImageReducedSearch, obj
.局部变量 ImageSearch, obj
.局部变量 Index, 整数型
.局部变量 Index1, 整数型
.局部变量 Index2, 整数型
.局部变量 IndexDPos, tuple
.局部变量 ModelCol, tuple
.局部变量 ModelContours, obj
.局部变量 ModelID, tuple
.局部变量 ModelPose, tuple
.局部变量 ModelRow, tuple
.局部变量 ModelWorld, obj
.局部变量 NumberContour, tuple
.局部变量 ObjectSelected, obj
.局部变量 Pose, tuple
.局部变量 PoseNewOrigin, tuple
.局部变量 PoseSelected, tuple
.局部变量 R, tuple
.局部变量 RCoord, tuple
.局部变量 ROI, obj
.局部变量 Rectangle2, obj
.局部变量 ReferencePose, tuple
.局部变量 Score, tuple
.局部变量 Seconds1, tuple
.局部变量 Seconds2, tuple
.局部变量 Time, tuple
.局部变量 WindowHandle, tuple
.局部变量 X, tuple
.局部变量 Xc, tuple
.局部变量 Y, tuple
.局部变量 Yc, tuple
.局部变量 Z, tuple
.局部变量 Zc, tuple

dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 640, 512, “black”, WindowHandle)
dev_set_part (0, 0, 视_减 (512, 1), 视_减 (640, 1))
p_set_font (WindowHandle)
dev_set_draw (“margin”)
dev_set_line_width (3)


' compute calibrated pose of object
read_image (Image, “automotive/car_door_calib_plate”)
视_设值 (CalTabDescrName, “caltab_200mm.descr”)
视_设值 (CamParam, G (0.0160522, -402.331, 9.30632e-006, 9.3e-006, 315.431, 273.525, 640, 512))
caltab_points (CalTabDescrName, X, Y, Z)
find_caltab (Image, Caltab, CalTabDescrName, 3, 112, 5)
find_marks_and_pose (Image, Caltab, CalTabDescrName, CamParam, 128, 10, 18, 0.9, 15, 100, RCoord, CCoord, ReferencePose)
gen_cross_contour_xld (Cross, RCoord, CCoord, 6, 0.785398)

' Create model
read_image (Image, “automotive/car_door_init_pose”)
dev_display (Image)
' Select a planar subpart of the car door as model region.
read_region (ROI, “automotive/car_door.reg”)
reduce_domain (Image, ROI, ImageReduced)
set_origin_pose (ReferencePose, 0, 0, 0.01, PoseNewOrigin)
create_planar_calib_deformable_model (ImageReduced, CamParam, PoseNewOrigin, “auto”, -0.2, 0.79, “auto”, 0.9, 1.2, “auto”, 1, 1, “auto”, “none”, “use_polarity”, “auto”, “auto”, G (), G (), ModelID)
get_deformable_model_contours (ModelContours, ModelID, 1)

' prepare contour data for result display
change_radial_distortion_cam_par (“preserve_resolution”, CamParam, 0, CamParNoRad)
get_deformable_model_params (ModelID, “model_row”, ModelRow)
get_deformable_model_params (ModelID, “model_col”, ModelCol)
get_deformable_model_params (ModelID, “model_pose”, ModelPose)
affine_trans_contour_xld (ModelContours, ContoursAffinTrans, G (1, 0, ModelRow, 0, 1, ModelCol))
contour_to_world_plane_xld (ContoursAffinTrans, ContoursTrans, CamParNoRad, ModelPose, “m”)
count_obj (ContoursTrans, NumberContour)
pose_to_hom_mat3d (ModelPose, HomMat3D)
gen_empty_obj (FoundContour)

dev_display (Image)
disp_message (WindowHandle, “Determine Pose of a Car Door in a ” ＋ #换行符 ＋ “Calibrated Setup” ＋ #换行符 ＋ “”, “window”, 50, 125, “black”, “true”)
wait_seconds (4)


' find pose of car door in subsequent images
gen_rectangle1 (Rectangle2, 200, 50, 420, 620)
视_设值 (IndexDPos, G (1, 4, 11, 12, 15, 16, 20, 17, 19, 3))
.变量循环首 (0, DD (视_减 (视_取元素总数 (IndexDPos), 1), ), 1, Index)
    read_image (ImageSearch, 视_加 (“automotive/car_door_”, 视_文本格式化 (视_取元素 (IndexDPos, Index), “.02”)))
    reduce_domain (ImageSearch, Rectangle2, ImageReducedSearch)
    set_system (“flush_graphic”, “false”)
    dev_display (ImageSearch)
    count_seconds (Seconds1)
    find_planar_calib_deformable_model (ImageReducedSearch, ModelID, -0.2, 0.78, 0.9, 1.2, 1, 1, 0.6, 1, 1, 0, 0.8, G (), G (), Pose, CovPose, Score)
    count_seconds (Seconds2)
    视_设值 (Time, 视_减 (Seconds2, Seconds1))

    ' check for results
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Score), 1), ), 1, Index1)
        tuple_select_range (Pose, 视_乘 (Index1, 7), 视_减 (视_乘 (视_加 (Index1, 1), 7), 1), PoseSelected)
        pose_to_hom_mat3d (PoseSelected, HomMat3D)
        gen_empty_obj (FoundContour)
        .变量循环首 (1, DD (NumberContour, ), 1, Index2)
            select_obj (ContoursTrans, ObjectSelected, Index2)
            get_contour_xld (ObjectSelected, Y, X)
            视_设值 (Z, gen_tuple_const (视_取元素总数 (X), 到小数 (0)))
            affine_trans_point_3d (HomMat3D, X, Y, Z, Xc, Yc, Zc)
            project_3d_point (Xc, Yc, Zc, CamParam, R, C)
            gen_contour_polygon_xld (ModelWorld, R, C)
            concat_obj (FoundContour, ModelWorld, FoundContour)
        .变量循环尾 ()

        ' display results
        disp_message (WindowHandle, 视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (视_加 (“Door found in ”, 视_文本格式化 (视_乘 (Time, 1000), “.4”)), “ ms”), “” ＋ #换行符 ＋ “ X: ”), 视_文本格式化 (视_取元素 (PoseSelected, 0), “.4f”)), “ m” ＋ #换行符 ＋ “ Y: ”), 视_文本格式化 (视_取元素 (PoseSelected, 1), “.4f”)), “ m” ＋ #换行符 ＋ “ Z: ”), 视_文本格式化 (视_取元素 (PoseSelected, 2), “.4f”)), “ m”), “window”, -1, -1, “black”, “true”)
        dev_set_color (“blue”)
        dev_display (FoundContour)
        dev_set_colored (3)
        disp_3d_coord_system (WindowHandle, CamParam, PoseSelected, 0.15)
    .变量循环尾 ()
    set_system (“flush_graphic”, “true”)
    disp_line (WindowHandle, -101, -101, -99, -99)
    wait_seconds (1)
.变量循环尾 ()

clear_deformable_model (ModelID)


wait_seconds (2)
dev_close_window ()
dev_update_pc (“on”)
dev_update_var (“on”)
返回 ()

.子程序 p_do_reconstruct_connection_rod_uncalib
.局部变量 Disparity, obj
.局部变量 Index, 整数型
.局部变量 ProfileImage, obj
.局部变量 ProfileRegion, obj
.局部变量 SheetOfLightModelID, tuple
.局部变量 WindowHandle, tuple
.局部变量 WindowHandle2, tuple


dev_update_window (“off”)
dev_update_var (“off”)
dev_update_pc (“off”)
dev_open_window (0, 0, 视_乘 (752, 0.85), 视_乘 (240, 0.85), “black”, WindowHandle)
dev_set_lut (“default”)
dev_set_draw (“margin”)
dev_set_line_width (3)
dev_set_color (“lime green”)
dev_set_part (0, 0, 239, 751)
p_set_font (WindowHandle)
dev_open_window (267, 0, 视_乘 (752, 0.85), 视_乘 (240, 0.85), “black”, WindowHandle2)
dev_set_part (0, -130, 289, 770)
dev_set_lut (“temperature”)
p_set_font (WindowHandle2)


' Create the rectangular region where to measure the profiles
read_image (ProfileImage, “sheet_of_light/connection_rod_001”)
gen_rectangle1 (ProfileRegion, 120, 75, 195, 710)

' Create a model in order to measure profiles according to
' the sheet-of-light technique. Simulataneously set some
' parameters to the model.
create_sheet_of_light_model (ProfileRegion, G (“min_gray”, “num_profiles”, “ambiguity_solving”, “score_type”), G (70, 290, “first”, “width”), SheetOfLightModelID)

' Measure the profile from successive images
.变量循环首 (1, 290, 1, Index)
    dev_set_window (WindowHandle)
    read_image (ProfileImage, 视_加 (“sheet_of_light/connection_rod_”, 视_文本格式化 (Index, “.3”)))
    measure_profile_sheet_of_light (ProfileImage, SheetOfLightModelID, G ())
    set_system (“flush_graphic”, “false”)
    dev_display (ProfileImage)
    dev_display (ProfileRegion)
    get_sheet_of_light_result (Disparity, SheetOfLightModelID, “disparity”)
    dev_set_window (WindowHandle2)
    dev_clear_window ()
    dev_set_part (0, -130, 289, 770)
    set_grayval (Disparity, 0, 0, 122)
    set_grayval (Disparity, 视_减 (Index, 1), 635, 195)
    dev_display (Disparity)
    disp_message (WindowHandle2, “Building Disparity Image per Scanline”, “window”, 0, 0, “black”, “true”)
    disp_message (WindowHandle, “Scanning Profile of Connection Rod”, “window”, 0, 0, “black”, “true”)
    set_system (“flush_graphic”, “true”)
    disp_line (WindowHandle, -202, -202, -199, -199)
    disp_line (WindowHandle2, -202, -202, -199, -199)
.变量循环尾 ()

dev_set_window (WindowHandle)
dev_display (ProfileImage)
dev_display (ProfileRegion)
disp_message (WindowHandle, “Scanned Connection Rod”, “window”, 0, 0, “black”, “true”)
dev_set_window (WindowHandle2)
dev_display (Disparity)
disp_message (WindowHandle2, “Disparity Image”, “window”, 0, 0, “black”, “true”)
wait_seconds (4)
' Close the sheet-of-light handle once the measurement
' has been performed
clear_sheet_of_light_model (SheetOfLightModelID)

dev_set_lut (“default”)
dev_set_window (WindowHandle)
dev_close_window ()
dev_set_window (WindowHandle2)
dev_close_window ()
dev_set_lut (“default”)

返回 ()

.子程序 do_check_for_model_files
.参数 CylinderModelExists, tuple, 参考
.参数 CookieModelExists, tuple, 参考
.参数 ClampsModelExists, tuple, 参考
.局部变量 DescrModelFile, tuple
.局部变量 HEXAMPLES, tuple
.局部变量 ShapeModel3DCylinderFile, tuple
.局部变量 ShapeModel3DFile, tuple


视_设值 (HEXAMPLES, environment (“HALCONEXAMPLES”))
.如果 (视_等于 (HEXAMPLES, “”))
    视_设值 (HEXAMPLES, 视_加 (environment (“HALCONROOT”), “/examples”))
.否则

.如果结束

视_设值 (ShapeModel3DCylinderFile, 视_加 (HEXAMPLES, “/hdevelop/Applications/Object-Recognition-3D/cylinder.sm3”))
file_exists (ShapeModel3DCylinderFile, CylinderModelExists)


视_设值 (DescrModelFile, 视_加 (HEXAMPLES, “/hdevelop/Applications/Object-Recognition-2D/cookie_box_model.dsm”))
file_exists (DescrModelFile, CookieModelExists)


视_设值 (ShapeModel3DFile, 视_加 (HEXAMPLES, “/hdevelop/Applications/Position-Recognition-3D/clamp_sloped_35.sm3”))
file_exists (ShapeModel3DFile, ClampsModelExists)

返回 ()

.子程序 p_do_track_engine_part
.局部变量 AngleExtent, tuple
.局部变量 AngleExtentTracking, tuple
.局部变量 Area, tuple
.局部变量 CamParam, tuple
.局部变量 Circle, obj
.局部变量 ColOrig, tuple
.局部变量 ColTrans, tuple
.局部变量 Column, tuple
.局部变量 Contours, obj
.局部变量 ContoursProjTrans, obj
.局部变量 Exception, tuple
.局部变量 HomMat2DInvert, tuple
.局部变量 HomMat2DOut, tuple
.局部变量 HomMat2DTrack, tuple
.局部变量 HomMat3D, tuple
.局部变量 Image, obj
.局部变量 ImageReduced, obj
.局部变量 Index, 整数型
.局部变量 Metric, tuple
.局部变量 MinScore, tuple
.局部变量 MinScoreTracking, tuple
.局部变量 ModelID, tuple
.局部变量 NotFound, tuple
.局部变量 NumImages, tuple
.局部变量 ObjectSelected, obj
.局部变量 Pose, tuple
.局部变量 PreferenceValue, tuple
.局部变量 Quality, tuple
.局部变量 Region, obj
.局部变量 Row, tuple
.局部变量 RowOrig, tuple
.局部变量 RowTrans, tuple
.局部变量 S1, tuple
.局部变量 S2, tuple
.局部变量 ScaleCOffset, tuple
.局部变量 ScaleROffset, tuple
.局部变量 Score, tuple
.局部变量 TrackingFailed, tuple
.局部变量 TrackingRadius, tuple
.局部变量 TrackingTime, tuple
.局部变量 TransImage, obj
.局部变量 WindowHandle, tuple

' This example shows how to efficiently perform a tracking task using
' perspective deformable matching. The basic idea is to speed up the
' search by using the pose that was determined in a previous image to
' restrict the search space in the next image. In case that the
' algorithm looses track of the object, the search is applied
' again, but this time in the full search domain.

dev_update_off ()
dev_get_preferences (“suppress_handled_exceptions_dlg”, PreferenceValue)
read_image (Image, “automotive/engine_part_001”)
dev_open_window_fit_image (Image, 0, 0, -1, -1, WindowHandle)
dev_set_line_width (3)
set_display_font (WindowHandle, 16, “mono”, “true”, “false”)
dev_display (Image)

' Search parameters
视_设值 (AngleExtent, 90)
视_设值 (AngleExtentTracking, 20)
视_设值 (MinScore, 0.4)
视_设值 (MinScoreTracking, 0.5)
视_设值 (TrackingRadius, 80)
视_设值 (ScaleROffset, 0.1)
视_设值 (ScaleCOffset, 到小数 (0))
视_设值 (Metric, “use_polarity”)
视_设值 (CamParam, G (视_除 (到小数 (12), 1000), 到小数 (0), 视_乘 (视_除 (4.65, 1000000), 2), 视_乘 (视_除 (4.65, 1000000), 2), 320, 256, 640, 512))

read_region (Region, “automotive/engine_part_model.reg”)
area_center (Region, Area, Row, Column)
reduce_domain (Image, Region, ImageReduced)
create_planar_uncalib_deformable_model (ImageReduced, “auto”, rad (视_除 (－DD (AngleExtent, ), 到小数 (2))), rad (AngleExtent), “auto”, 1, 视_加 (1, ScaleROffset), “auto”, 1, 视_加 (1, ScaleCOffset), “auto”, “none”, Metric, “auto”, “auto”, G (), G (), ModelID)
set_deformable_model_origin (ModelID, －DD (Row, ), －DD (Column, ))
get_deformable_model_contours (Contours, ModelID, 1)
dev_display (Image)
dev_set_color (“green”)
dev_set_draw (“margin”)
dev_display (Contours)
disp_message (WindowHandle, “Model created”, “window”, 12, 12, “black”, “true”)
gen_circle (Circle, Row, Column, TrackingRadius)
wait_seconds (3)

视_设值 (Score, G ())
select_obj (Contours, ObjectSelected, 1)
get_contour_xld (ObjectSelected, RowOrig, ColOrig)
视_设值 (NotFound, G ())
视_设值 (TrackingFailed, G ())
视_设值 (NumImages, 100)
视_调试配置 (G (#视_调试_发生错误暂停, #视_调试_不启用))
.变量循环首 (1, DD (NumImages, ), 1, Index)
    wait_seconds (0.05)
    视_设值 (TrackingTime, 0)
    read_image (Image, 视_加 (“automotive/engine_part_”, 视_文本格式化 (Index, “03”)))
    ' Either it is the first image, and one needs to perform full search,
    ' or else the algorithm lost track of the object, and needs to start
    ' all over again
    set_system (“flush_graphic”, “false”)
    dev_set_preferences (“suppress_handled_exceptions_dlg”, “true”)
    .如果 (视_大于 (视_取元素总数 (Score), 0))
        ' Keep track of the object: project the image with the pose that the object had
        ' in the previous image. The assumption is that the pose does not change much
        ' from image to image (see parameter AngleExtentTracking). Update the pose after
        ' successful search
        ' try
        count_seconds (S1)
        hom_mat2d_invert (HomMat2DOut, HomMat2DInvert)
        projective_trans_image (Image, TransImage, HomMat2DInvert, “bilinear”, “false”, “false”)
        reduce_domain (TransImage, Circle, ImageReduced)
        find_planar_uncalib_deformable_model (TransImage, ModelID, rad (视_除 (－DD (AngleExtentTracking, ), 2)), rad (AngleExtentTracking), 1, 1, 1, 1, MinScoreTracking, 1, 1, 0, 0.9, G (), G (), HomMat2DTrack, Score)
        count_seconds (S2)
        dev_set_color (“green”)
        .判断开始 (hom_mat2d_compose (HomMat2DOut, HomMat2DTrack, HomMat2DOut) ＝ #视_错误代码_无错误)
            projective_trans_contour_xld (Contours, ContoursProjTrans, HomMat2DOut)
            projective_trans_pixel (HomMat2DOut, G (视_减 (Row, 1), 视_减 (Row, 1), 视_加 (Row, 1), 视_加 (Row, 1)), G (视_减 (Column, 2), 视_加 (Column, 1), 视_加 (Column, 1), 视_减 (Column, 1)), RowTrans, ColTrans)
            vector_to_pose (G (-2, 1, 1, -1), G (-1, -1, 1, 1), G (), RowTrans, ColTrans, CamParam, “planar_analytic”, “error”, Pose, Quality)
            pose_to_hom_mat3d (Pose, HomMat3D)
        .默认
            视_设值 (TrackingTime, 视_减 (S2, S1))
            视_设值 (TrackingFailed, G (TrackingFailed, Index))
        .判断结束

        ' *' 不支持的方法：catch(Exception)
        ' endtry
    .否则

    .如果结束
    .如果 (视_等于 (视_取元素总数 (Score), 0))
        ' Still no object found. Try full search.
        ' try
        count_seconds (S1)
        find_planar_uncalib_deformable_model (Image, ModelID, rad (视_除 (－DD (AngleExtent, ), 到小数 (2))), rad (AngleExtent), 1, 视_加 (1, ScaleROffset), 1, 视_加 (1, ScaleCOffset), MinScore, 1, 1, 0, 0.9, G (), G (), HomMat2DOut, Score)
        count_seconds (S2)
        projective_trans_contour_xld (Contours, ContoursProjTrans, HomMat2DOut)
        projective_trans_pixel (HomMat2DOut, G (视_减 (Row, 1), 视_减 (Row, 1), 视_加 (Row, 1), 视_加 (Row, 1)), G (视_减 (Column, 2), 视_加 (Column, 1), 视_加 (Column, 1), 视_减 (Column, 1)), RowTrans, ColTrans)
        vector_to_pose (G (-2, 1, 1, -1), G (-1, -1, 1, 1), G (), RowTrans, ColTrans, CamParam, “planar_analytic”, “error”, Pose, Quality)
        dev_set_color (“green”)
        ' *' 不支持的方法：catch(Exception)
        ' set_system("flush_graphic","true")
        ' dev_display(Image)
        ' 视_设值 (NotFound, G (NotFound, Index))
        ' 到循环尾 ()
        ' endtry
    .否则

    .如果结束
    dev_set_preferences (“suppress_handled_exceptions_dlg”, PreferenceValue)
    dev_display (Image)
    dev_display (ContoursProjTrans)
    disp_message (WindowHandle, 视_加 (视_加 (“Model found in ”, 视_文本格式化 (视_乘 (视_减 (视_加 (TrackingTime, S2), S1), 1000), “.1f”)), “ ms”), “window”, 12, 12, “black”, “true”)
    dev_set_colored (3)
    disp_3d_coord_system (WindowHandle, CamParam, Pose, 100)
    set_system (“flush_graphic”, “true”)
    set_tposition (WindowHandle, -200, -200)
    write_string (WindowHandle, “”)
.变量循环尾 ()
视_调试配置 (G (#视_调试_发生错误暂停, #视_调试_启用))
clear_deformable_model (ModelID)
wait_seconds (3)
dev_close_window ()
返回 ()

.子程序 p_do_locate_pipe_joints_stereo
.局部变量 CamParam0, tuple
.局部变量 CamParam1, tuple
.局部变量 CamParam2, tuple
.局部变量 CamParam3, tuple
.局部变量 CameraSetupModelID, tuple
.局部变量 DispTime, tuple
.局部变量 Exception, tuple
.局部变量 Height, tuple
.局部变量 HomMat3DCamToObj, tuple
.局部变量 HomMat3DCamToWorld, tuple
.局部变量 HomMat3DObjToCam, tuple
.局部变量 HomMat3DObjToWorld, tuple
.局部变量 HomMat3DWorldToCam, tuple
.局部变量 HomMat3DWorldToObj, tuple
.局部变量 Image, obj
.局部变量 ImagePath, tuple
.局部变量 ImagePrefix, tuple
.局部变量 Images, obj
.局部变量 Img, obj
.局部变量 Index, 整数型
.局部变量 MatchIndex, 整数型
.局部变量 MatchingDiff, tuple
.局部变量 Message, tuple
.局部变量 MinScore, tuple
.局部变量 ModelContours, obj
.局部变量 NumCameras, tuple
.局部变量 NumImages, tuple
.局部变量 NumMatches, tuple
.局部变量 ObjPoseCam0, tuple
.局部变量 ObjectModel3DIDAffineTrans, tuple
.局部变量 OldImage, obj
.局部变量 Params, tuple
.局部变量 PipeJointOM3DID, tuple
.局部变量 PipeJointPileOM3DID, tuple
.局部变量 PipeJointSMID, tuple
.局部变量 Pose0, tuple
.局部变量 Pose1, tuple
.局部变量 Pose2, tuple
.局部变量 Pose3, tuple
.局部变量 Poses, tuple
.局部变量 ReconsTime, tuple
.局部变量 Scores, tuple
.局部变量 Status, tuple
.局部变量 StereoModelID, tuple
.局部变量 SurfaceMatchingResultID, tuple
.局部变量 T0, tuple
.局部变量 T1, tuple
.局部变量 T2, tuple
.局部变量 T3, tuple
.局部变量 T4, tuple
.局部变量 T5, tuple
.局部变量 Values, tuple
.局部变量 Width, tuple
.局部变量 WindowHandle, tuple
.局部变量 WorldPose0, tuple

' Reconstruct the three-dimensional surface of a pile of pipe
' joints by using a multi-view stereo setup with four similar
' cameras and detect the position of each joint by using
' surface-based 3D matching


' *****
' Initializations:
' *****

dev_update_off ()
dev_set_preferences (“suppress_handled_exceptions_dlg”, “true”)
视_设值 (ImagePath, “3d_machine_vision/multi_view/”)
视_设值 (ImagePrefix, “multi_view_pipe_joints”)
read_image (Image, 视_加 (视_加 (ImagePath, ImagePrefix), “_cam_0_01”))
get_image_size (Image, Width, Height)
dev_open_window (0, 0, 640, 420, “black”, WindowHandle)
dev_set_draw (“margin”)
set_display_font (WindowHandle, 16, “mono”, “true”, “false”)

' *****
' Part 1: Read the parameters of the multi-view stereo setup
' *****
' Read the camera setup model from file and get the parameters
' and the poses of the cameras
' try
file_exists (“H:/Program Files/MVTec/HALCON-10.0/examples/hdevelop/Calibration/Multi-View/four_camera_setup_model.csm”, CameraSetupModelID)
.判断开始 (视_是否为真 (CameraSetupModelID))
    read_camera_setup_model (“H:/Program Files/MVTec/HALCON-10.0/examples/hdevelop/Calibration/Multi-View/four_camera_setup_model.csm”, CameraSetupModelID)
.默认
    init_camera_setup (CameraSetupModelID)
.判断结束

' read_camera_setup_model (“Calibration/Multi-View/four_camera_setup_model.csm”, CameraSetupModelID)
' *' 不支持的方法：catch(Exception)
' 如果 (视_等于(视_取元素(Exception,0),5200))如果 ()
' init_camera_setup(CameraSetupModelID)
' *' 不支持的方法：throw(Exception)
' 'endtry

get_camera_setup_param (CameraSetupModelID, “general”, “num_cameras”, NumCameras)
get_camera_setup_param (CameraSetupModelID, 0, “pose”, Pose0)
get_camera_setup_param (CameraSetupModelID, 1, “pose”, Pose1)
get_camera_setup_param (CameraSetupModelID, 2, “pose”, Pose2)
get_camera_setup_param (CameraSetupModelID, 3, “pose”, Pose3)
get_camera_setup_param (CameraSetupModelID, 0, “params”, CamParam0)
get_camera_setup_param (CameraSetupModelID, 1, “params”, CamParam1)
get_camera_setup_param (CameraSetupModelID, 2, “params”, CamParam2)
get_camera_setup_param (CameraSetupModelID, 3, “params”, CamParam3)

' Create a multi-view stereo model, initialize it, and clear
' the camera setup, which is no longer required
create_stereo_model (CameraSetupModelID, “surface_pairwise”, “persistence”, 1, StereoModelID)
clear_camera_setup_model (CameraSetupModelID)
' -> Subsampling X, Y, Z
set_stereo_model_param (StereoModelID, “sub_sampling_step”, 3)
set_stereo_model_param (StereoModelID, “binocular_method”, “ncc”)
' -> Interpolation aliasing by binocular image rectification
set_stereo_model_param (StereoModelID, “rectif_interpolation”, “bilinear”)
set_stereo_model_param (StereoModelID, “rectif_sub_sampling”, 1.2)
' -> Binocular disparity parameters
set_stereo_model_param (StereoModelID, “binocular_num_levels”, 1)
set_stereo_model_param (StereoModelID, “binocular_mask_width”, 19)
set_stereo_model_param (StereoModelID, “binocular_mask_height”, 19)
set_stereo_model_param (StereoModelID, “binocular_texture_thresh”, 0)
set_stereo_model_param (StereoModelID, “binocular_score_thresh”, 0.4)
set_stereo_model_param (StereoModelID, “binocular_filter”, “left_right_check”)
set_stereo_model_param (StereoModelID, “binocular_sub_disparity”, “interpolation”)
' -> Define bounding box and camera pairs
set_stereo_model_param (StereoModelID, “bounding_box”, G (-0.2, -0.07, -0.075, 0.2, 0.07, -0.004))
set_stereo_model_image_pairs (StereoModelID, G (0, 2), G (1, 3))

' *****
' Part 2: Create a surface model of the pipe fittings to be matched
' *****
read_object_model_3d (“H:/Program Files/MVTec/HALCON-10.0/examples/hdevelop/Applications/Robot-Vision/pipe_joint.ply”, “m”, G (), G (), PipeJointOM3DID, Status)
create_surface_model (PipeJointOM3DID, 0.03, G (), G (), PipeJointSMID)

' The next line is required in order to use the option
' 'hidden_surface_removal' in the operator
' project_object_model_3d (see below).
prepare_object_model_3d (PipeJointOM3DID, “shape_based_matching_3d”, “true”, G (), G ())

' *****
' Part 3: Reconstruct the surface of the pile of pipe fittings
' and detect the position of up to MaxNumParts by using
' surface-based 3D matching
' *****
视_设值 (NumMatches, 3)
视_设值 (MinScore, 0.3)
视_设值 (Params, G (“num_matches”, “pose_ref_scoring_dist_rel”))
视_设值 (Values, G (NumMatches, 0.02))

pose_to_hom_mat3d (Pose0, HomMat3DCamToWorld)
hom_mat3d_invert (HomMat3DCamToWorld, HomMat3DWorldToCam)
hom_mat3d_to_pose (HomMat3DWorldToCam, WorldPose0)

视_设值 (NumImages, 15)
.变量循环首 (1, DD (NumImages, ), 1, Index)

    ' Read and display the images
    read_multi_view_stereo_images (Images, ImagePath, ImagePrefix, G (Index), NumCameras)

    ' Reconstruct the 3D scene (the pile of pipe fittings)
    视_设值 (Message, G (“Performing the reconstruction...”))
    display_multi_view_stereo_images (Images, WindowHandle)
    disp_message (WindowHandle, Message, “window”, 12, 12, “black”, “true”)

    count_seconds (T0)
    reconstruct_surface_stereo (Images, StereoModelID, PipeJointPileOM3DID)
    count_seconds (T1)
    视_设值 (ReconsTime, 视_减 (T1, T0))

    ' Perform surface-based 3D matching
    视_设值 (Message, G (视_加 (视_加 (“Search ”, NumMatches), “ best parts with surface based matching...”)))
    disp_message (WindowHandle, Message, “window”, 36, 12, “black”, “true”)
    count_seconds (T2)
    find_surface_model (PipeJointSMID, PipeJointPileOM3DID, 0.04, 0.15, MinScore, “false”, Params, Values, Poses, Scores, SurfaceMatchingResultID)
    count_seconds (T3)
    视_设值 (MatchingDiff, 视_减 (T3, T2))

    ' Display the results
    set_system (“flush_graphic”, “false”)
    select_obj (Images, Img, 1)
    dev_set_part (0, 0, 视_减 (Height, 1), 视_减 (Width, 1))
    dev_display (Img)
    count_seconds (T4)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Scores), 1), ), 1, MatchIndex)
        pose_to_hom_mat3d (视_取元素范围 (Poses, 视_乘 (MatchIndex, 7), 视_加 (视_乘 (MatchIndex, 7), 6)), HomMat3DObjToWorld)
        hom_mat3d_invert (HomMat3DObjToWorld, HomMat3DWorldToObj)
        hom_mat3d_compose (HomMat3DWorldToObj, HomMat3DCamToWorld, HomMat3DCamToObj)
        hom_mat3d_invert (HomMat3DCamToObj, HomMat3DObjToCam)
        hom_mat3d_to_pose (HomMat3DObjToCam, ObjPoseCam0)
        ' Display the coordinate system of the part
        dev_set_colored (3)
        dev_set_line_width (3)
        disp_3d_coord_system (WindowHandle, CamParam0, ObjPoseCam0, 0.03)
        ' Display the faces of the part
        affine_trans_object_model_3d (PipeJointOM3DID, HomMat3DObjToWorld, ObjectModel3DIDAffineTrans)
        project_object_model_3d (ModelContours, ObjectModel3DIDAffineTrans, CamParam0, WorldPose0, G (“data”, “hidden_surface_removal”), G (“faces”, “true”))
        dev_set_line_width (2)
        dev_set_color (“green”)
        dev_display (ModelContours)

        clear_object_model_3d (ObjectModel3DIDAffineTrans)
    .变量循环尾 ()
    set_system (“flush_graphic”, “true”)
    count_seconds (T5)
    视_设值 (DispTime, 视_减 (T5, T4))

    视_设值 (Message, 视_加 (视_加 (“Reconstruction: ”, 视_文本格式化 (ReconsTime, “.2f”)), “ s”))
    视_tuple元素赋值 (Message, 1, 视_加 (视_加 (视_加 (视_加 (“Found ”, 视_取元素总数 (Scores)), “ pipe joint(s) in ”), 视_文本格式化 (MatchingDiff, “.2f”)), “ s”))
    ' *     Message[2] := 'Visualization: ' + DispTime$'.1f' + ' s'
    disp_message (WindowHandle, Message, “window”, 12, 12, “black”, “true”)
    disp_message (WindowHandle, “Camera 0”, “window”, 视_减 (Height, 36), 12, “white”, “false”)
    wait_seconds (5)

    ' clear the 3D object model
    clear_object_model_3d (PipeJointPileOM3DID)
    copy_obj (Images, OldImage, 1, 1)
.变量循环尾 ()

' Clear the stereo model and the surface model
clear_stereo_model (StereoModelID)
clear_surface_model (PipeJointSMID)
clear_object_model_3d (PipeJointOM3DID)

dev_set_preferences (“suppress_handled_exceptions_dlg”, “false”)
wait_seconds (3)
dev_close_window ()
返回 ()

.子程序 display_multi_view_stereo_images
.参数 Images, obj
.参数 WindowHandle, tuple
.局部变量 ColIdx, tuple
.局部变量 Height, tuple
.局部变量 Img, obj
.局部变量 Index, 整数型
.局部变量 NumCols, tuple
.局部变量 NumImages, tuple
.局部变量 RowIdx, tuple
.局部变量 TiledImage, obj
.局部变量 Width, tuple

' Display the images of a multi-view stereo setup
' consisting of four cameras

dev_set_window (WindowHandle)

count_obj (Images, NumImages)
.如果 (视_不等于 (NumImages, 4))
    disp_message (WindowHandle, “Wrong number of images provided!”, “window”, 12, 12, “black”, “true”)
    stop ()
.否则

.如果结束

视_设值 (NumCols, 2)
select_obj (Images, Img, 1)
get_image_size (Img, Width, Height)
tile_images (Images, TiledImage, NumCols, “horizontal”)
dev_set_part (0, 0, 视_减 (视_乘 (2, Height), 1), 视_减 (视_乘 (2, Width), 1))
dev_display (TiledImage)

.变量循环首 (0, DD (视_减 (NumImages, 1), ), 1, Index)
    视_设值 (RowIdx, 视_加 (视_除 (Index, NumCols), 1))
    视_设值 (ColIdx, 视_求模 (Index, NumCols))
    disp_message (WindowHandle, 视_加 (“Camera ”, Index), “image”, 视_减 (视_乘 (RowIdx, Height), 72), 视_加 (视_乘 (ColIdx, Width), 12), “white”, “false”)
.变量循环尾 ()
返回 ()


.子程序 init_camera_setup
.参数 CameraSetupModelID, tuple, 参考
.局部变量 CamParam0, tuple
.局部变量 CamParam1, tuple
.局部变量 CamParam2, tuple
.局部变量 CamParam3, tuple
.局部变量 Pose0, tuple
.局部变量 Pose1, tuple
.局部变量 Pose2, tuple
.局部变量 Pose3, tuple


' Define the interior and exterior camera parameters
视_设值 (CamParam0, G (0.00850373, 4008.61, -295892000, 2.37315e+013, 0.139749, -0.00367983, 5.99965e-006, 6e-006, 362.715, 236.769, 752, 480))
视_设值 (CamParam1, G (0.00854019, 3445.26, -118075000, 6407150000000, -0.0527818, -0.192439, 5.99894e-006, 6e-006, 406.13, 254.15, 752, 480))
视_设值 (CamParam2, G (0.00852569, 3938.44, -275967000, 2.27295e+013, 0.231091, 0.193667, 6.00001e-006, 6e-006, 367.159, 242.477, 752, 480))
视_设值 (CamParam3, G (0.00853794, 3793.19, -349193000, 3.9611e+013, 0.0264028, 0.147156, 6.00169e-006, 6e-006, 397.066, 224.671, 752, 480))

视_设值 (Pose0, G (0.0496073, 0.0280127, -0.431281, 3.5466, 354.117, 179.758, 0))
视_设值 (Pose1, G (0.0495484, -0.0297644, -0.429654, 355.333, 354.014, 359.147, 0))
视_设值 (Pose2, G (-0.0411315, -0.0294687, -0.427325, 355.519, 4.45356, 359.876, 0))
视_设值 (Pose3, G (-0.0414501, 0.0288074, -0.429167, 2.94179, 4.59538, 179.173, 0))

' Create a camera setup model and set its parameters
create_camera_setup_model (4, CameraSetupModelID)

set_camera_setup_cam_param (CameraSetupModelID, 0, “area_scan_polynomial”, CamParam0, Pose0)
set_camera_setup_cam_param (CameraSetupModelID, 1, “area_scan_polynomial”, CamParam1, Pose1)
set_camera_setup_cam_param (CameraSetupModelID, 2, “area_scan_polynomial”, CamParam2, Pose2)
set_camera_setup_cam_param (CameraSetupModelID, 3, “area_scan_polynomial”, CamParam3, Pose3)
返回 ()

.子程序 read_multi_view_stereo_images
.参数 Images, obj, 参考
.参数 ImagePath, tuple
.参数 ImagePrefix, tuple
.参数 SceneIndex, tuple
.参数 NumCamera, tuple
.局部变量 Img, obj
.局部变量 Index, 整数型

' Read the images of the multi-view stereo setup

read_image (Images, 视_加 (视_加 (视_加 (ImagePath, ImagePrefix), “_cam_0_”), 视_文本格式化 (SceneIndex, “.02”)))
.变量循环首 (1, DD (视_减 (NumCamera, 1), ), 1, Index)
    read_image (Img, 视_加 (视_加 (视_加 (视_加 (视_加 (ImagePath, ImagePrefix), “_cam_”), Index), “_”), 视_文本格式化 (SceneIndex, “.02”)))
    concat_obj (Images, Img, Images)
.变量循环尾 ()
返回 ()

.子程序 p_do_find_cocoa_package_local_deformable
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 ContoursAffinTrans, obj
.局部变量 DeformedContours, obj
.局部变量 FoundOut, tuple
.局部变量 HomMat2DIdentity, tuple
.局部变量 HomMat2DTranslate, tuple
.局部变量 Image, obj
.局部变量 ImageRectified, obj
.局部变量 Index, 整数型
.局部变量 J, 整数型
.局部变量 ModelContours, obj
.局部变量 ModelID, tuple
.局部变量 ModelImage, obj
.局部变量 NumImages, tuple
.局部变量 Row, tuple
.局部变量 S1, tuple
.局部变量 S2, tuple
.局部变量 Score, tuple
.局部变量 Smoothness, tuple
.局部变量 Time, tuple
.局部变量 VectorField, obj
.局部变量 WarpedMesh, obj
.局部变量 WindowHandle, tuple


' * FoundOut := Found


' This example program shows how to use local deformable
' matching to find objects that are deformed.

' Note that to find deformed objects you can
' - apply shape-based matching using the parameter
' 'max_deformation' or
' - apply local deformable matching.

' In this example, the task is solved with local
' deformable matching. You can compare it to the example
' 'find_cocoa_packages_max_deformations.hdev', which
' solves the same task with shape-based matching and the
' parameter 'max_deformation'. Shape-based matching is
' significantly faster, but local deformable matching is
' more robust to different types of deformations.
' For example, the deformations in the example program
' 'find_peanut_chocolate_candies_local_deformable.hdev'
' can not be handled by shape-based matching.

dev_update_off ()
read_image (ModelImage, “food/cocoa_package_model”)
dev_close_window ()
dev_open_window_fit_image (ModelImage, 0, 0, -1, -1, WindowHandle)
set_display_font (WindowHandle, 16, “mono”, “true”, “false”)

' Create and display the local deformable model
create_local_deformable_model (ModelImage, “auto”, rad (-15), rad (30), “auto”, 1, 1, “auto”, 1, 1, “auto”, “none”, “use_polarity”, “auto”, “auto”, G (), G (), ModelID)
get_deformable_model_contours (ModelContours, ModelID, 1)
area_center (ModelImage, Area, Row, Column)
hom_mat2d_identity (HomMat2DIdentity)
hom_mat2d_translate (HomMat2DIdentity, Row, Column, HomMat2DTranslate)
affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)
dev_set_line_width (2)
dev_set_color (“yellow”)
dev_display (ModelImage)
dev_display (ContoursAffinTrans)
disp_message (WindowHandle, “Model image and contours”, “window”, 12, 12, “black”, “true”)
disp_continue_message (WindowHandle, “black”, “true”)
stop ()

视_设值 (Smoothness, 19)
视_设值 (NumImages, 13)
.变量循环首 (1, DD (NumImages, ), 1, Index)
    read_image (Image, 视_加 (“food/cocoa_packages_”, 视_文本格式化 (Index, “02”)))
    dev_resize_window_fit_image (Image, 0, 0, -1, -1, )
    dev_display (Image)
    disp_message (WindowHandle, “Search ...”, “window”, 12, 12, “black”, “true”)
    count_seconds (S1)
    ' Find the model in the deformed search image.
    ' As result, the rectified image, the respective
    ' vector field, and the found contours are queried.
    find_local_deformable_model (Image, ImageRectified, VectorField, DeformedContours, ModelID, rad (-14), rad (28), 1, 1, 1, 1, 0.78, 0, 0, 0, 0.45, G (“image_rectified”, “vector_field”, “deformed_contours”), G (“deformation_smoothness”, “expand_border”, “subpixel”), G (Smoothness, 0, 0), Score, Row, Column)
    count_seconds (S2)
    视_设值 (Time, 视_减 (S2, S1))
    ' Visualize the deformation as a mesh generated from
    ' the returned vector field
    gen_warped_mesh (VectorField, WarpedMesh, G (视_除 (Smoothness, 2)))
    dev_set_line_width (1)
    dev_set_color (“yellow”)
    dev_display (WarpedMesh)
    视_tuple元素赋值 (FoundOut, LL (Index, ), 视_取元素总数 (Score))
    dev_set_line_width (2)
    dev_set_color (“green”)
    dev_display (DeformedContours)
    disp_message (WindowHandle, 视_加 (视_加 (视_加 (视_取元素总数 (Score), “ matches found in ”), 视_文本格式化 (Time, “1.2f”)), “ s”), “window”, 12, 12, “black”, “true”)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Score), 1), ), 1, J)
        disp_message (WindowHandle, 视_加 (“Score: ”, 视_文本格式化 (视_取元素 (Score, J), “.2f”)), “image”, 350, 视_减 (视_取元素 (Column, J), 80), “black”, “true”)
    .变量循环尾 ()
    .如果 (视_小于 (Index, NumImages))
        disp_continue_message (WindowHandle, “black”, “true”)
        stop ()
    .否则

    .如果结束

.变量循环尾 ()

' Clean up
clear_deformable_model (ModelID)
返回 ()

.子程序 gen_lines
.参数 DRow, obj
.参数 DColumn, obj
.参数 Lines, obj, 参考
.参数 Length1, tuple
.参数 Length2, tuple
.参数 Step, tuple
.局部变量 Column1, tuple
.局部变量 ContR, 整数型
.局部变量 Contour, obj
.局部变量 GrayCol, tuple
.局部变量 GrayRow, tuple
.局部变量 Row1, tuple

gen_empty_obj (Lines)
.变量循环首 (0.5, DD (视_减 (视_取元素 (Length1, 0), 1), ), DD (Step, ), ContR)
    tuple_gen_sequence (0.5, 视_减 (视_取元素 (Length2, 0), 1), 1, Column1)
    tuple_gen_const (视_减 (视_取元素 (Length2, 0), 1), ContR, Row1)
    get_grayval_interpolated (DRow, Row1, Column1, “bilinear”, GrayRow)
    get_grayval_interpolated (DColumn, Row1, Column1, “bilinear”, GrayCol)
    gen_contour_polygon_xld (Contour, GrayRow, GrayCol)
    concat_obj (Lines, Contour, Lines)
.变量循环尾 ()
返回 ()

.子程序 gen_warped_mesh
.参数 VectorField, obj
.参数 WarpedMesh, obj, 参考
.参数 Step, tuple
.局部变量 Column, tuple
.局部变量 ContC, 整数型
.局部变量 ContR, 整数型
.局部变量 Contour, obj
.局部变量 DColumn, obj
.局部变量 DRow, obj
.局部变量 GrayColumn, tuple
.局部变量 GrayRow, tuple
.局部变量 Height, tuple
.局部变量 Index, 整数型
.局部变量 Number, tuple
.局部变量 ObjectSelected, obj
.局部变量 Row, tuple
.局部变量 Width, tuple

' Generate a grid of the deformation from the VectorField
' The step width is given by the parameter Step.

gen_empty_obj (WarpedMesh)
count_obj (VectorField, Number)
.变量循环首 (1, DD (Number, ), 1, Index)
    select_obj (VectorField, ObjectSelected, Index)
    vector_field_to_real (ObjectSelected, DRow, DColumn)
    get_image_size (VectorField, Width, Height)
    ' Horizontal lines
    .变量循环首 (0.5, DD (视_减 (视_取元素 (Height, 0), 1), ), DD (Step, ), ContR)
        tuple_gen_sequence (0.5, 视_减 (视_取元素 (Width, 0), 1), 1, Column)
        tuple_gen_const (视_减 (视_取元素 (Width, 0), 1), ContR, Row)
        get_grayval_interpolated (DRow, Row, Column, “bilinear”, GrayRow)
        get_grayval_interpolated (DColumn, Row, Column, “bilinear”, GrayColumn)
        gen_contour_polygon_xld (Contour, GrayRow, GrayColumn)
        concat_obj (WarpedMesh, Contour, WarpedMesh)
    .变量循环尾 ()
    ' Vertical lines
    .变量循环首 (0.5, DD (视_减 (视_取元素 (Width, 0), 1), ), DD (Step, ), ContC)
        tuple_gen_sequence (0.5, 视_减 (视_取元素 (Height, 0), 1), 1, Row)
        tuple_gen_const (视_减 (视_取元素 (Height, 0), 1), ContC, Column)
        get_grayval_interpolated (DRow, Row, Column, “bilinear”, GrayRow)
        get_grayval_interpolated (DColumn, Row, Column, “bilinear”, GrayColumn)
        gen_contour_polygon_xld (Contour, GrayRow, GrayColumn)
        concat_obj (WarpedMesh, Contour, WarpedMesh)
    .变量循环尾 ()
.变量循环尾 ()
返回 ()

.子程序 p_find_cocoa_package_local_deformable
.局部变量 Area, tuple
.局部变量 Column, tuple
.局部变量 ContoursAffinTrans, obj
.局部变量 DeformedContours, obj
.局部变量 FoundOut, tuple
.局部变量 HomMat2DIdentity, tuple
.局部变量 HomMat2DTranslate, tuple
.局部变量 Image, obj
.局部变量 ImageRectified, obj
.局部变量 Index, 整数型
.局部变量 J, 整数型
.局部变量 ModelContours, obj
.局部变量 ModelID, tuple
.局部变量 ModelImage, obj
.局部变量 NumImages, tuple
.局部变量 Row, tuple
.局部变量 S1, tuple
.局部变量 S2, tuple
.局部变量 Score, tuple
.局部变量 Smoothness, tuple
.局部变量 Time, tuple
.局部变量 VectorField, obj
.局部变量 WarpedMesh, obj
.局部变量 WindowHandle, tuple

' This example program shows how to use local deformable
' matching to find objects that are deformed.

' Note that to find deformed objects you can
' - apply shape-based matching using the parameter
' 'max_deformation' or
' - apply local deformable matching.

' In this example, the task is solved with local
' deformable matching. You can compare it to the example
' 'find_cocoa_packages_max_deformations.hdev', which
' solves the same task with shape-based matching and the
' parameter 'max_deformation'. Shape-based matching is
' significantly faster, but local deformable matching is
' more robust to different types of deformations.
' For example, the deformations in the example program
' 'find_peanut_chocolate_candies_local_deformable.hdev'
' can not be handled by shape-based matching.

dev_update_off ()
read_image (ModelImage, “food/cocoa_package_model”)
dev_open_window_fit_image (ModelImage, 0, 0, -1, -1, WindowHandle)
set_display_font (WindowHandle, 16, “mono”, “true”, “false”)

' Create and display the local deformable model
create_local_deformable_model (ModelImage, “auto”, rad (-15), rad (30), “auto”, 1, 1, “auto”, 1, 1, “auto”, “none”, “use_polarity”, “auto”, “auto”, G (), G (), ModelID)
get_deformable_model_contours (ModelContours, ModelID, 1)
area_center (ModelImage, Area, Row, Column)
hom_mat2d_identity (HomMat2DIdentity)
hom_mat2d_translate (HomMat2DIdentity, Row, Column, HomMat2DTranslate)
affine_trans_contour_xld (ModelContours, ContoursAffinTrans, HomMat2DTranslate)
dev_set_line_width (2)
dev_set_color (“yellow”)
dev_display (ModelImage)
dev_display (ContoursAffinTrans)
disp_message (WindowHandle, “Model image and contours”, “window”, 12, 12, “black”, “true”)
wait_seconds (3)

视_设值 (Smoothness, 19)
视_设值 (NumImages, 13)
.变量循环首 (1, DD (NumImages, ), 1, Index)
    read_image (Image, 视_加 (“food/cocoa_packages_”, 视_文本格式化 (Index, “02”)))
    dev_resize_window_fit_image (Image, 0, 0, -1, -1, )
    dev_display (Image)
    disp_message (WindowHandle, “Search ...”, “window”, 12, 12, “black”, “true”)
    count_seconds (S1)
    ' Find the model in the deformed search image.
    ' As result, the rectified image, the respective
    ' vector field, and the found contours are queried.
    find_local_deformable_model (Image, ImageRectified, VectorField, DeformedContours, ModelID, rad (-14), rad (28), 1, 1, 1, 1, 0.78, 0, 0, 0, 0.45, G (“image_rectified”, “vector_field”, “deformed_contours”), G (“deformation_smoothness”, “expand_border”, “subpixel”), G (Smoothness, 0, 0), Score, Row, Column)
    count_seconds (S2)
    视_设值 (Time, 视_减 (S2, S1))
    ' Visualize the deformation as a mesh generated from
    ' the returned vector field
    gen_warped_mesh (VectorField, WarpedMesh, G (视_除 (Smoothness, 2)))
    dev_set_line_width (1)
    dev_set_color (“yellow”)
    dev_display (WarpedMesh)
    视_tuple元素赋值 (FoundOut, LL (Index, ), 视_取元素总数 (Score))
    dev_set_line_width (2)
    dev_set_color (“green”)
    dev_display (DeformedContours)
    disp_message (WindowHandle, 视_加 (视_加 (视_加 (视_取元素总数 (Score), “ matches found in ”), 视_文本格式化 (Time, “1.2f”)), “ s”), “window”, 12, 12, “black”, “true”)
    .变量循环首 (0, DD (视_减 (视_取元素总数 (Score), 1), ), 1, J)
        disp_message (WindowHandle, 视_加 (“Score: ”, 视_文本格式化 (视_取元素 (Score, J), “.2f”)), “image”, 350, 视_减 (视_取元素 (Column, J), 80), “black”, “true”)
    .变量循环尾 ()
    .如果 (视_小于 (Index, 5))
        p_disp_pause_sign (WindowHandle, G (2))
        wait_seconds (2)
    .否则

    .如果结束

.变量循环尾 ()

' Clean up
wait_seconds (3)
clear_deformable_model (ModelID)

dev_close_window ()
返回 ()
